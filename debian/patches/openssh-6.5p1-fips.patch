# comply with FIPS 140-2 by using only approved crypto algorithms
# when OpenSSL is detected to be running in FIPS mode
#
# HG changeset patch
# Parent 6536ed881743cbf05afe962021b985f9b1eab495

diff --git a/Makefile.in b/Makefile.in
--- a/Makefile.in
+++ b/Makefile.in
@@ -77,7 +77,8 @@ LIBSSH_OBJS=authfd.o authfile.o bufaux.o
 	sc25519.o ge25519.o fe25519.o ed25519.o verify.o hash.o blocks.o \
 	kex.o kexdh.o kexgex.o kexecdh.o kexc25519.o \
 	kexdhc.o kexgexc.o kexecdhc.o kexc25519c.o \
-	kexdhs.o kexgexs.o kexecdhs.o kexc25519s.o
+	kexdhs.o kexgexs.o kexecdhs.o kexc25519s.o \
+	fips.o
 
 SSHOBJS= ssh.o readconf.o clientloop.o sshtty.o \
 	sshconnect.o sshconnect1.o sshconnect2.o mux.o \
diff --git a/cipher-ctr.c b/cipher-ctr.c
--- a/cipher-ctr.c
+++ b/cipher-ctr.c
@@ -21,16 +21,17 @@
 
 #include <stdarg.h>
 #include <string.h>
 
 #include <openssl/evp.h>
 
 #include "xmalloc.h"
 #include "log.h"
+#include "fips.h"
 
 /* compatibility with old or broken OpenSSL versions */
 #include "openbsd-compat/openssl-compat.h"
 
 #ifndef USE_BUILTIN_RIJNDAEL
 #include <openssl/aes.h>
 #endif
 
@@ -134,13 +135,15 @@ evp_aes_128_ctr(void)
 	aes_ctr.iv_len = AES_BLOCK_SIZE;
 	aes_ctr.key_len = 16;
 	aes_ctr.init = ssh_aes_ctr_init;
 	aes_ctr.cleanup = ssh_aes_ctr_cleanup;
 	aes_ctr.do_cipher = ssh_aes_ctr;
 #ifndef SSH_OLD_EVP
 	aes_ctr.flags = EVP_CIPH_CBC_MODE | EVP_CIPH_VARIABLE_LENGTH |
 	    EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CUSTOM_IV;
+	if (fips_mode())
+		aes_ctr.flags |= EVP_CIPH_FLAG_FIPS;
 #endif
 	return (&aes_ctr);
 }
 
 #endif /* defined(WITH_OPENSSL) && !defined(OPENSSL_HAVE_EVPCTR) */
diff --git a/cipher.c b/cipher.c
--- a/cipher.c
+++ b/cipher.c
@@ -46,16 +46,17 @@
 #include <stdarg.h>
 #include <stdio.h>
 
 #include "cipher.h"
 #include "misc.h"
 #include "sshbuf.h"
 #include "ssherr.h"
 #include "digest.h"
+#include "fips.h"
 
 #include "openbsd-compat/openssl-compat.h"
 
 #ifdef WITH_SSH1
 extern const EVP_CIPHER *evp_ssh1_bf(void);
 extern const EVP_CIPHER *evp_ssh1_3des(void);
 extern int ssh1_3des_iv(EVP_CIPHER_CTX *, int, u_char *, int);
 #endif
@@ -99,27 +100,52 @@ struct Cipher ciphers[] = {
 	{ "none",	SSH_CIPHER_NONE, 8, 0, 0, 0, 0, CFLAG_NONE, NULL },
 #endif /* WITH_OPENSSL */
 	{ "chacha20-poly1305@openssh.com",
 			SSH_CIPHER_SSH2, 8, 64, 0, 16, 0, CFLAG_CHACHAPOLY, NULL },
 
 	{ NULL,		SSH_CIPHER_INVALID, 0, 0, 0, 0, 0, 0, NULL }
 };
 
+static const struct sshcipher ciphers_fips140_2[] = {
+	{ "none",	SSH_CIPHER_NONE, 8, 0, 0, 0, 0, 0, EVP_enc_null },
+
+	{ "3des-cbc",	SSH_CIPHER_SSH2, 8, 24, 0, 0, 0, 1, EVP_des_ede3_cbc },
+	{ "aes128-cbc",	SSH_CIPHER_SSH2, 16, 16, 0, 0, 0, 1, EVP_aes_128_cbc },
+	{ "aes192-cbc",	SSH_CIPHER_SSH2, 16, 24, 0, 0, 0, 1, EVP_aes_192_cbc },
+	{ "aes256-cbc",	SSH_CIPHER_SSH2, 16, 32, 0, 0, 0, 1, EVP_aes_256_cbc },
+	{ "rijndael-cbc@lysator.liu.se",
+			SSH_CIPHER_SSH2, 16, 32, 0, 0, 0, 1, EVP_aes_256_cbc },
+	{ "aes128-ctr",	SSH_CIPHER_SSH2, 16, 16, 0, 0, 0, 0, EVP_aes_128_ctr },
+	{ "aes192-ctr",	SSH_CIPHER_SSH2, 16, 24, 0, 0, 0, 0, EVP_aes_192_ctr },
+	{ "aes256-ctr",	SSH_CIPHER_SSH2, 16, 32, 0, 0, 0, 0, EVP_aes_256_ctr },
+	{ NULL,		SSH_CIPHER_INVALID, 0, 0, 0, 0, 0, 0, NULL }
+};
+
 /*--*/
 
+static const struct sshcipher *
+fips_select_ciphers(void)
+{
+	if (fips_mode()) {
+		return ciphers_fips140_2;
+	}
+
+	return ciphers;
+}
+
 /* Returns a comma-separated list of supported ciphers. */
 char *
 cipher_alg_list(char sep, int auth_only)
 {
 	char *tmp, *ret = NULL;
 	size_t nlen, rlen = 0;
 	const struct sshcipher *c;
 
-	for (c = ciphers; c->name != NULL; c++) {
+	for (c = fips_select_ciphers(); c->name != NULL; c++) {
 		if (c->number != SSH_CIPHER_SSH2)
 			continue;
 		if (auth_only && c->auth_len == 0)
 			continue;
 		if (ret != NULL)
 			ret[rlen++] = sep;
 		nlen = strlen(c->name);
 		if ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {
@@ -189,27 +214,27 @@ cipher_mask_ssh1(int client)
 	}
 	return mask;
 }
 
 const struct sshcipher *
 cipher_by_name(const char *name)
 {
 	const struct sshcipher *c;
-	for (c = ciphers; c->name != NULL; c++)
+	for (c = fips_select_ciphers(); c->name != NULL; c++)
 		if (strcmp(c->name, name) == 0)
 			return c;
 	return NULL;
 }
 
 const struct sshcipher *
 cipher_by_number(int id)
 {
 	const struct sshcipher *c;
-	for (c = ciphers; c->name != NULL; c++)
+	for (c = fips_select_ciphers(); c->name != NULL; c++)
 		if (c->number == id)
 			return c;
 	return NULL;
 }
 
 #define	CIPHER_SEP	","
 int
 ciphers_valid(const char *names)
@@ -243,17 +268,17 @@ ciphers_valid(const char *names)
  */
 
 int
 cipher_number(const char *name)
 {
 	const struct sshcipher *c;
 	if (name == NULL)
 		return -1;
-	for (c = ciphers; c->name != NULL; c++)
+	for (c = fips_select_ciphers(); c->name != NULL; c++)
 		if (strcasecmp(c->name, name) == 0)
 			return c->number;
 	return -1;
 }
 
 char *
 cipher_name(int id)
 {
@@ -431,16 +456,17 @@ cipher_cleanup(CipherContext *cc)
 /*
  * Selects the cipher, and keys if by computing the MD5 checksum of the
  * passphrase and using the resulting 16 bytes as the key.
  */
 int
 cipher_set_key_string(struct sshcipher_ctx *cc, const struct sshcipher *cipher,
     const char *passphrase, int do_encrypt)
 {
+	/* This function is only used for SSH v1, which is disabled in FIPS mode */
 	u_char digest[16];
 	int r = SSH_ERR_INTERNAL_ERROR;
 
 	if ((r = ssh_digest_memory(SSH_DIGEST_MD5,
 	    passphrase, strlen(passphrase),
 	    digest, sizeof(digest))) != 0)
 		goto out;
 
 	r = cipher_init(cc, cipher, digest, 16, NULL, 0, do_encrypt);
diff --git a/fips.c b/fips.c
new file mode 100644
--- /dev/null
+++ b/fips.c
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2012 Petr Cerny.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <openssl/crypto.h>
+
+#include "fips.h"
+
+#include "log.h"
+
+int
+fips_mode()
+{
+	static int fips_state = -1;
+	if (-1 == fips_state) {
+		fips_state = FIPS_mode();
+		if (fips_state)
+			debug("FIPS mode initialized");
+	}
+	return fips_state;
+}
diff --git a/fips.h b/fips.h
new file mode 100644
--- /dev/null
+++ b/fips.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2012 Petr Cerny.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef FIPS_H
+#define FIPS_H
+
+int	 fips_mode(void);
+
+#endif
+
diff --git a/kex.c b/kex.c
--- a/kex.c
+++ b/kex.c
@@ -50,6 +50,7 @@
 #include "ssherr.h"
 #include "sshbuf.h"
 #include "digest.h"
+#include "fips.h"
 
 #if OPENSSL_VERSION_NUMBER >= 0x00907000L
 # if defined(HAVE_EVP_SHA256)
@@ -105,6 +106,36 @@
 	{ NULL, -1, -1, -1},
 };
 
+static const struct kexalg kexalgs_fips140_2[] = {
+	{ KEX_DH1, KEX_DH_GRP1_SHA1, 0, SSH_DIGEST_SHA1 },
+	{ KEX_DH14, KEX_DH_GRP14_SHA1, 0, SSH_DIGEST_SHA1 },
+	{ KEX_DHGEX_SHA1, KEX_DH_GEX_SHA1, 0, SSH_DIGEST_SHA1 },
+#ifdef HAVE_EVP_SHA256
+	{ KEX_DHGEX_SHA256, KEX_DH_GEX_SHA256, 0, SSH_DIGEST_SHA256 },
+#endif
+#ifdef OPENSSL_HAS_ECC
+	{ KEX_ECDH_SHA2_NISTP256, KEX_ECDH_SHA2,
+	    NID_X9_62_prime256v1, SSH_DIGEST_SHA256 },
+	{ KEX_ECDH_SHA2_NISTP384, KEX_ECDH_SHA2, NID_secp384r1,
+	    SSH_DIGEST_SHA384 },
+# ifdef OPENSSL_HAS_NISTP521
+	{ KEX_ECDH_SHA2_NISTP521, KEX_ECDH_SHA2, NID_secp521r1,
+	    SSH_DIGEST_SHA512 },
+# endif
+#endif
+	{ NULL, -1, -1, -1},
+};
+
+static const struct kexalg *
+fips_select_kexalgs(void)
+{
+	if (fips_mode()) {
+		return kexalgs_fips140_2;
+	}
+
+	return kexalgs;
+}
+
 char *
 kex_alg_list(char sep)
 {
@@ -112,7 +143,7 @@
 	size_t nlen, rlen = 0;
 	const struct kexalg *k;
 
-	for (k = kexalgs; k->name != NULL; k++) {
+	for (k = fips_select_kexalgs(); k->name != NULL; k++) {
 		if (ret != NULL)
 			ret[rlen++] = sep;
 		nlen = strlen(k->name);
@@ -128,7 +159,7 @@
 {
 	const struct kexalg *k;
 
-	for (k = kexalgs; k->name != NULL; k++) {
+	for (k = fips_select_kexalgs(); k->name != NULL; k++) {
 		if (strcmp(k->name, name) == 0)
 			return k;
 	}
diff --git a/mac.c b/mac.c
--- a/mac.c
+++ b/mac.c
@@ -36,16 +36,17 @@
 
 #include "digest.h"
 #include "hmac.h"
 #include "umac.h"
 #include "mac.h"
 #include "misc.h"
 #include "ssherr.h"
 #include "sshbuf.h"
+#include "fips.h"
 
 #include "openbsd-compat/openssl-compat.h"
 
 #define SSH_DIGEST	1	/* SSH_DIGEST_XXX */
 #define SSH_UMAC	2	/* UMAC (not integrated with OpenSSL) */
 #define SSH_UMAC128	3
 
 struct macalg {
@@ -86,25 +87,44 @@ struct {
 	{ "hmac-md5-96-etm@openssh.com",	SSH_DIGEST, SSH_DIGEST_MD5, 96, 0, 0, 1 },
 	{ "hmac-ripemd160-etm@openssh.com",	SSH_DIGEST, SSH_DIGEST_RIPEMD160, 0, 0, 0, 1 },
 	{ "umac-64-etm@openssh.com",		SSH_UMAC, 0, 0, 128, 64, 1 },
 	{ "umac-128-etm@openssh.com",		SSH_UMAC128, 0, 0, 128, 128, 1 },
 
 	{ NULL,					0, 0, 0, 0, 0, 0 }
 };
 
+static const struct macalg macs_fips140_2[] = {
+	{ "hmac-sha1",				SSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 0 },
+#ifdef HAVE_EVP_SHA256
+	{ "hmac-sha2-256",			SSH_DIGEST, SSH_DIGEST_SHA256, 0, 0, 0, 0 },
+	{ "hmac-sha2-512",			SSH_DIGEST, SSH_DIGEST_SHA512, 0, 0, 0, 0 },
+#endif
+	{ NULL,					0, 0, 0, 0, 0, 0 }
+};
+
+static const struct macalg *
+fips_select_macs(void)
+{
+	if (fips_mode()) {
+		return macs_fips140_2;
+	}
+
+	return macs;
+}
+
 /* Returns a list of supported MACs separated by the specified char. */
 char *
 mac_alg_list(char sep)
 {
 	char *ret = NULL, *tmp;
 	size_t nlen, rlen = 0;
 	const struct macalg *m;
 
-	for (m = macs; m->name != NULL; m++) {
+	for (m = fips_select_macs(); m->name != NULL; m++) {
 		if (ret != NULL)
 			ret[rlen++] = sep;
 		nlen = strlen(m->name);
 		if ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {
 			free(ret);
 			return NULL;
 		}
 		ret = tmp;
@@ -131,17 +151,17 @@ mac_setup_by_alg(Mac *mac, const struct macalg *macalg)
 	return 0;
 }
 
 int
 mac_setup(struct sshmac *mac, char *name)
 {
 	const struct macalg *m;
 
-	for (m = macs; m->name != NULL; m++) {
+	for (m = fips_select_macs(); m->name != NULL; m++) {
 		if (strcmp(name, m->name) != 0)
 			continue;
 		if (mac != NULL)
 			return mac_setup_by_alg(mac, m);
 		return 0;
 	}
 	return SSH_ERR_INVALID_ARGUMENT;
 }
diff --git a/myproposal.h b/myproposal.h
--- a/myproposal.h
+++ b/myproposal.h
@@ -83,36 +83,62 @@
 	"diffie-hellman-group14-sha1," \
 	"diffie-hellman-group1-sha1" 
 
 #define KEX_CLIENT_KEX KEX_COMMON_KEX \
 	"diffie-hellman-group-exchange-sha1," \
 	"diffie-hellman-group14-sha1," \
 	"diffie-hellman-group1-sha1"
 
-#define	KEX_DEFAULT_PK_ALG	\
+#define KEX_FIPS_140_2_SERVER_KEX \
+	KEX_ECDH_METHODS \
+	KEX_SHA256_METHODS \
+	"diffie-hellman-group14-sha1," \
+	"diffie-hellman-group1-sha1"
+
+#define KEX_FIPS_140_2_CLIENT_KEX \
+	KEX_ECDH_METHODS \
+	KEX_SHA256_METHODS \
+	"diffie-hellman-group-exchange-sha1," \
+	"diffie-hellman-group14-sha1," \
+	"diffie-hellman-group1-sha1"
+
+#define	KEX_DEFAULT_PK_ALG      \
 	HOSTKEY_ECDSA_CERT_METHODS \
 	"ssh-ed25519-cert-v01@openssh.com," \
 	"ssh-rsa-cert-v01@openssh.com," \
 	HOSTKEY_ECDSA_METHODS \
 	"ssh-ed25519," \
 	"ssh-rsa" \
 
+#define	KEX_FIPS_140_2_PK_ALG      \
+	HOSTKEY_ECDSA_CERT_METHODS \
+	"ssh-rsa-cert-v01@openssh.com," \
+	HOSTKEY_ECDSA_METHODS \
+	"ssh-rsa"
+
 /* the actual algorithms */
 
 #define KEX_SERVER_ENCRYPT \
 	"chacha20-poly1305@openssh.com," \
 	"aes128-ctr,aes192-ctr,aes256-ctr" \
 	AESGCM_CIPHER_MODES
 
 #define KEX_CLIENT_ENCRYPT KEX_SERVER_ENCRYPT "," \
 	"arcfour256,arcfour128," \
 	"aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc," \
 	"aes192-cbc,aes256-cbc,arcfour,rijndael-cbc@lysator.liu.se"
 
+#define	KEX_FIPS_140_2_SERVER_ENCRYPT \
+	"aes128-ctr,aes192-ctr,aes256-ctr," \
+	"aes128-cbc,3des-cbc," \
+	"aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se"
+
+#define	KEX_FIPS_140_2_CLIENT_ENCRYPT KEX_FIPS_140_2_SERVER_ENCRYPT
+
 #define KEX_SERVER_MAC \
 	"umac-64-etm@openssh.com," \
 	"umac-128-etm@openssh.com," \
 	"hmac-sha2-256-etm@openssh.com," \
 	"hmac-sha2-512-etm@openssh.com," \
 	"hmac-sha1-etm@openssh.com," \
 	"umac-64@openssh.com," \
 	"umac-128@openssh.com," \
@@ -125,16 +151,23 @@
 	"hmac-sha1-96-etm@openssh.com," \
 	"hmac-md5-96-etm@openssh.com," \
 	"hmac-md5," \
 	"hmac-ripemd160," \
 	"hmac-ripemd160@openssh.com," \
 	"hmac-sha1-96," \
 	"hmac-md5-96"
 
+#define	KEX_FIPS_140_2_SERVER_MAC \
+	"hmac-sha2-256," \
+	"hmac-sha2-512," \
+	"hmac-sha1"
+
+#define	KEX_FIPS_140_2_CLIENT_MAC KEX_FIPS_140_2_SERVER_MAC
+
 #else
 
 #define KEX_SERVER_KEX		\
 	"curve25519-sha256@libssh.org"
 #define	KEX_DEFAULT_PK_ALG	\
 	"ssh-ed25519-cert-v01@openssh.com," \
 	"ssh-ed25519"
 #define	KEX_SERVER_ENCRYPT \
diff --git a/openbsd-compat/arc4random.c b/openbsd-compat/arc4random.c
--- a/openbsd-compat/arc4random.c
+++ b/openbsd-compat/arc4random.c
@@ -32,16 +32,17 @@
 #ifndef HAVE_ARC4RANDOM
 
 #ifdef WITH_OPENSSL
 #include <openssl/rand.h>
 #include <openssl/err.h>
 #endif
 
 #include "log.h"
+#include "fips.h"
 
 #define KEYSTREAM_ONLY
 #include "chacha_private.h"
 
 #ifdef __GNUC__
 #define inline __inline
 #else				/* !__GNUC__ */
 #define inline
@@ -161,59 +162,71 @@
 	memset(rs_buf + RSBUFSZ - rs_have, 0, sizeof(*val));
 	rs_have -= sizeof(*val);
 	return;
 }
 
 void
 arc4random_stir(void)
 {
-	_ARC4_LOCK();
-	_rs_stir();
-	_ARC4_UNLOCK();
+	if (!fips_mode()) {
+		_ARC4_LOCK();
+		_rs_stir();
+		_ARC4_UNLOCK();
+	}
 }
 
 void
 arc4random_addrandom(u_char *dat, int datlen)
 {
-	int m;
+	if (!fips_mode()) {
+		int m;
 
-	_ARC4_LOCK();
-	if (!rs_initialized)
-		_rs_stir();
-	while (datlen > 0) {
-		m = MIN(datlen, KEYSZ + IVSZ);
-		_rs_rekey(dat, m);
-		dat += m;
-		datlen -= m;
+		_ARC4_LOCK();
+		if (!rs_initialized)
+			_rs_stir();
+		while (datlen > 0) {
+			m = MIN(datlen, KEYSZ + IVSZ);
+			_rs_rekey(dat, m);
+			dat += m;
+			datlen -= m;
+		}
+		_ARC4_UNLOCK();
 	}
-	_ARC4_UNLOCK();
 }
 
 u_int32_t
 arc4random(void)
 {
 	u_int32_t val;
 
 	_ARC4_LOCK();
-	_rs_random_u32(&val);
+	if (fips_mode()) {
+		RAND_bytes((u_int8_t *)&val, sizeof(val));
+	} else {
+		_rs_random_u32(&val);
+	}
 	_ARC4_UNLOCK();
 	return val;
 }
 
 /*
  * If we are providing arc4random, then we can provide a more efficient 
  * arc4random_buf().
  */
 # ifndef HAVE_ARC4RANDOM_BUF
 void
 arc4random_buf(void *buf, size_t n)
 {
 	_ARC4_LOCK();
-	_rs_random_buf(buf, n);
+	if (fips_mode()) {
+		RAND_bytes(buf, n);
+	} else {
+		_rs_random_buf(buf, n);
+	}
 	_ARC4_UNLOCK();
 }
 # endif /* !HAVE_ARC4RANDOM_BUF */
 #endif /* !HAVE_ARC4RANDOM */
 
 /* arc4random_buf() that uses platform arc4random() */
 #if !defined(HAVE_ARC4RANDOM_BUF) && defined(HAVE_ARC4RANDOM)
 void
diff --git a/ssh.c b/ssh.c
--- a/ssh.c
+++ b/ssh.c
@@ -99,16 +99,17 @@
 #include "sshpty.h"
 #include "match.h"
 #include "msg.h"
 #include "uidswap.h"
 #include "roaming.h"
 #include "version.h"
 #include "ssherr.h"
 #include "myproposal.h"
+#include "fips.h"
 
 #ifdef ENABLE_PKCS11
 #include "ssh-pkcs11.h"
 #endif
 
 extern char *__progname;
 
 /* Saves a copy of argv for setproctitle emulation */
@@ -453,16 +454,18 @@ main(int ac, char **av)
 	logfile = NULL;
 	argv0 = av[0];
 
  again:
 	while ((opt = getopt(ac, av, "1246ab:c:e:fgi:kl:m:no:p:qstvx"
 	    "ACD:E:F:GI:KL:MNO:PQ:R:S:TVw:W:XYy")) != -1) {
 		switch (opt) {
 		case '1':
+			if (fips_mode())
+				fatal("Protocol 1 not allowed in the FIPS mode.");
 			options.protocol = SSH_PROTO_1;
 			break;
 		case '2':
 			options.protocol = SSH_PROTO_2;
 			break;
 		case '4':
 			options.address_family = AF_INET;
 			break;
@@ -809,16 +812,18 @@
 				fprintf(stderr, "Unknown cipher type '%s'\n",
 				    optarg);
 				exit(255);
 			}
 			if (options.cipher == SSH_CIPHER_3DES)
 				options.ciphers = xstrdup("3des-cbc");
 			else if (options.cipher == SSH_CIPHER_BLOWFISH)
 				options.ciphers = xstrdup("blowfish-cbc");
+			else if (fips_mode())
+				options.ciphers = xstrdup(KEX_FIPS_140_2_CLIENT_ENCRYPT);
 			else
 				options.ciphers = xstrdup(KEX_CLIENT_ENCRYPT);
 			break;
 		case 'm':
 			if (mac_valid(optarg))
 				options.macs = xstrdup(optarg);
 			else {
 				fprintf(stderr, "Unknown mac type '%s'\n",
@@ -959,16 +964,22 @@ main(int ac, char **av)
 	if (addrs == NULL && options.proxy_command == NULL) {
 		if ((addrs = resolve_host(host, options.port, 1,
 		    cname, sizeof(cname))) == NULL)
 			cleanup_exit(255); /* resolve_host logs the error */
 	}
 
 	timeout_ms = options.connection_timeout * 1000;
 
+	if (fips_mode()) {
+		options.protocol &= SSH_PROTO_2;
+		if (options.protocol == 0)
+			fatal("Protocol 2 disabled by configuration but required in the FIPS mode");
+	}
+
 	/* Open a connection to the remote host. */
 	if (ssh_connect(host, addrs, &hostaddr, options.port,
 	    options.address_family, options.connection_attempts,
 	    &timeout_ms, options.tcp_keep_alive,
 	    options.use_privileged_port) != 0)
  		exit(255);
 
 	if (addrs != NULL)
diff --git a/sshconnect2.c b/sshconnect2.c
index 7751031..4dec07c 100644
--- a/sshconnect2.c
+++ b/sshconnect2.c
@@ -71,6 +71,7 @@
 #include "uidswap.h"
 #include "hostfile.h"
 #include "ssherr.h"
+#include "fips.h"
 
 #ifdef GSSAPI
 #include "ssh-gss.h"
@@ -116,7 +117,7 @@ order_hostkeyalgs(char *host, struct sockaddr *hostaddr, u_short port)
 	for (i = 0; i < options.num_system_hostfiles; i++)
 		load_hostkeys(hostkeys, hostname, options.system_hostfiles[i]);
 
-	oavail = avail = xstrdup(KEX_DEFAULT_PK_ALG);
+	oavail = avail = xstrdup(fips_mode() ? KEX_FIPS_140_2_PK_ALG : KEX_DEFAULT_PK_ALG);
 	maxlen = strlen(avail) + 1;
 	first = xmalloc(maxlen);
 	last = xmalloc(maxlen);
@@ -179,14 +180,14 @@ ssh_kex2(char *host, struct sockaddr *hostaddr, u_short port)
 	myproposal[PROPOSAL_MAC_ALGS_CTOS] =
 	    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;
 	if (options.hostkeyalgorithms != NULL) {
-		if (kex_assemble_names(KEX_DEFAULT_PK_ALG,
+		if (kex_assemble_names(fips_mode() ? KEX_FIPS_140_2_PK_ALG : KEX_DEFAULT_PK_ALG,
 		    &options.hostkeyalgorithms) != 0)
 			fatal("%s: kex_assemble_namelist", __func__);
 		myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =
 		    compat_pkalg_proposal(options.hostkeyalgorithms);
 	} else {
 		/* Enforce default */
-		options.hostkeyalgorithms = xstrdup(KEX_DEFAULT_PK_ALG);
+		options.hostkeyalgorithms = xstrdup(fips_mode() ? KEX_FIPS_140_2_PK_ALG : KEX_DEFAULT_PK_ALG);
 		/* Prefer algorithms that we already have keys for */
 		myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =
 		    compat_pkalg_proposal(
diff --git a/sshd.c b/sshd.c
--- a/sshd.c
+++ b/sshd.c
@@ -116,16 +116,17 @@
 #ifdef GSSAPI
 #include "ssh-gss.h"
 #endif
 #include "monitor_wrap.h"
 #include "roaming.h"
 #include "ssh-sandbox.h"
 #include "version.h"
 #include "ssherr.h"
+#include "fips.h"
 
 #ifndef O_NOCTTY
 #define O_NOCTTY	0
 #endif
 
 /* Re-exec fds */
 #define REEXEC_DEVCRYPTO_RESERVED_FD	(STDERR_FILENO + 1)
 #define REEXEC_STARTUP_PIPE_FD		(STDERR_FILENO + 2)
@@ -1712,16 +1719,20 @@ main(int ac, char **av)
 		if ((fp = sshkey_fingerprint(pubkey, options.fingerprint_hash,
 		    SSH_FP_DEFAULT)) == NULL)
 			fatal("sshkey_fingerprint failed");
 		debug("%s host key #%d: %s %s",
 		    key ? "private" : "agent", i, keytype == KEY_RSA1 ?
 		    sshkey_type(pubkey) : sshkey_ssh_name(pubkey), fp);
 		free(fp);
 	}
+	if ((options.protocol & SSH_PROTO_1) && fips_mode()) {
+		logit("Disabling protocol version 1. Not allowed in the FIPS mode.");
+		options.protocol &= ~SSH_PROTO_1;
+	}
 	if ((options.protocol & SSH_PROTO_1) && !sensitive_data.have_ssh1_key) {
 		logit("Disabling protocol version 1. Could not load host key");
 		options.protocol &= ~SSH_PROTO_1;
 	}
 	if ((options.protocol & SSH_PROTO_2) && !sensitive_data.have_ssh2_key) {
 		logit("Disabling protocol version 2. Could not load host key");
 		options.protocol &= ~SSH_PROTO_2;
 	}
diff --git a/ssh-dss.c b/ssh-dss.c
--- a/ssh-dss.c
+++ b/ssh-dss.c
@@ -42,41 +42,74 @@
 
 #define INTBLOB_LEN	20
 #define SIGBLOB_LEN	(2*INTBLOB_LEN)
 
 int
 ssh_dss_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
     const u_char *data, size_t datalen, u_int compat)
 {
+	const EVP_MD *evp_md = EVP_dss1();
+	EVP_MD_CTX md;
+	u_char *tsig;
+	const unsigned char *psig;
+	EVP_PKEY *pkey;
+	int signature_ok = 0;
 	DSA_SIG *sig = NULL;
-	u_char digest[SSH_DIGEST_MAX_LENGTH], sigblob[SIGBLOB_LEN];
-	size_t rlen, slen, len, dlen = ssh_digest_bytes(SSH_DIGEST_SHA1);
+	u_char sigblob[SIGBLOB_LEN];
+	size_t rlen, slen;
+	u_int len = 0;
 	struct sshbuf *b = NULL;
 	int ret = SSH_ERR_INVALID_ARGUMENT;
 
 	if (lenp != NULL)
 		*lenp = 0;
 	if (sigp != NULL)
 		*sigp = NULL;
 
 	if (key == NULL || key->dsa == NULL ||
 	    sshkey_type_plain(key->type) != KEY_DSA)
 		return SSH_ERR_INVALID_ARGUMENT;
-	if (dlen == 0)
-		return SSH_ERR_INTERNAL_ERROR;
 
-	if ((ret = ssh_digest_memory(SSH_DIGEST_SHA1, data, datalen,
-	    digest, sizeof(digest))) != 0)
-		goto out;
+	pkey = EVP_PKEY_new();
+	if (pkey == NULL) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+
+	EVP_PKEY_set1_DSA(pkey, key->dsa);
+	slen = EVP_PKEY_size(pkey);
+	if ((psig = tsig = malloc(slen)) == NULL) {
+		EVP_PKEY_free(pkey);
+		ret = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+
+	EVP_MD_CTX_init(&md);
+	if (EVP_SignInit_ex(&md, evp_md, NULL) == 1 &&
+	    EVP_SignUpdate(&md, data, datalen) == 1) {
+		signature_ok = EVP_SignFinal(&md, tsig, &len, pkey);
+	}
+	EVP_MD_CTX_cleanup(&md);
+	EVP_PKEY_free(pkey);
+
+	if (signature_ok != 1) {
+		free(tsig);
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
 
-	if ((sig = DSA_do_sign(digest, dlen, key->dsa)) == NULL) {
-		ret = SSH_ERR_LIBCRYPTO_ERROR;
-		goto out;
-	}
+	/* Output of EVP_SignFinal() is encoded, convert to DSA_SIG */
+	sig = d2i_DSA_SIG(NULL, &psig, len);
+	explicit_bzero(tsig, len);
+	free(tsig);
+ 	if (sig == NULL) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+ 	}
 
 	rlen = BN_num_bytes(sig->r);
 	slen = BN_num_bytes(sig->s);
 	if (rlen > INTBLOB_LEN || slen > INTBLOB_LEN) {
 		ret = SSH_ERR_INTERNAL_ERROR;
 		goto out;
 	}
 	explicit_bzero(sigblob, SIGBLOB_LEN);
@@ -106,41 +139,42 @@
 			}
 			memcpy(*sigp, sshbuf_ptr(b), len);
 		}
 		if (lenp != NULL)
 			*lenp = len;
 		ret = 0;
 	}
  out:
-	explicit_bzero(digest, sizeof(digest));
 	if (sig != NULL)
 		DSA_SIG_free(sig);
 	if (b != NULL)
 		sshbuf_free(b);
 	return ret;
 }
 
 int
 ssh_dss_verify(const struct sshkey *key,
     const u_char *signature, size_t signaturelen,
     const u_char *data, size_t datalen, u_int compat)
 {
+	const EVP_MD *evp_md = EVP_dss1();
+	EVP_MD_CTX md;
+	u_char *psig, *tsig;
+	EVP_PKEY *pkey;
 	DSA_SIG *sig = NULL;
-	u_char digest[SSH_DIGEST_MAX_LENGTH], *sigblob = NULL;
-	size_t len, dlen = ssh_digest_bytes(SSH_DIGEST_SHA1);
+	u_char *sigblob = NULL;
+	size_t len;
 	int ret = SSH_ERR_INTERNAL_ERROR;
 	struct sshbuf *b = NULL;
 	char *ktype = NULL;
 
 	if (key == NULL || key->dsa == NULL ||
 	    sshkey_type_plain(key->type) != KEY_DSA)
 		return SSH_ERR_INVALID_ARGUMENT;
-	if (dlen == 0)
-		return SSH_ERR_INTERNAL_ERROR;
 
 	/* fetch signature */
 	if (compat & SSH_BUG_SIGBLOB) {
 		if ((sigblob = malloc(signaturelen)) == NULL)
 			return SSH_ERR_ALLOC_FAIL;
 		memcpy(sigblob, signature, signaturelen);
 		len = signaturelen;
 	} else {
@@ -166,35 +200,53 @@
 		goto out;
 	}
 	if ((BN_bin2bn(sigblob, INTBLOB_LEN, sig->r) == NULL) ||
 	    (BN_bin2bn(sigblob+ INTBLOB_LEN, INTBLOB_LEN, sig->s) == NULL)) {
 		ret = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
 	}
 
-	/* sha1 the data */
-	if ((ret = ssh_digest_memory(SSH_DIGEST_SHA1, data, datalen,
-	    digest, sizeof(digest))) != 0)
-		goto out;
+	/* Sig is a DSA_SIG structure; convert to encoded buffer */
+	len = i2d_DSA_SIG(sig, NULL);
+	if ((psig = tsig = malloc(len)) == NULL) {
+		ret = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	i2d_DSA_SIG(sig, &psig);
+
+	/* Verify the signature */
+	pkey = EVP_PKEY_new();
+	if (pkey != NULL) {
+		EVP_PKEY_set1_DSA(pkey, key->dsa);
+
+		EVP_MD_CTX_init(&md);
+		if (EVP_VerifyInit(&md, evp_md) == 1 &&
+		    EVP_VerifyUpdate(&md, data, datalen) == 1) {
+			ret = EVP_VerifyFinal(&md, tsig, len, pkey);
+		}
+		EVP_MD_CTX_cleanup(&md);
+		EVP_PKEY_free(pkey);
+	}
+	explicit_bzero(tsig, len);
+	free(tsig);
 
-	switch (DSA_do_verify(digest, dlen, sig, key->dsa)) {
+	switch (ret) {
 	case 1:
 		ret = 0;
 		break;
 	case 0:
 		ret = SSH_ERR_SIGNATURE_INVALID;
 		goto out;
 	default:
 		ret = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
 	}
 
  out:
-	explicit_bzero(digest, sizeof(digest));
 	if (sig != NULL)
 		DSA_SIG_free(sig);
 	if (b != NULL)
 		sshbuf_free(b);
 	if (ktype != NULL)
 		free(ktype);
 	if (sigblob != NULL) {
 		explicit_bzero(sigblob, len);
diff --git a/ssh-rsa.c b/ssh-rsa.c
--- a/ssh-rsa.c
+++ b/ssh-rsa.c
@@ -29,60 +29,68 @@
 
 #include "sshbuf.h"
 #include "compat.h"
 #include "ssherr.h"
 #define SSHKEY_INTERNAL
 #include "sshkey.h"
 #include "digest.h"
 
-static int openssh_RSA_verify(int, u_char *, size_t, u_char *, size_t, RSA *);
-
 /* RSASSA-PKCS1-v1_5 (PKCS #1 v2.0 signature) with SHA1 */
 int
 ssh_rsa_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
     const u_char *data, size_t datalen, u_int compat)
 {
-	int hash_alg;
-	u_char digest[SSH_DIGEST_MAX_LENGTH], *sig = NULL;
-	size_t slen;
-	u_int dlen, len;
-	int nid, ret = SSH_ERR_INTERNAL_ERROR;
+	const EVP_MD *evp_md = EVP_sha1();
+	EVP_MD_CTX md;
+	EVP_PKEY *pkey;
+	u_char *sig = NULL;
+	size_t slen;
+	u_int len = 0;
+	int ret = SSH_ERR_INTERNAL_ERROR;
 	struct sshbuf *b = NULL;
 
 	if (lenp != NULL)
 		*lenp = 0;
 	if (sigp != NULL)
 		*sigp = NULL;
 
 	if (key == NULL || key->rsa == NULL ||
 	    sshkey_type_plain(key->type) != KEY_RSA)
 		return SSH_ERR_INVALID_ARGUMENT;
-	slen = RSA_size(key->rsa);
-	if (slen <= 0 || slen > SSHBUF_MAX_BIGNUM)
-		return SSH_ERR_INVALID_ARGUMENT;
 
 	/* hash the data */
-	hash_alg = SSH_DIGEST_SHA1;
-	nid = NID_sha1;
-	if ((dlen = ssh_digest_bytes(hash_alg)) == 0)
-		return SSH_ERR_INTERNAL_ERROR;
-	if ((ret = ssh_digest_memory(hash_alg, data, datalen,
-	    digest, sizeof(digest))) != 0)
-		goto out;
+	pkey = EVP_PKEY_new();
+	if (pkey == NULL)
+		return SSH_ERR_LIBCRYPTO_ERROR;
+	EVP_PKEY_set1_RSA(pkey, key->rsa);
+	slen = EVP_PKEY_size(pkey);
+	if (slen <= 0 || slen > SSHBUF_MAX_BIGNUM) {
+		EVP_PKEY_free(pkey);
+		return SSH_ERR_INVALID_ARGUMENT;
+	}
 
 	if ((sig = malloc(slen)) == NULL) {
+		EVP_PKEY_free(pkey);
 		ret = SSH_ERR_ALLOC_FAIL;
 		goto out;
 	}
 
-	if (RSA_sign(nid, digest, dlen, sig, &len, key->rsa) != 1) {
-		ret = SSH_ERR_LIBCRYPTO_ERROR;
-		goto out;
-	}
+	EVP_MD_CTX_init(&md);
+	if (EVP_SignInit_ex(&md, evp_md, NULL) != 1 ||
+	    EVP_SignUpdate(&md, data, datalen) != 1 ||
+	    EVP_SignFinal(&md, sig, &len, pkey) != 1) {
+		EVP_MD_CTX_cleanup(&md);
+		EVP_PKEY_free(pkey);
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	EVP_MD_CTX_cleanup(&md);
+	EVP_PKEY_free(pkey);
+
 	if (len < slen) {
 		size_t diff = slen - len;
 		memmove(sig + diff, sig, len);
 		explicit_bzero(sig, diff);
 	} else if (len > slen) {
 		ret = SSH_ERR_INTERNAL_ERROR;
 		goto out;
 	}
@@ -107,36 +115,38 @@
 			goto out;
 		}
 		memcpy(*sigp, sshbuf_ptr(b), len);
 	}
 	if (lenp != NULL)
 		*lenp = len;
 	ret = 0;
  out:
-	explicit_bzero(digest, sizeof(digest));
 	if (sig != NULL) {
 		explicit_bzero(sig, slen);
 		free(sig);
 	}
 	if (b != NULL)
 		sshbuf_free(b);
 	return ret;
 }
 
 int
 ssh_rsa_verify(const struct sshkey *key,
     const u_char *signature, size_t signaturelen,
     const u_char *data, size_t datalen, u_int compat)
 {
+	const EVP_MD *evp_md = EVP_sha1();
+	EVP_MD_CTX md;
+	EVP_PKEY *pkey;
 	char *ktype = NULL;
-	int hash_alg, ret = SSH_ERR_INTERNAL_ERROR;
-	size_t len, diff, modlen, dlen;
+	int ret = SSH_ERR_INTERNAL_ERROR;
+	size_t len, diff, modlen;
 	struct sshbuf *b = NULL;
-	u_char digest[SSH_DIGEST_MAX_LENGTH], *osigblob, *sigblob = NULL;
+	u_char *osigblob, *sigblob = NULL;
 
 	if (key == NULL || key->rsa == NULL ||
 	    sshkey_type_plain(key->type) != KEY_RSA ||
 	    BN_num_bits(key->rsa->n) < SSH_RSA_MINIMUM_MODULUS_SIZE)
 		return SSH_ERR_INVALID_ARGUMENT;
 
 	if ((b = sshbuf_from(signature, signaturelen)) == NULL)
 		return SSH_ERR_ALLOC_FAIL;
@@ -160,107 +170,38 @@
 			sigblob = osigblob; /* put it back for clear/free */
 			ret = SSH_ERR_ALLOC_FAIL;
 			goto out;
 		}
 		memmove(sigblob + diff, sigblob, len);
 		explicit_bzero(sigblob, diff);
 		len = modlen;
 	}
-	hash_alg = SSH_DIGEST_SHA1;
-	if ((dlen = ssh_digest_bytes(hash_alg)) == 0) {
-		ret = SSH_ERR_INTERNAL_ERROR;
-		goto out;
-	}
-	if ((ret = ssh_digest_memory(hash_alg, data, datalen,
-	    digest, sizeof(digest))) != 0)
-		goto out;
+	pkey = EVP_PKEY_new();
+	if (pkey != NULL) {
+		EVP_PKEY_set1_RSA(pkey, key->rsa);
+
+		EVP_MD_CTX_init(&md);
+		if (EVP_VerifyInit_ex(&md, evp_md, NULL) != 1 ||
+		    EVP_VerifyUpdate(&md, data, datalen) != 1 ||
+		    EVP_VerifyFinal(&md, sigblob, len, pkey) != 1) {
+			EVP_MD_CTX_cleanup(&md);
+			EVP_PKEY_free(pkey);
+			ret = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		EVP_MD_CTX_cleanup(&md);
+		EVP_PKEY_free(pkey);
+	}
 
-	ret = openssh_RSA_verify(hash_alg, digest, dlen, sigblob, len,
-	    key->rsa);
  out:
 	if (sigblob != NULL) {
 		explicit_bzero(sigblob, len);
 		free(sigblob);
 	}
 	if (ktype != NULL)
 		free(ktype);
 	if (b != NULL)
 		sshbuf_free(b);
-	explicit_bzero(digest, sizeof(digest));
 	return ret;
 }
 
-/*
- * See:
- * http://www.rsasecurity.com/rsalabs/pkcs/pkcs-1/
- * ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1.asn
- */
-/*
- * id-sha1 OBJECT IDENTIFIER ::= { iso(1) identified-organization(3)
- *	oiw(14) secsig(3) algorithms(2) 26 }
- */
-static const u_char id_sha1[] = {
-	0x30, 0x21, /* type Sequence, length 0x21 (33) */
-	0x30, 0x09, /* type Sequence, length 0x09 */
-	0x06, 0x05, /* type OID, length 0x05 */
-	0x2b, 0x0e, 0x03, 0x02, 0x1a, /* id-sha1 OID */
-	0x05, 0x00, /* NULL */
-	0x04, 0x14  /* Octet string, length 0x14 (20), followed by sha1 hash */
-};
-
-static int
-openssh_RSA_verify(int hash_alg, u_char *hash, size_t hashlen,
-    u_char *sigbuf, size_t siglen, RSA *rsa)
-{
-	size_t ret, rsasize = 0, oidlen = 0, hlen = 0;
-	int len, oidmatch, hashmatch;
-	const u_char *oid = NULL;
-	u_char *decrypted = NULL;
-
-	ret = SSH_ERR_INTERNAL_ERROR;
-	switch (hash_alg) {
-	case SSH_DIGEST_SHA1:
-		oid = id_sha1;
-		oidlen = sizeof(id_sha1);
-		hlen = 20;
-		break;
-	default:
-		goto done;
-	}
-	if (hashlen != hlen) {
-		ret = SSH_ERR_INVALID_ARGUMENT;
-		goto done;
-	}
-	rsasize = RSA_size(rsa);
-	if (rsasize <= 0 || rsasize > SSHBUF_MAX_BIGNUM ||
-	    siglen == 0 || siglen > rsasize) {
-		ret = SSH_ERR_INVALID_ARGUMENT;
-		goto done;
-	}
-	if ((decrypted = malloc(rsasize)) == NULL) {
-		ret = SSH_ERR_ALLOC_FAIL;
-		goto done;
-	}
-	if ((len = RSA_public_decrypt(siglen, sigbuf, decrypted, rsa,
-	    RSA_PKCS1_PADDING)) < 0) {
-		ret = SSH_ERR_LIBCRYPTO_ERROR;
-		goto done;
-	}
-	if (len < 0 || (size_t)len != hlen + oidlen) {
-		ret = SSH_ERR_INVALID_FORMAT;
-		goto done;
-	}
-	oidmatch = timingsafe_bcmp(decrypted, oid, oidlen) == 0;
-	hashmatch = timingsafe_bcmp(decrypted + oidlen, hash, hlen) == 0;
-	if (!oidmatch || !hashmatch) {
-		ret = SSH_ERR_SIGNATURE_INVALID;
-		goto done;
-	}
-	ret = 0;
-done:
-	if (decrypted) {
-		explicit_bzero(decrypted, rsasize);
-		free(decrypted);
-	}
-	return ret;
-}
 #endif /* WITH_OPENSSL */
diff --git a/sshkey.c b/sshkey.c
index dbb16e2..9508b8f 100644
--- a/sshkey.c
+++ b/sshkey.c
@@ -58,6 +58,7 @@
 #define SSHKEY_INTERNAL
 #include "sshkey.h"
 #include "match.h"
+#include "fips.h"
 
 /* openssh private key file format */
 #define MARK_BEGIN		"-----BEGIN OPENSSH PRIVATE KEY-----\n"
@@ -115,12 +116,49 @@ static const struct keytype keytypes[] = {
 	{ NULL, NULL, -1, -1, 0 }
 };
 
+static const struct keytype keytypes_fips140_2[] = {
+#ifdef WITH_OPENSSL
+	{ "ssh-rsa", "RSA", KEY_RSA, 0, 0 },
+	{ "ssh-dss", "DSA", KEY_DSA, 0, 0 },
+# ifdef OPENSSL_HAS_ECC
+	{ "ecdsa-sha2-nistp256", "ECDSA", KEY_ECDSA, NID_X9_62_prime256v1, 0 },
+	{ "ecdsa-sha2-nistp384", "ECDSA", KEY_ECDSA, NID_secp384r1, 0 },
+#  ifdef OPENSSL_HAS_NISTP521
+	{ "ecdsa-sha2-nistp521", "ECDSA", KEY_ECDSA, NID_secp521r1, 0 },
+#  endif /* OPENSSL_HAS_NISTP521 */
+# endif /* OPENSSL_HAS_ECC */
+	{ "ssh-rsa-cert-v01@openssh.com", "RSA-CERT", KEY_RSA_CERT, 0, 1 },
+	{ "ssh-dss-cert-v01@openssh.com", "DSA-CERT", KEY_DSA_CERT, 0, 1 },
+# ifdef OPENSSL_HAS_ECC
+	{ "ecdsa-sha2-nistp256-cert-v01@openssh.com", "ECDSA-CERT",
+	    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1 },
+	{ "ecdsa-sha2-nistp384-cert-v01@openssh.com", "ECDSA-CERT",
+	    KEY_ECDSA_CERT, NID_secp384r1, 1 },
+#  ifdef OPENSSL_HAS_NISTP521
+	{ "ecdsa-sha2-nistp521-cert-v01@openssh.com", "ECDSA-CERT",
+	    KEY_ECDSA_CERT, NID_secp521r1, 1 },
+#  endif /* OPENSSL_HAS_NISTP521 */
+# endif /* OPENSSL_HAS_ECC */
+#endif /* WITH_OPENSSL */
+	{ NULL, NULL, -1, -1, 0 }
+};
+
+static const struct keytype *
+fips_select_keytypes(void)
+{
+	if (fips_mode()) {
+		return keytypes_fips140_2;
+	}
+
+	return keytypes;
+}
+
 const char *
 sshkey_type(const struct sshkey *k)
 {
 	const struct keytype *kt;
 
-	for (kt = keytypes; kt->type != -1; kt++) {
+	for (kt = fips_select_keytypes(); kt->type != -1; kt++) {
 		if (kt->type == k->type)
 			return kt->shortname;
 	}
@@ -132,7 +170,7 @@ sshkey_ssh_name_from_type_nid(int type, int nid)
 {
 	const struct keytype *kt;
 
-	for (kt = keytypes; kt->type != -1; kt++) {
+	for (kt = fips_select_keytypes(); kt->type != -1; kt++) {
 		if (kt->type == type && (kt->nid == 0 || kt->nid == nid))
 			return kt->name;
 	}
@@ -144,7 +182,7 @@ sshkey_type_is_cert(int type)
 {
 	const struct keytype *kt;
 
-	for (kt = keytypes; kt->type != -1; kt++) {
+	for (kt = fips_select_keytypes(); kt->type != -1; kt++) {
 		if (kt->type == type)
 			return kt->cert;
 	}
@@ -169,7 +207,7 @@ sshkey_type_from_name(const char *name)
 {
 	const struct keytype *kt;
 
-	for (kt = keytypes; kt->type != -1; kt++) {
+	for (kt = fips_select_keytypes(); kt->type != -1; kt++) {
 		/* Only allow shortname matches for plain key types */
 		if ((kt->name != NULL && strcmp(name, kt->name) == 0) ||
 		    (!kt->cert && strcasecmp(kt->shortname, name) == 0))
@@ -183,7 +221,7 @@ sshkey_ecdsa_nid_from_name(const char *name)
 {
 	const struct keytype *kt;
 
-	for (kt = keytypes; kt->type != -1; kt++) {
+	for (kt = fips_select_keytypes(); kt->type != -1; kt++) {
 		if (kt->type != KEY_ECDSA && kt->type != KEY_ECDSA_CERT)
 			continue;
 		if (kt->name != NULL && strcmp(name, kt->name) == 0)
@@ -199,7 +237,7 @@ key_alg_list(int certs_only, int plain_only)
 	size_t nlen, rlen = 0;
 	const struct keytype *kt;
 
-	for (kt = keytypes; kt->type != -1; kt++) {
+	for (kt = fips_select_keytypes(); kt->type != -1; kt++) {
 		if (kt->name == NULL)
 			continue;
 		if ((certs_only && !kt->cert) || (plain_only && kt->cert))
@@ -243,7 +281,7 @@ sshkey_names_valid2(const char *names, int allow_wildcard)
 				 * If any has a positive or negative match then
 				 * the component is accepted.
 				 */
-				for (kt = keytypes; kt->type != -1; kt++) {
+				for (kt = fips_select_keytypes(); kt->type != -1; kt++) {
 					if (kt->type == KEY_RSA1)
 						continue;
 					if (match_pattern_list(kt->name,
@@ -1663,6 +1701,10 @@ sshkey_generate(int type, u_int bits, struct sshkey **keyp)
 		return SSH_ERR_ALLOC_FAIL;
 	switch (type) {
 	case KEY_ED25519:
+		if (fips_mode()) {
+			/* ED25519 disabled in FIPS mode */
+			break;
+		}
 		if ((k->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL ||
 		    (k->ed25519_sk = malloc(ED25519_SK_SZ)) == NULL) {
 			ret = SSH_ERR_ALLOC_FAIL;
@@ -3538,7 +3580,7 @@ sshkey_private_to_fileblob(struct sshkey *key, struct sshbuf *blob,
 	case KEY_DSA:
 	case KEY_ECDSA:
 	case KEY_RSA:
-		if (force_new_format) {
+		if (force_new_format && !fips_mode()) {
 			return sshkey_private_to_blob2(key, blob, passphrase,
 			    comment, new_format_cipher, new_format_rounds);
 		}
@@ -3546,6 +3588,10 @@ sshkey_private_to_fileblob(struct sshkey *key, struct sshbuf *blob,
 		    passphrase, comment);
 #endif /* WITH_OPENSSL */
 	case KEY_ED25519:
+		if (fips_mode()) {
+			/* ED25519 not supported in FIPS mode */
+			return SSH_ERR_KEY_TYPE_UNKNOWN;
+		}
 		return sshkey_private_to_blob2(key, blob, passphrase,
 		    comment, new_format_cipher, new_format_rounds);
 	default:
@@ -3854,10 +3900,14 @@ sshkey_parse_private_fileblob_type(struct sshbuf *blob, int type,
 		    passphrase, keyp);
 #endif /* WITH_OPENSSL */
 	case KEY_ED25519:
+		if (fips_mode()) {
+			/* ED25519 keys unavailable in FIPS mode */
+			return SSH_ERR_INVALID_FORMAT;
+		}
 		return sshkey_parse_private2(blob, type, passphrase,
 		    keyp, commentp);
 	case KEY_UNSPEC:
-		if ((r = sshkey_parse_private2(blob, type, passphrase, keyp,
+		if (!fips_mode() && (r = sshkey_parse_private2(blob, type, passphrase, keyp,
 		    commentp)) == 0)
 			return 0;
 #ifdef WITH_OPENSSL
diff --git a/readconf.c b/readconf.c
index 1d03bdf..2bde149 100644
--- a/readconf.c
+++ b/readconf.c
@@ -61,6 +61,7 @@
 #include "uidswap.h"
 #include "myproposal.h"
 #include "digest.h"
+#include "fips.h"
 
 /* Format of the configuration file:
 
@@ -1855,12 +1856,12 @@ fill_default_options(Options * options)
 		options->fingerprint_hash = SSH_FP_HASH_DEFAULT;
 	if (options->update_hostkeys == -1)
 		options->update_hostkeys = 0;
-	if (kex_assemble_names(KEX_CLIENT_ENCRYPT, &options->ciphers) != 0 ||
-	    kex_assemble_names(KEX_CLIENT_MAC, &options->macs) != 0 ||
-	    kex_assemble_names(KEX_CLIENT_KEX, &options->kex_algorithms) != 0 ||
-	    kex_assemble_names(KEX_DEFAULT_PK_ALG,
+	if (kex_assemble_names(fips_mode() ? KEX_FIPS_140_2_CLIENT_ENCRYPT : KEX_CLIENT_ENCRYPT, &options->ciphers) != 0 ||
+	    kex_assemble_names(fips_mode() ? KEX_FIPS_140_2_CLIENT_MAC : KEX_CLIENT_MAC, &options->macs) != 0 ||
+	    kex_assemble_names(fips_mode() ? KEX_FIPS_140_2_CLIENT_KEX : KEX_CLIENT_KEX, &options->kex_algorithms) != 0 ||
+	    kex_assemble_names(fips_mode() ? KEX_FIPS_140_2_PK_ALG : KEX_DEFAULT_PK_ALG,
 	    &options->hostbased_key_types) != 0 ||
-	    kex_assemble_names(KEX_DEFAULT_PK_ALG,
+	    kex_assemble_names(fips_mode() ? KEX_FIPS_140_2_PK_ALG : KEX_DEFAULT_PK_ALG,
 	    &options->pubkey_key_types) != 0)
 		fatal("%s: kex_assemble_names failed", __func__);
 
diff --git a/servconf.c b/servconf.c
index 6c7a91e..ca9fe70 100644
--- a/servconf.c
+++ b/servconf.c
@@ -57,6 +57,7 @@
 #include "auth.h"
 #include "myproposal.h"
 #include "digest.h"
+#include "fips.h"
 
 static void add_listen_addr(ServerOptions *, char *, int);
 static void add_one_listen_addr(ServerOptions *, char *, int);
@@ -260,7 +261,7 @@ fill_default_server_options(ServerOptions *options)
 	if (options->hostbased_uses_name_from_packet_only == -1)
 		options->hostbased_uses_name_from_packet_only = 0;
 	if (options->hostkeyalgorithms == NULL)
-		options->hostkeyalgorithms = xstrdup(KEX_DEFAULT_PK_ALG);
+		options->hostkeyalgorithms = xstrdup(fips_mode() ? KEX_FIPS_140_2_PK_ALG : KEX_DEFAULT_PK_ALG);
 	if (options->rsa_authentication == -1)
 		options->rsa_authentication = 1;
 	if (options->pubkey_authentication == -1)
@@ -342,12 +343,12 @@ fill_default_server_options(ServerOptions *options)
 	if (options->debian_banner == -1)
 		options->debian_banner = 1;
 
-	if (kex_assemble_names(KEX_SERVER_ENCRYPT, &options->ciphers) != 0 ||
-	    kex_assemble_names(KEX_SERVER_MAC, &options->macs) != 0 ||
-	    kex_assemble_names(KEX_SERVER_KEX, &options->kex_algorithms) != 0 ||
-	    kex_assemble_names(KEX_DEFAULT_PK_ALG,
+	if (kex_assemble_names(fips_mode() ? KEX_FIPS_140_2_SERVER_ENCRYPT : KEX_SERVER_ENCRYPT, &options->ciphers) != 0 ||
+	    kex_assemble_names(fips_mode() ? KEX_FIPS_140_2_SERVER_MAC : KEX_SERVER_MAC, &options->macs) != 0 ||
+	    kex_assemble_names(fips_mode() ? KEX_FIPS_140_2_SERVER_KEX : KEX_SERVER_KEX, &options->kex_algorithms) != 0 ||
+	    kex_assemble_names(fips_mode() ? KEX_FIPS_140_2_PK_ALG : KEX_DEFAULT_PK_ALG,
 	    &options->hostbased_key_types) != 0 ||
-	    kex_assemble_names(KEX_DEFAULT_PK_ALG,
+	    kex_assemble_names(fips_mode() ? KEX_FIPS_140_2_PK_ALG : KEX_DEFAULT_PK_ALG,
 	    &options->pubkey_key_types) != 0)
 		fatal("%s: kex_assemble_names failed", __func__);
 
@@ -1839,6 +1840,9 @@ process_server_config_line(ServerOptions *options, char *line,
 		if ((value = ssh_digest_alg_by_name(arg)) == -1)
 			fatal("%.200s line %d: Invalid hash algorithm \"%s\".",
 			    filename, linenum, arg);
+		if (fips_mode() && value == SSH_DIGEST_MD5)
+			fatal("%.200s line %d: Hash algorithm not permitted \"%s\".",
+			    filename, linenum, arg);
 		if (*activep)
 			options->fingerprint_hash = value;
 		break;
