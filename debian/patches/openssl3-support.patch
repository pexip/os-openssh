diff --git a/cipher.c b/cipher.c
index 5b3a86d..8fb6d3c 100644
--- a/cipher.c
+++ b/cipher.c
@@ -501,39 +501,3 @@ cipher_get_keyiv(struct sshcipher_ctx *cc, u_char *iv, size_t len)
 #endif
 	return 0;
 }
-
-int
-cipher_set_keyiv(struct sshcipher_ctx *cc, const u_char *iv, size_t len)
-{
-#ifdef WITH_OPENSSL
-	const struct sshcipher *c = cc->cipher;
-	int evplen = 0;
-#endif
-
-	if ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)
-		return 0;
-	if ((cc->cipher->flags & CFLAG_NONE) != 0)
-		return 0;
-
-#ifdef WITH_OPENSSL
-	evplen = EVP_CIPHER_CTX_iv_length(cc->evp);
-	if (evplen <= 0)
-		return SSH_ERR_LIBCRYPTO_ERROR;
-	if ((size_t)evplen != len)
-		return SSH_ERR_INVALID_ARGUMENT;
-#ifndef OPENSSL_HAVE_EVPCTR
-	/* XXX iv arg is const, but ssh_aes_ctr_iv isn't */
-	if (c->evptype == evp_aes_128_ctr)
-		ssh_aes_ctr_iv(cc->evp, 1, (u_char *)iv, evplen);
-	else
-#endif
-	if (cipher_authlen(c)) {
-		/* XXX iv arg is const, but EVP_CIPHER_CTX_ctrl isn't */
-		if (!EVP_CIPHER_CTX_ctrl(cc->evp,
-		    EVP_CTRL_GCM_SET_IV_FIXED, -1, (void *)iv))
-			return SSH_ERR_LIBCRYPTO_ERROR;
-	} else if (!EVP_CIPHER_CTX_set_iv(cc->evp, iv, evplen))
-		return SSH_ERR_LIBCRYPTO_ERROR;
-#endif
-	return 0;
-}
diff --git a/cipher.h b/cipher.h
index 1a591cd..8bc7084 100644
--- a/cipher.h
+++ b/cipher.h
@@ -72,7 +72,6 @@ u_int	 cipher_is_cbc(const struct sshcipher *);
 u_int	 cipher_ctx_is_plaintext(struct sshcipher_ctx *);
 
 int	 cipher_get_keyiv(struct sshcipher_ctx *, u_char *, size_t);
-int	 cipher_set_keyiv(struct sshcipher_ctx *, const u_char *, size_t);
 int	 cipher_get_keyiv_len(const struct sshcipher_ctx *);
 
 #endif				/* CIPHER_H */
diff --git a/configure.ac b/configure.ac
index 17a3061..cfa506a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2902,7 +2902,7 @@ if test "x$openssl" = "xyes" ; then
 	AC_MSG_CHECKING([if programs using OpenSSL functions will link])
 	AC_LINK_IFELSE(
 		[AC_LANG_PROGRAM([[ #include <openssl/err.h> ]],
-		[[ ERR_load_crypto_strings(); ]])],
+		[[ ERR_clear_error(); ]])],
 		[
 			AC_MSG_RESULT([yes])
 		],
@@ -2913,7 +2913,7 @@ if test "x$openssl" = "xyes" ; then
 			AC_MSG_CHECKING([if programs using OpenSSL need -ldl])
 			AC_LINK_IFELSE(
 				[AC_LANG_PROGRAM([[ #include <openssl/err.h> ]],
-				[[ ERR_load_crypto_strings(); ]])],
+				[[ ERR_clear_error(); ]])],
 				[
 					AC_MSG_RESULT([yes])
 				],
@@ -3121,7 +3121,7 @@ if test "x$openssl" = "xyes" ; then
 	#include <openssl/objects.h>
 	#include <openssl/opensslv.h>
 		]], [[
-		EC_KEY *e = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
+		EC_GROUP *e = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1);
 		const EVP_MD *m = EVP_sha256(); /* We need this too */
 		]])],
 		[ AC_MSG_RESULT([yes])
@@ -3139,7 +3139,7 @@ if test "x$openssl" = "xyes" ; then
 	#include <openssl/objects.h>
 	#include <openssl/opensslv.h>
 		]], [[
-		EC_KEY *e = EC_KEY_new_by_curve_name(NID_secp384r1);
+		EC_GROUP *e = EC_GROUP_new_by_curve_name(NID_secp384r1);
 		const EVP_MD *m = EVP_sha384(); /* We need this too */
 		]])],
 		[ AC_MSG_RESULT([yes])
@@ -3157,7 +3157,7 @@ if test "x$openssl" = "xyes" ; then
 	#include <openssl/objects.h>
 	#include <openssl/opensslv.h>
 		]], [[
-		EC_KEY *e = EC_KEY_new_by_curve_name(NID_secp521r1);
+		EC_GROUP *e = EC_GROUP_new_by_curve_name(NID_secp521r1);
 		const EVP_MD *m = EVP_sha512(); /* We need this too */
 		]])],
 		[ AC_MSG_RESULT([yes])
@@ -3172,7 +3172,7 @@ if test "x$openssl" = "xyes" ; then
 	#include <openssl/objects.h>
 	#include <openssl/opensslv.h>
 			]],[[
-			EC_KEY *e = EC_KEY_new_by_curve_name(NID_secp521r1);
+			EC_GROUP *e = EC_GROUP_new_by_curve_name(NID_secp521r1);
 			const EVP_MD *m = EVP_sha512(); /* We need this too */
 			exit(e == NULL || m == NULL);
 			]])],
diff --git a/dh.c b/dh.c
index ce2eb47..447d1a8 100644
--- a/dh.c
+++ b/dh.c
@@ -35,7 +35,7 @@
 #include <limits.h>
 
 #include <openssl/bn.h>
-#include <openssl/dh.h>
+#include <openssl/evp.h>
 
 #include "dh.h"
 #include "pathnames.h"
@@ -155,7 +155,7 @@ parse_prime(int linenum, char *line, struct dhgroup *dhg)
 	return 0;
 }
 
-DH *
+EVP_PKEY *
 choose_dh(int min, int wantbits, int max)
 {
 	FILE *f;
@@ -233,32 +233,39 @@ choose_dh(int min, int wantbits, int max)
 /* diffie-hellman-groupN-sha1 */
 
 int
-dh_pub_is_valid(const DH *dh, const BIGNUM *dh_pub)
+dh_pub_is_valid(const EVP_PKEY *dh, const BIGNUM *dh_pub)
 {
 	int i;
 	int n = BN_num_bits(dh_pub);
 	int bits_set = 0;
+	BIGNUM *dh_p = NULL;
 	BIGNUM *tmp;
-	const BIGNUM *dh_p;
 
-	DH_get0_pqg(dh, &dh_p, NULL, NULL);
+	if (EVP_PKEY_get_bn_param(dh, OSSL_PKEY_PARAM_FFC_P, &dh_p) == 0) {
+		logit("failed retrieving modulus");
+		return 0;
+	}
 
 	if (BN_is_negative(dh_pub)) {
+		BN_clear_free(dh_p);
 		logit("invalid public DH value: negative");
 		return 0;
 	}
 	if (BN_cmp(dh_pub, BN_value_one()) != 1) {	/* pub_exp <= 1 */
+		BN_clear_free(dh_p);
 		logit("invalid public DH value: <= 1");
 		return 0;
 	}
 
 	if ((tmp = BN_new()) == NULL) {
+		BN_clear_free(dh_p);
 		error_f("BN_new failed");
 		return 0;
 	}
 	if (!BN_sub(tmp, dh_p, BN_value_one()) ||
 	    BN_cmp(dh_pub, tmp) != -1) {		/* pub_exp > p-2 */
 		BN_clear_free(tmp);
+		BN_clear_free(dh_p);
 		logit("invalid public DH value: >= p-1");
 		return 0;
 	}
@@ -275,56 +282,69 @@ dh_pub_is_valid(const DH *dh, const BIGNUM *dh_pub)
 	if (bits_set < 4) {
 		logit("invalid public DH value (%d/%d)",
 		    bits_set, BN_num_bits(dh_p));
+		BN_clear_free(dh_p);
 		return 0;
 	}
+	BN_clear_free(dh_p);
 	return 1;
 }
 
 int
-dh_gen_key(DH *dh, int need)
+dh_gen_key(EVP_PKEY *dh, int need)
 {
+	EVP_PKEY_CTX *pctx = NULL;
 	int pbits;
-	const BIGNUM *dh_p, *pub_key;
+	BIGNUM *dh_p = NULL, *pub_key = NULL;
+	int ret = 0;
 
-	DH_get0_pqg(dh, &dh_p, NULL, NULL);
+	if (EVP_PKEY_get_bn_param(dh, OSSL_PKEY_PARAM_FFC_P, &dh_p) == 0) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
 
 	if (need < 0 || dh_p == NULL ||
 	    (pbits = BN_num_bits(dh_p)) <= 0 ||
-	    need > INT_MAX / 2 || 2 * need > pbits)
-		return SSH_ERR_INVALID_ARGUMENT;
+	    need > INT_MAX / 2 || 2 * need > pbits) {
+		ret = SSH_ERR_INVALID_ARGUMENT;
+		goto out;
+	}
 	if (need < 256)
 		need = 256;
-	/*
-	 * Pollard Rho, Big step/Little Step attacks are O(sqrt(n)),
-	 * so double requested need here.
-	 */
-	if (!DH_set_length(dh, MINIMUM(need * 2, pbits - 1)))
-		return SSH_ERR_LIBCRYPTO_ERROR;
-
-	if (DH_generate_key(dh) == 0)
-		return SSH_ERR_LIBCRYPTO_ERROR;
-	DH_get0_key(dh, &pub_key, NULL);
-	if (!dh_pub_is_valid(dh, pub_key))
-		return SSH_ERR_INVALID_FORMAT;
-	return 0;
+
+	if ((pctx = EVP_PKEY_CTX_new(dh, NULL)) == NULL) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if (EVP_PKEY_keygen_init(pctx) <= 0 ||
+	    EVP_PKEY_generate(pctx, &dh) <= 0) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if (EVP_PKEY_get_bn_param(dh,
+	    OSSL_PKEY_PARAM_PUB_KEY, &pub_key) == 0) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if (!dh_pub_is_valid(dh, pub_key)) {
+		ret = SSH_ERR_INVALID_FORMAT;
+		goto out;
+	}
+out:
+	BN_clear_free(dh_p);
+	BN_clear_free(pub_key);
+	return ret;
 }
 
-DH *
+EVP_PKEY *
 dh_new_group_asc(const char *gen, const char *modulus)
 {
-	DH *dh;
 	BIGNUM *dh_p = NULL, *dh_g = NULL;
 
-	if ((dh = DH_new()) == NULL)
-		return NULL;
 	if (BN_hex2bn(&dh_p, modulus) == 0 ||
 	    BN_hex2bn(&dh_g, gen) == 0)
 		goto fail;
-	if (!DH_set0_pqg(dh, dh_p, NULL, dh_g))
-		goto fail;
-	return dh;
+	return dh_new_group(dh_g, dh_p);
  fail:
-	DH_free(dh);
 	BN_clear_free(dh_p);
 	BN_clear_free(dh_g);
 	return NULL;
@@ -334,23 +354,37 @@ dh_new_group_asc(const char *gen, const char *modulus)
  * This just returns the group, we still need to generate the exchange
  * value.
  */
-DH *
+EVP_PKEY *
 dh_new_group(BIGNUM *gen, BIGNUM *modulus)
 {
-	DH *dh;
-
-	if ((dh = DH_new()) == NULL)
-		return NULL;
-	if (!DH_set0_pqg(dh, modulus, NULL, gen)) {
-		DH_free(dh);
-		return NULL;
-	}
-
+	OSSL_PARAM_BLD *bld = NULL;
+	OSSL_PARAM *params = NULL;
+	EVP_PKEY_CTX *pctx = NULL;
+	EVP_PKEY *dh = NULL;
+
+	if ((bld = OSSL_PARAM_BLD_new()) == NULL)
+		goto out;
+	if (OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_FFC_P, modulus) == 0 ||
+	    OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_FFC_G, gen) == 0)
+		goto out;
+	if ((params = OSSL_PARAM_BLD_to_param(bld)) == NULL)
+		goto out;
+	if ((pctx = EVP_PKEY_CTX_new_from_name(NULL, "DH", NULL)) == NULL)
+		goto out;
+	if (EVP_PKEY_fromdata_init(pctx) <= 0 ||
+	    EVP_PKEY_fromdata(pctx, &dh, EVP_PKEY_KEY_PARAMETERS, params) <= 0)
+		goto out;
+ out:
+	EVP_PKEY_CTX_free(pctx);
+	OSSL_PARAM_free(params);
+	OSSL_PARAM_BLD_free(bld);
+	BN_clear_free(modulus);
+	BN_clear_free(gen);
 	return dh;
 }
 
 /* rfc2409 "Second Oakley Group" (1024 bits) */
-DH *
+EVP_PKEY *
 dh_new_group1(void)
 {
 	static char *gen = "2", *group1 =
@@ -365,7 +399,7 @@ dh_new_group1(void)
 }
 
 /* rfc3526 group 14 "2048-bit MODP Group" */
-DH *
+EVP_PKEY *
 dh_new_group14(void)
 {
 	static char *gen = "2", *group14 =
@@ -385,7 +419,7 @@ dh_new_group14(void)
 }
 
 /* rfc3526 group 16 "4096-bit MODP Group" */
-DH *
+EVP_PKEY *
 dh_new_group16(void)
 {
 	static char *gen = "2", *group16 =
@@ -416,7 +450,7 @@ dh_new_group16(void)
 }
 
 /* rfc3526 group 18 "8192-bit MODP Group" */
-DH *
+EVP_PKEY *
 dh_new_group18(void)
 {
 	static char *gen = "2", *group18 =
@@ -468,7 +502,7 @@ dh_new_group18(void)
 }
 
 /* Select fallback group used by DH-GEX if moduli file cannot be read. */
-DH *
+EVP_PKEY *
 dh_new_group_fallback(int max)
 {
 	debug3_f("requested max size %d", max);
diff --git a/dh.h b/dh.h
index c6326a3..1dc0229 100644
--- a/dh.h
+++ b/dh.h
@@ -34,17 +34,17 @@ struct dhgroup {
 	BIGNUM *p;
 };
 
-DH	*choose_dh(int, int, int);
-DH	*dh_new_group_asc(const char *, const char *);
-DH	*dh_new_group(BIGNUM *, BIGNUM *);
-DH	*dh_new_group1(void);
-DH	*dh_new_group14(void);
-DH	*dh_new_group16(void);
-DH	*dh_new_group18(void);
-DH	*dh_new_group_fallback(int);
+EVP_PKEY *choose_dh(int, int, int);
+EVP_PKEY *dh_new_group_asc(const char *, const char *);
+EVP_PKEY *dh_new_group(BIGNUM *, BIGNUM *);
+EVP_PKEY *dh_new_group1(void);
+EVP_PKEY *dh_new_group14(void);
+EVP_PKEY *dh_new_group16(void);
+EVP_PKEY *dh_new_group18(void);
+EVP_PKEY *dh_new_group_fallback(int);
 
-int	 dh_gen_key(DH *, int);
-int	 dh_pub_is_valid(const DH *, const BIGNUM *);
+int	 dh_gen_key(EVP_PKEY *, int);
+int	 dh_pub_is_valid(const EVP_PKEY *, const BIGNUM *);
 
 u_int	 dh_estimate(int);
 void	 dh_set_moduli_file(const char *);
diff --git a/kex.c b/kex.c
index f06ad36..761e72d 100644
--- a/kex.c
+++ b/kex.c
@@ -39,7 +39,7 @@
 
 #ifdef WITH_OPENSSL
 #include <openssl/crypto.h>
-#include <openssl/dh.h>
+#include <openssl/evp.h>
 #endif
 
 #include "ssh.h"
@@ -702,9 +702,10 @@ kex_free(struct kex *kex)
 		return;
 
 #ifdef WITH_OPENSSL
-	DH_free(kex->dh);
+	EVP_PKEY_free(kex->dh);
 #ifdef OPENSSL_HAS_ECC
-	EC_KEY_free(kex->ec_client_key);
+	EVP_PKEY_free(kex->ec_client_key);
+	EC_GROUP_free(kex->ec_group);
 #endif /* OPENSSL_HAS_ECC */
 #endif /* WITH_OPENSSL */
 	for (mode = 0; mode < MODE_MAX; mode++) {
diff --git a/kex.h b/kex.h
index b7846ad..6d0c909 100644
--- a/kex.h
+++ b/kex.h
@@ -31,7 +31,7 @@
 
 #ifdef WITH_OPENSSL
 # include <openssl/bn.h>
-# include <openssl/dh.h>
+# include <openssl/evp.h>
 # include <openssl/ecdsa.h>
 # ifdef OPENSSL_HAS_ECC
 #  include <openssl/ec.h>
@@ -41,7 +41,7 @@
 #  define EC_POINT	void
 # endif /* OPENSSL_HAS_ECC */
 #else /* WITH_OPENSSL */
-# define DH		void
+# define EVP_PKEY	void
 # define BIGNUM		void
 # define EC_KEY		void
 # define EC_GROUP	void
@@ -168,10 +168,10 @@ struct kex {
 	    u_char **, size_t *, const u_char *, size_t, const char *);
 	int	(*kex[KEX_MAX])(struct ssh *);
 	/* kex specific state */
-	DH	*dh;			/* DH */
+	EVP_PKEY *dh;			/* DH */
 	u_int	min, max, nbits;	/* GEX */
-	EC_KEY	*ec_client_key;		/* ECDH */
-	const EC_GROUP *ec_group;	/* ECDH */
+	EVP_PKEY *ec_client_key;	/* ECDH */
+	EC_GROUP *ec_group;		/* ECDH */
 	u_char c25519_client_key[CURVE25519_SIZE]; /* 25519 + KEM */
 	u_char c25519_client_pubkey[CURVE25519_SIZE]; /* 25519 */
 	u_char sntrup761_client_key[crypto_kem_sntrup761_SECRETKEYBYTES]; /* KEM */
diff --git a/kexdh.c b/kexdh.c
index c1084f2..573d9ba 100644
--- a/kexdh.c
+++ b/kexdh.c
@@ -34,7 +34,6 @@
 #include <signal.h>
 
 #include "openbsd-compat/openssl-compat.h"
-#include <openssl/dh.h>
 
 #include "sshkey.h"
 #include "kex.h"
@@ -72,17 +71,21 @@ kex_dh_keygen(struct kex *kex)
 int
 kex_dh_compute_key(struct kex *kex, BIGNUM *dh_pub, struct sshbuf *out)
 {
-	BIGNUM *shared_secret = NULL;
+	OSSL_PARAM_BLD *bld = NULL;
+	OSSL_PARAM *params = NULL;
+	EVP_PKEY_CTX *pctx = NULL;
+	EVP_PKEY *peer_key = NULL;
+	BIGNUM *dh_p = NULL, *dh_g = NULL, *shared_secret = NULL;
 	u_char *kbuf = NULL;
 	size_t klen = 0;
-	int kout, r;
+	int r;
 
 #ifdef DEBUG_KEXDH
 	fprintf(stderr, "dh_pub= ");
 	BN_print_fp(stderr, dh_pub);
 	fprintf(stderr, "\n");
 	debug("bits %d", BN_num_bits(dh_pub));
-	DHparams_print_fp(stderr, kex->dh);
+	EVP_PKEY_print_params_fp(stderr, kex->dh, 0, NULL);
 	fprintf(stderr, "\n");
 #endif
 
@@ -90,44 +93,100 @@ kex_dh_compute_key(struct kex *kex, BIGNUM *dh_pub, struct sshbuf *out)
 		r = SSH_ERR_MESSAGE_INCOMPLETE;
 		goto out;
 	}
-	klen = DH_size(kex->dh);
+
+	if (EVP_PKEY_get_bn_param(kex->dh,
+	    OSSL_PKEY_PARAM_FFC_P, &dh_p) == 0 ||
+	    EVP_PKEY_get_bn_param(kex->dh,
+	    OSSL_PKEY_PARAM_FFC_G, &dh_g) == 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if ((bld = OSSL_PARAM_BLD_new()) == NULL) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if (OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_FFC_P, dh_p) == 0 ||
+	    OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_FFC_G, dh_g) == 0 ||
+	    OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_PUB_KEY, dh_pub) == 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if ((params = OSSL_PARAM_BLD_to_param(bld)) == NULL) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if ((pctx = EVP_PKEY_CTX_new_from_name(NULL, "DH", NULL)) == NULL) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if (EVP_PKEY_fromdata_init(pctx) <= 0 ||
+	    EVP_PKEY_fromdata(pctx, &peer_key,
+	    EVP_PKEY_PUBLIC_KEY, params) <= 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	EVP_PKEY_CTX_free(pctx);
+
+	if ((pctx = EVP_PKEY_CTX_new(kex->dh, NULL)) == NULL) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if (EVP_PKEY_derive_init(pctx) <= 0 ||
+	    EVP_PKEY_derive_set_peer(pctx, peer_key) <= 0 ||
+	    EVP_PKEY_derive(pctx, NULL, &klen) <= 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
 	if ((kbuf = malloc(klen)) == NULL ||
 	    (shared_secret = BN_new()) == NULL) {
 		r = SSH_ERR_ALLOC_FAIL;
 		goto out;
 	}
-	if ((kout = DH_compute_key(kbuf, dh_pub, kex->dh)) < 0 ||
-	    BN_bin2bn(kbuf, kout, shared_secret) == NULL) {
+	if (EVP_PKEY_derive(pctx, kbuf, &klen) <= 0 ||
+	    BN_bin2bn(kbuf, (int) klen, shared_secret) == NULL) {
 		r = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
 	}
+
 #ifdef DEBUG_KEXDH
-	dump_digest("shared secret", kbuf, kout);
+	dump_digest("shared secret", kbuf, klen);
 #endif
 	r = sshbuf_put_bignum2(out, shared_secret);
  out:
 	freezero(kbuf, klen);
 	BN_clear_free(shared_secret);
+	EVP_PKEY_CTX_free(pctx);
+	EVP_PKEY_free(peer_key);
+	OSSL_PARAM_free(params);
+	OSSL_PARAM_BLD_free(bld);
+	BN_clear_free(dh_p);
+	BN_clear_free(dh_g);
 	return r;
 }
 
 int
 kex_dh_keypair(struct kex *kex)
 {
-	const BIGNUM *pub_key;
+	BIGNUM *pub_key = NULL;
 	struct sshbuf *buf = NULL;
 	int r;
 
 	if ((r = kex_dh_keygen(kex)) != 0)
 		return r;
-	DH_get0_key(kex->dh, &pub_key, NULL);
-	if ((buf = sshbuf_new()) == NULL)
-		return SSH_ERR_ALLOC_FAIL;
+	if (EVP_PKEY_get_bn_param(kex->dh,
+	    OSSL_PKEY_PARAM_PUB_KEY, &pub_key) == 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if ((buf = sshbuf_new()) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
 	if ((r = sshbuf_put_bignum2(buf, pub_key)) != 0 ||
 	    (r = sshbuf_get_u32(buf, NULL)) != 0)
 		goto out;
 #ifdef DEBUG_KEXDH
-	DHparams_print_fp(stderr, kex->dh);
+	EVP_PKEY_print_params_fp(stderr, kex->dh, 0, NULL);
 	fprintf(stderr, "pub= ");
 	BN_print_fp(stderr, pub_key);
 	fprintf(stderr, "\n");
@@ -136,6 +195,7 @@ kex_dh_keypair(struct kex *kex)
 	buf = NULL;
  out:
 	sshbuf_free(buf);
+	BN_clear_free(pub_key);
 	return r;
 }
 
@@ -143,7 +203,7 @@ int
 kex_dh_enc(struct kex *kex, const struct sshbuf *client_blob,
     struct sshbuf **server_blobp, struct sshbuf **shared_secretp)
 {
-	const BIGNUM *pub_key;
+	BIGNUM *pub_key = NULL;
 	struct sshbuf *server_blob = NULL;
 	int r;
 
@@ -152,7 +212,11 @@ kex_dh_enc(struct kex *kex, const struct sshbuf *client_blob,
 
 	if ((r = kex_dh_keygen(kex)) != 0)
 		goto out;
-	DH_get0_key(kex->dh, &pub_key, NULL);
+	if (EVP_PKEY_get_bn_param(kex->dh,
+	    OSSL_PKEY_PARAM_PUB_KEY, &pub_key) == 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
 	if ((server_blob = sshbuf_new()) == NULL) {
 		r = SSH_ERR_ALLOC_FAIL;
 		goto out;
@@ -165,7 +229,8 @@ kex_dh_enc(struct kex *kex, const struct sshbuf *client_blob,
 	*server_blobp = server_blob;
 	server_blob = NULL;
  out:
-	DH_free(kex->dh);
+	BN_clear_free(pub_key);
+	EVP_PKEY_free(kex->dh);
 	kex->dh = NULL;
 	sshbuf_free(server_blob);
 	return r;
@@ -195,7 +260,7 @@ kex_dh_dec(struct kex *kex, const struct sshbuf *dh_blob,
 	buf = NULL;
  out:
 	BN_free(dh_pub);
-	DH_free(kex->dh);
+	EVP_PKEY_free(kex->dh);
 	kex->dh = NULL;
 	sshbuf_free(buf);
 	return r;
diff --git a/kexecdh.c b/kexecdh.c
index efb2e55..76629e6 100644
--- a/kexecdh.c
+++ b/kexecdh.c
@@ -34,7 +34,8 @@
 #include <string.h>
 #include <signal.h>
 
-#include <openssl/ecdh.h>
+#include <openssl/evp.h>
+#include "openbsd-compat/openssl-compat.h"
 
 #include "sshkey.h"
 #include "kex.h"
@@ -43,28 +44,53 @@
 #include "ssherr.h"
 
 static int
-kex_ecdh_dec_key_group(struct kex *, const struct sshbuf *, EC_KEY *key,
+kex_ecdh_dec_key_group(struct kex *, const struct sshbuf *, EVP_PKEY *key,
     const EC_GROUP *, struct sshbuf **);
 
 int
 kex_ecdh_keypair(struct kex *kex)
 {
-	EC_KEY *client_key = NULL;
-	const EC_GROUP *group;
-	const EC_POINT *public_key;
+	EVP_PKEY *client_key = NULL;
+	EC_GROUP *group = NULL;
+	EC_POINT *public_key = NULL;
 	struct sshbuf *buf = NULL;
+	char *pubkey = NULL;
+	size_t publen = 0;
 	int r;
 
-	if ((client_key = EC_KEY_new_by_curve_name(kex->ec_nid)) == NULL) {
+	if ((client_key = EVP_EC_gen(
+	    OSSL_EC_curve_nid2name(kex->ec_nid))) == NULL) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+
+	if ((group = EC_GROUP_new_by_curve_name(kex->ec_nid)) == NULL) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+
+	if (EVP_PKEY_get_octet_string_param(client_key,
+	    OSSL_PKEY_PARAM_PUB_KEY, NULL, 0, &publen) == 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if ((pubkey = malloc(publen)) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	if (EVP_PKEY_get_octet_string_param(client_key,
+	    OSSL_PKEY_PARAM_PUB_KEY, pubkey, publen, NULL) == 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if ((public_key = EC_POINT_new(group)) == NULL) {
 		r = SSH_ERR_ALLOC_FAIL;
 		goto out;
 	}
-	if (EC_KEY_generate_key(client_key) != 1) {
+	if (EC_POINT_oct2point(group, public_key, pubkey, publen, NULL) == 0) {
 		r = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
 	}
-	group = EC_KEY_get0_group(client_key);
-	public_key = EC_KEY_get0_public_key(client_key);
 
 	if ((buf = sshbuf_new()) == NULL) {
 		r = SSH_ERR_ALLOC_FAIL;
@@ -79,11 +105,15 @@ kex_ecdh_keypair(struct kex *kex)
 #endif
 	kex->ec_client_key = client_key;
 	kex->ec_group = group;
+	group = NULL;		/* owned by the kex */
 	client_key = NULL;	/* owned by the kex */
 	kex->client_pub = buf;
 	buf = NULL;
  out:
-	EC_KEY_free(client_key);
+	EC_GROUP_free(group);
+	EC_POINT_clear_free(public_key);
+	freezero(pubkey, publen);
+	EVP_PKEY_free(client_key);
 	sshbuf_free(buf);
 	return r;
 }
@@ -92,35 +122,60 @@ int
 kex_ecdh_enc(struct kex *kex, const struct sshbuf *client_blob,
     struct sshbuf **server_blobp, struct sshbuf **shared_secretp)
 {
-	const EC_GROUP *group;
-	const EC_POINT *pub_key;
-	EC_KEY *server_key = NULL;
+	EC_GROUP *group = NULL;
+	EC_POINT *public_key = NULL;
+	EVP_PKEY *server_key = NULL;
 	struct sshbuf *server_blob = NULL;
+	char *pubkey = NULL;
+	size_t publen = 0;
 	int r;
 
 	*server_blobp = NULL;
 	*shared_secretp = NULL;
 
-	if ((server_key = EC_KEY_new_by_curve_name(kex->ec_nid)) == NULL) {
-		r = SSH_ERR_ALLOC_FAIL;
+	if ((server_key = EVP_EC_gen(
+	    OSSL_EC_curve_nid2name(kex->ec_nid))) == NULL) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
 	}
-	if (EC_KEY_generate_key(server_key) != 1) {
+
+	if ((group = EC_GROUP_new_by_curve_name(kex->ec_nid)) == NULL) {
 		r = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
 	}
-	group = EC_KEY_get0_group(server_key);
 
 #ifdef DEBUG_KEXECDH
 	fputs("server private key:\n", stderr);
 	sshkey_dump_ec_key(server_key);
 #endif
-	pub_key = EC_KEY_get0_public_key(server_key);
+	if (EVP_PKEY_get_octet_string_param(server_key,
+	    OSSL_PKEY_PARAM_PUB_KEY, NULL, 0, &publen) == 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if ((pubkey = malloc(publen)) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	if (EVP_PKEY_get_octet_string_param(server_key,
+	    OSSL_PKEY_PARAM_PUB_KEY, pubkey, publen, NULL) == 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if ((public_key = EC_POINT_new(group)) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	if (EC_POINT_oct2point(group, public_key, pubkey, publen, NULL) == 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+
 	if ((server_blob = sshbuf_new()) == NULL) {
 		r = SSH_ERR_ALLOC_FAIL;
 		goto out;
 	}
-	if ((r = sshbuf_put_ec(server_blob, pub_key, group)) != 0 ||
+	if ((r = sshbuf_put_ec(server_blob, public_key, group)) != 0 ||
 	    (r = sshbuf_get_u32(server_blob, NULL)) != 0)
 		goto out;
 	if ((r = kex_ecdh_dec_key_group(kex, client_blob, server_key, group,
@@ -129,20 +184,28 @@ kex_ecdh_enc(struct kex *kex, const struct sshbuf *client_blob,
 	*server_blobp = server_blob;
 	server_blob = NULL;
  out:
-	EC_KEY_free(server_key);
+	EC_GROUP_free(group);
+	EC_POINT_clear_free(public_key);
+	freezero(pubkey, publen);
+	EVP_PKEY_free(server_key);
 	sshbuf_free(server_blob);
 	return r;
 }
 
 static int
 kex_ecdh_dec_key_group(struct kex *kex, const struct sshbuf *ec_blob,
-    EC_KEY *key, const EC_GROUP *group, struct sshbuf **shared_secretp)
+    EVP_PKEY *key, const EC_GROUP *group, struct sshbuf **shared_secretp)
 {
+	OSSL_PARAM_BLD *bld = NULL;
+	OSSL_PARAM *params = NULL;
+	EVP_PKEY_CTX *pctx = NULL;
+	EVP_PKEY *pkey = NULL;
 	struct sshbuf *buf = NULL;
 	BIGNUM *shared_secret = NULL;
 	EC_POINT *dh_pub = NULL;
 	u_char *kbuf = NULL;
-	size_t klen = 0;
+	char *pubkey = NULL;
+	size_t klen = 0, publen = 0;
 	int r;
 
 	*shared_secretp = NULL;
@@ -170,13 +233,61 @@ kex_ecdh_dec_key_group(struct kex *kex, const struct sshbuf *ec_blob,
 		r = SSH_ERR_MESSAGE_INCOMPLETE;
 		goto out;
 	}
-	klen = (EC_GROUP_get_degree(group) + 7) / 8;
+
+	publen = EC_POINT_point2oct(group, dh_pub,
+	    POINT_CONVERSION_UNCOMPRESSED, NULL, 0, NULL);
+	if ((pubkey = malloc(publen)) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	if (EC_POINT_point2oct(group, dh_pub, POINT_CONVERSION_UNCOMPRESSED,
+	    pubkey, publen, NULL) == 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+
+	if ((bld = OSSL_PARAM_BLD_new()) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	if (OSSL_PARAM_BLD_push_utf8_string(bld, OSSL_PKEY_PARAM_GROUP_NAME,
+	    OBJ_nid2sn(EC_GROUP_get_curve_name(group)), 0) == 0 ||
+	    OSSL_PARAM_BLD_push_octet_string(bld, OSSL_PKEY_PARAM_PUB_KEY,
+	    pubkey, publen) == 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if ((params = OSSL_PARAM_BLD_to_param(bld)) == NULL) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if ((pctx = EVP_PKEY_CTX_new_from_name(NULL, "EC", NULL)) == NULL) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if (EVP_PKEY_fromdata_init(pctx) <= 0 ||
+	    EVP_PKEY_fromdata(pctx, &pkey, EVP_PKEY_PUBLIC_KEY, params) <= 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	EVP_PKEY_CTX_free(pctx);
+
+	if ((pctx = EVP_PKEY_CTX_new(key, NULL)) == NULL) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if (EVP_PKEY_derive_init(pctx) <= 0 ||
+	    EVP_PKEY_derive_set_peer(pctx, pkey) <= 0 ||
+	    EVP_PKEY_derive(pctx, NULL, &klen) <= 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
 	if ((kbuf = malloc(klen)) == NULL ||
 	    (shared_secret = BN_new()) == NULL) {
 		r = SSH_ERR_ALLOC_FAIL;
 		goto out;
 	}
-	if (ECDH_compute_key(kbuf, klen, dh_pub, key, NULL) != (int)klen ||
+	if (EVP_PKEY_derive(pctx, kbuf, &klen) <= 0 ||
 	    BN_bin2bn(kbuf, klen, shared_secret) == NULL) {
 		r = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
@@ -189,6 +300,11 @@ kex_ecdh_dec_key_group(struct kex *kex, const struct sshbuf *ec_blob,
 	*shared_secretp = buf;
 	buf = NULL;
  out:
+	EVP_PKEY_CTX_free(pctx);
+	EVP_PKEY_free(pkey);
+	OSSL_PARAM_free(params);
+	OSSL_PARAM_BLD_free(bld);
+	freezero(pubkey, publen);
 	EC_POINT_clear_free(dh_pub);
 	BN_clear_free(shared_secret);
 	freezero(kbuf, klen);
@@ -204,8 +320,10 @@ kex_ecdh_dec(struct kex *kex, const struct sshbuf *server_blob,
 
 	r = kex_ecdh_dec_key_group(kex, server_blob, kex->ec_client_key,
 	    kex->ec_group, shared_secretp);
-	EC_KEY_free(kex->ec_client_key);
+	EVP_PKEY_free(kex->ec_client_key);
+	EC_GROUP_free(kex->ec_group);
 	kex->ec_client_key = NULL;
+	kex->ec_group = NULL;
 	return r;
 }
 
diff --git a/kexgexc.c b/kexgexc.c
index e99e0cf..9d5e0b1 100644
--- a/kexgexc.c
+++ b/kexgexc.c
@@ -96,7 +96,7 @@ input_kex_dh_gex_group(int type, u_int32_t seq, struct ssh *ssh)
 {
 	struct kex *kex = ssh->kex;
 	BIGNUM *p = NULL, *g = NULL;
-	const BIGNUM *pub_key;
+	BIGNUM *pub_key = NULL;
 	int r, bits;
 
 	debug("SSH2_MSG_KEX_DH_GEX_GROUP received");
@@ -120,14 +120,18 @@ input_kex_dh_gex_group(int type, u_int32_t seq, struct ssh *ssh)
 	/* generate and send 'e', client DH public key */
 	if ((r = dh_gen_key(kex->dh, kex->we_need * 8)) != 0)
 		goto out;
-	DH_get0_key(kex->dh, &pub_key, NULL);
+	if (EVP_PKEY_get_bn_param(kex->dh,
+	    OSSL_PKEY_PARAM_PUB_KEY, &pub_key) == 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
 	if ((r = sshpkt_start(ssh, SSH2_MSG_KEX_DH_GEX_INIT)) != 0 ||
 	    (r = sshpkt_put_bignum2(ssh, pub_key)) != 0 ||
 	    (r = sshpkt_send(ssh)) != 0)
 		goto out;
 	debug("SSH2_MSG_KEX_DH_GEX_INIT sent");
 #ifdef DEBUG_KEXDH
-	DHparams_print_fp(stderr, kex->dh);
+	EV_PKEY_print_params_fp(stderr, kex->dh, 0, NULL);
 	fprintf(stderr, "pub= ");
 	BN_print_fp(stderr, pub_key);
 	fprintf(stderr, "\n");
@@ -136,6 +140,7 @@ input_kex_dh_gex_group(int type, u_int32_t seq, struct ssh *ssh)
 	ssh_dispatch_set(ssh, SSH2_MSG_KEX_DH_GEX_REPLY, &input_kex_dh_gex_reply);
 	r = 0;
 out:
+	BN_clear_free(pub_key);
 	BN_clear_free(p);
 	BN_clear_free(g);
 	return r;
@@ -146,7 +151,7 @@ input_kex_dh_gex_reply(int type, u_int32_t seq, struct ssh *ssh)
 {
 	struct kex *kex = ssh->kex;
 	BIGNUM *dh_server_pub = NULL;
-	const BIGNUM *pub_key, *dh_p, *dh_g;
+	BIGNUM *pub_key = NULL, *dh_p = NULL, *dh_g = NULL;
 	struct sshbuf *shared_secret = NULL;
 	struct sshbuf *tmp = NULL, *server_host_key_blob = NULL;
 	struct sshkey *server_host_key = NULL;
@@ -184,8 +189,15 @@ input_kex_dh_gex_reply(int type, u_int32_t seq, struct ssh *ssh)
 		kex->min = kex->max = -1;
 
 	/* calc and verify H */
-	DH_get0_key(kex->dh, &pub_key, NULL);
-	DH_get0_pqg(kex->dh, &dh_p, NULL, &dh_g);
+	if (EVP_PKEY_get_bn_param(kex->dh,
+	    OSSL_PKEY_PARAM_PUB_KEY, &pub_key) == 0 ||
+	    EVP_PKEY_get_bn_param(kex->dh,
+	    OSSL_PKEY_PARAM_FFC_P, &dh_p) == 0 ||
+	    EVP_PKEY_get_bn_param(kex->dh,
+	    OSSL_PKEY_PARAM_FFC_G, &dh_g) == 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
 	hashlen = sizeof(hash);
 	if ((r = kexgex_hash(
 	    kex->hash_alg,
@@ -228,7 +240,10 @@ input_kex_dh_gex_reply(int type, u_int32_t seq, struct ssh *ssh)
 	/* success */
  out:
 	explicit_bzero(hash, sizeof(hash));
-	DH_free(kex->dh);
+	BN_clear_free(pub_key);
+	BN_clear_free(dh_p);
+	BN_clear_free(dh_g);
+	EVP_PKEY_free(kex->dh);
 	kex->dh = NULL;
 	BN_clear_free(dh_server_pub);
 	sshbuf_free(shared_secret);
diff --git a/kexgexs.c b/kexgexs.c
index 72b444f..bb3c08a 100644
--- a/kexgexs.c
+++ b/kexgexs.c
@@ -74,7 +74,7 @@ input_kex_dh_gex_request(int type, u_int32_t seq, struct ssh *ssh)
 	struct kex *kex = ssh->kex;
 	int r;
 	u_int min = 0, max = 0, nbits = 0;
-	const BIGNUM *dh_p, *dh_g;
+	BIGNUM *dh_p = NULL, *dh_g = NULL;
 
 	debug("SSH2_MSG_KEX_DH_GEX_REQUEST received");
 	ssh_dispatch_set(ssh, SSH2_MSG_KEX_DH_GEX_REQUEST, &kex_protocol_error);
@@ -106,7 +106,13 @@ input_kex_dh_gex_request(int type, u_int32_t seq, struct ssh *ssh)
 		goto out;
 	}
 	debug("SSH2_MSG_KEX_DH_GEX_GROUP sent");
-	DH_get0_pqg(kex->dh, &dh_p, NULL, &dh_g);
+	if (EVP_PKEY_get_bn_param(kex->dh,
+	    OSSL_PKEY_PARAM_FFC_P, &dh_p) == 0 ||
+	    EVP_PKEY_get_bn_param(kex->dh,
+	    OSSL_PKEY_PARAM_FFC_G, &dh_g) == 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
 	if ((r = sshpkt_start(ssh, SSH2_MSG_KEX_DH_GEX_GROUP)) != 0 ||
 	    (r = sshpkt_put_bignum2(ssh, dh_p)) != 0 ||
 	    (r = sshpkt_put_bignum2(ssh, dh_g)) != 0 ||
@@ -121,6 +127,8 @@ input_kex_dh_gex_request(int type, u_int32_t seq, struct ssh *ssh)
 	ssh_dispatch_set(ssh, SSH2_MSG_KEX_DH_GEX_INIT, &input_kex_dh_gex_init);
 	r = 0;
  out:
+	BN_clear_free(dh_p);
+	BN_clear_free(dh_g);
 	return r;
 }
 
@@ -129,7 +137,7 @@ input_kex_dh_gex_init(int type, u_int32_t seq, struct ssh *ssh)
 {
 	struct kex *kex = ssh->kex;
 	BIGNUM *dh_client_pub = NULL;
-	const BIGNUM *pub_key, *dh_p, *dh_g;
+	BIGNUM *pub_key = NULL, *dh_p = NULL, *dh_g = NULL;
 	struct sshbuf *shared_secret = NULL;
 	struct sshbuf *server_host_key_blob = NULL;
 	struct sshkey *server_host_public, *server_host_private;
@@ -163,8 +171,15 @@ input_kex_dh_gex_init(int type, u_int32_t seq, struct ssh *ssh)
 		goto out;
 
 	/* calc H */
-	DH_get0_key(kex->dh, &pub_key, NULL);
-	DH_get0_pqg(kex->dh, &dh_p, NULL, &dh_g);
+	if (EVP_PKEY_get_bn_param(kex->dh,
+	    OSSL_PKEY_PARAM_PUB_KEY, &pub_key) == 0 ||
+	    EVP_PKEY_get_bn_param(kex->dh,
+	    OSSL_PKEY_PARAM_FFC_P, &dh_p) == 0 ||
+	    EVP_PKEY_get_bn_param(kex->dh,
+	    OSSL_PKEY_PARAM_FFC_G, &dh_g) == 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
 	hashlen = sizeof(hash);
 	if ((r = kexgex_hash(
 	    kex->hash_alg,
@@ -206,7 +221,10 @@ input_kex_dh_gex_init(int type, u_int32_t seq, struct ssh *ssh)
 	/* success */
  out:
 	explicit_bzero(hash, sizeof(hash));
-	DH_free(kex->dh);
+	BN_clear_free(pub_key);
+	BN_clear_free(dh_p);
+	BN_clear_free(dh_g);
+	EVP_PKEY_free(kex->dh);
 	kex->dh = NULL;
 	BN_clear_free(dh_client_pub);
 	sshbuf_free(shared_secret);
diff --git a/moduli.c b/moduli.c
index 8dd36b1..f097210 100644
--- a/moduli.c
+++ b/moduli.c
@@ -744,41 +744,23 @@ prime_test(FILE *in, FILE *out, u_int32_t trials, u_int32_t generator_wanted,
 		count_possible++;
 
 		/*
-		 * The (1/4)^N performance bound on Miller-Rabin is
-		 * extremely pessimistic, so don't spend a lot of time
-		 * really verifying that q is prime until after we know
-		 * that p is also prime. A single pass will weed out the
-		 * vast majority of composite q's.
-		 */
-		is_prime = BN_is_prime_ex(q, 1, NULL, NULL);
-		if (is_prime < 0)
-			fatal("BN_is_prime_ex failed");
-		if (is_prime == 0) {
-			debug("%10u: q failed first possible prime test",
-			    count_in);
-			continue;
-		}
-
-		/*
-		 * q is possibly prime, so go ahead and really make sure
-		 * that p is prime. If it is, then we can go back and do
-		 * the same for q. If p is composite, chances are that
+		 * Test if p is prime. If p is composite, chances are that
 		 * will show up on the first Rabin-Miller iteration so it
 		 * doesn't hurt to specify a high iteration count.
 		 */
-		is_prime = BN_is_prime_ex(p, trials, NULL, NULL);
+		is_prime = BN_check_prime(p, NULL, NULL);
 		if (is_prime < 0)
-			fatal("BN_is_prime_ex failed");
+			fatal("BN_check_prime failed");
 		if (is_prime == 0) {
 			debug("%10u: p is not prime", count_in);
 			continue;
 		}
 		debug("%10u: p is almost certainly prime", count_in);
 
-		/* recheck q more rigorously */
-		is_prime = BN_is_prime_ex(q, trials - 1, NULL, NULL);
+		/* Test if q is prime */
+		is_prime = BN_check_prime(q, NULL, NULL);
 		if (is_prime < 0)
-			fatal("BN_is_prime_ex failed");
+			fatal("BN_check_prime failed");
 		if (is_prime == 0) {
 			debug("%10u: q is not prime", count_in);
 			continue;
diff --git a/monitor.c b/monitor.c
index c9c06d8..51cc94d 100644
--- a/monitor.c
+++ b/monitor.c
@@ -567,8 +567,8 @@ monitor_reset_key_state(void)
 int
 mm_answer_moduli(struct ssh *ssh, int sock, struct sshbuf *m)
 {
-	DH *dh;
-	const BIGNUM *dh_p, *dh_g;
+	EVP_PKEY *dh;
+	BIGNUM *dh_p = NULL, *dh_g = NULL;
 	int r;
 	u_int min, want, max;
 
@@ -591,13 +591,19 @@ mm_answer_moduli(struct ssh *ssh, int sock, struct sshbuf *m)
 		return (0);
 	} else {
 		/* Send first bignum */
-		DH_get0_pqg(dh, &dh_p, NULL, &dh_g);
+		if (EVP_PKEY_get_bn_param(dh,
+		    OSSL_PKEY_PARAM_FFC_P, &dh_p) == 0 ||
+		    EVP_PKEY_get_bn_param(dh,
+		    OSSL_PKEY_PARAM_FFC_G, &dh_g) == 0)
+			fatal_f("failed extracting parameters");
 		if ((r = sshbuf_put_u8(m, 1)) != 0 ||
 		    (r = sshbuf_put_bignum2(m, dh_p)) != 0 ||
 		    (r = sshbuf_put_bignum2(m, dh_g)) != 0)
 			fatal_fr(r, "assemble");
 
-		DH_free(dh);
+		BN_clear_free(dh_g);
+		BN_clear_free(dh_p);
+		EVP_PKEY_free(dh);
 	}
 	mm_request_send(sock, MONITOR_ANS_MODULI, m);
 	return (0);
diff --git a/monitor_wrap.c b/monitor_wrap.c
index 461db95..da0f385 100644
--- a/monitor_wrap.c
+++ b/monitor_wrap.c
@@ -40,7 +40,6 @@
 
 #ifdef WITH_OPENSSL
 #include <openssl/bn.h>
-#include <openssl/dh.h>
 #include <openssl/evp.h>
 #endif
 
@@ -177,7 +176,7 @@ mm_request_receive_expect(int sock, enum monitor_reqtype type, struct sshbuf *m)
 }
 
 #ifdef WITH_OPENSSL
-DH *
+EVP_PKEY *
 mm_choose_dh(int min, int nbits, int max)
 {
 	BIGNUM *p, *g;
diff --git a/monitor_wrap.h b/monitor_wrap.h
index 84d3aaa..05f940f 100644
--- a/monitor_wrap.h
+++ b/monitor_wrap.h
@@ -43,7 +43,7 @@ struct sshkey_sig_details;
 void mm_log_handler(LogLevel, int, const char *, void *);
 int mm_is_monitor(void);
 #ifdef WITH_OPENSSL
-DH *mm_choose_dh(int, int, int);
+EVP_PKEY *mm_choose_dh(int, int, int);
 #endif
 int mm_sshkey_sign(struct ssh *, struct sshkey *, u_char **, size_t *,
     const u_char *, size_t, const char *, const char *,
diff --git a/openbsd-compat/libressl-api-compat.c b/openbsd-compat/libressl-api-compat.c
index 801a2e8..d0b84ff 100644
--- a/openbsd-compat/libressl-api-compat.c
+++ b/openbsd-compat/libressl-api-compat.c
@@ -157,6 +157,7 @@
 #endif
 #include <openssl/dh.h>
 
+#if OPENSSL_VERSION_NUMBER < 0x30000000L
 #ifndef HAVE_DSA_GET0_PQG
 void
 DSA_get0_pqg(const DSA *d, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)
@@ -335,6 +336,7 @@ RSA_set0_factors(RSA *r, BIGNUM *p, BIGNUM *q)
 #endif /* HAVE_RSA_SET0_FACTORS */
 
 #ifndef HAVE_EVP_CIPHER_CTX_GET_IV
+#ifndef HAVE_EVP_CIPHER_CTX_GET_UPDATED_IV
 int
 EVP_CIPHER_CTX_get_iv(const EVP_CIPHER_CTX *ctx, unsigned char *iv, size_t len)
 {
@@ -361,37 +363,9 @@ EVP_CIPHER_CTX_get_iv(const EVP_CIPHER_CTX *ctx, unsigned char *iv, size_t len)
 	}
 	return 1;
 }
+#endif /* HAVE_EVP_CIPHER_CTX_GET_UPDATED_IV */
 #endif /* HAVE_EVP_CIPHER_CTX_GET_IV */
 
-#ifndef HAVE_EVP_CIPHER_CTX_SET_IV
-int
-EVP_CIPHER_CTX_set_iv(EVP_CIPHER_CTX *ctx, const unsigned char *iv, size_t len)
-{
-	if (ctx == NULL)
-		return 0;
-	if (EVP_CIPHER_CTX_iv_length(ctx) < 0)
-		return 0;
-	if (len != (size_t)EVP_CIPHER_CTX_iv_length(ctx))
-		return 0;
-	if (len > EVP_MAX_IV_LENGTH)
-		return 0; /* sanity check; shouldn't happen */
-	/*
-	 * Skip the memcpy entirely when the requested IV length is zero,
-	 * since the iv pointer may be NULL or invalid.
-	 */
-	if (len != 0) {
-		if (iv == NULL)
-			return 0;
-# ifdef HAVE_EVP_CIPHER_CTX_IV_NOCONST
-		memcpy(EVP_CIPHER_CTX_iv_noconst(ctx), iv, len);
-# else
-		memcpy(ctx->iv, iv, len);
-# endif /* HAVE_EVP_CIPHER_CTX_IV_NOCONST */
-	}
-	return 1;
-}
-#endif /* HAVE_EVP_CIPHER_CTX_SET_IV */
-
 #ifndef HAVE_DSA_SIG_GET0
 void
 DSA_SIG_get0(const DSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps)
@@ -636,5 +610,101 @@ EVP_MD_CTX_free(EVP_MD_CTX *ctx)
 	free(ctx);
 }
 #endif /* HAVE_EVP_MD_CTX_FREE */
+#endif /* OPENSSL_VERSION_NUMBER < 0x30000000L */
+
+#if OPENSSL_VERSION_NUMBER < 0x30000000L
+//XXX(ossl3): separate method tests
+static int EVP_PKEY_is_a(const EVP_PKEY *pkey, const char *name)
+{
+	int rc = 0;
+
+	if (strcmp(name, "DSA") == 0 &&
+			EVP_PKEY_get0_DSA((EVP_PKEY *) pkey) != NULL) {
+		rc = 1;
+	} else if (strcmp(name, "RSA") == 0 &&
+			EVP_PKEY_get0_RSA((EVP_PKEY *) pkey) != NULL) {
+		rc = 1;
+	}
+
+	return rc;
+}
+
+static int EVP_PKEY_get_bn_param(const EVP_PKEY *pkey,
+				 const char *key_name,
+				 BIGNUM **bn)
+{
+	DSA *dsa = EVP_PKEY_is_a(pkey, "DSA") ?
+	    EVP_PKEY_get0_DSA((EVP_PKEY *) pkey) : NULL;
+	RSA *rsa = EVP_PKEY_is_a(pkey, "RSA") ?
+	    EVP_PKEY_get0_RSA((EVP_PKEY *) pkey) : NULL;
+	const BIGNUM *val = NULL;
+	int rc = 0;
+
+	if (dsa != NULL) {
+		if (strcmp(key_name, OSSL_PKEY_PARAM_PUB_KEY) == 0) {
+			DSA_get0_key(dsa, &val, NULL);
+		} else if (strcmp(key_name, OSSL_PKEY_PARAM_PRIV_KEY) == 0) {
+			DSA_get0_key(dsa, NULL, &val);
+		} else if (strcmp(key_name, OSSL_PKEY_PARAM_FFC_P) == 0) {
+			DSA_get0_pqg(dsa, &val, NULL, NULL);
+		} else if (strcmp(key_name, OSSL_PKEY_PARAM_FFC_Q) == 0) {
+			DSA_get0_pqg(dsa, NULL, &val, NULL);
+		} else if (strcmp(key_name, OSSL_PKEY_PARAM_FFC_G) == 0) {
+			DSA_get0_pqg(dsa, NULL, NULL, &val);
+		}
+	} else if (rsa != NULL) {
+		if (strcmp(key_name, OSSL_PKEY_PARAM_RSA_N) == 0) {
+			RSA_get0_key(rsa, &val, NULL, NULL);
+		} else if (strcmp(key_name, OSSL_PKEY_PARAM_RSA_E) == 0) {
+			RSA_get0_key(rsa, NULL, &val, NULL);
+		} else if (strcmp(key_name, OSSL_PKEY_PARAM_RSA_D) == 0) {
+			RSA_get0_key(rsa, NULL, NULL, &val);
+		}
+	}
+
+	if (val != NULL) {
+		*bn = BN_dup(val);
+		rc = 1;
+	}
+
+	return rc;
+}
+
+int EVP_PKEY_print_public_fp(FILE *fp, const EVP_PKEY *pkey, int indent,
+    ASN1_PCTX *pctx)
+{
+	int ret = 0;
+	BIO *out = BIO_new_fd(fileno(fd), BIO_NOCLOSE);
+	if (out != NULL) {
+		ret = EVP_PKEY_print_public(out, pkey, indent, pctx);
+		BIO_free(out);
+	}
+	return ret;
+}
+
+int EVP_PKEY_print_private_fp(FILE *fp, const EVP_PKEY *pkey, int indent,
+    ASN1_PCTX *pctx)
+{
+	int ret = 0;
+	BIO *out = BIO_new_fd(fileno(fd), BIO_NOCLOSE);
+	if (out != NULL) {
+		ret = EVP_PKEY_print_private(out, pkey, indent, pctx);
+		BIO_free(out);
+	}
+	return ret;
+}
+
+int EVP_PKEY_print_params_fp(FILE *fp, const EVP_PKEY *pkey, int indent,
+    ASN1_PCTX *pctx)
+{
+	int ret = 0;
+	BIO *out = BIO_new_fd(fileno(fd), BIO_NOCLOSE);
+	if (out != NULL) {
+		ret = EVP_PKEY_print_params(out, pkey, indent, pctx);
+		BIO_free(out);
+	}
+	return ret;
+}
+#endif
 
 #endif /* WITH_OPENSSL */
diff --git a/openbsd-compat/openssl-compat.c b/openbsd-compat/openssl-compat.c
index c174921..994dd30 100644
--- a/openbsd-compat/openssl-compat.c
+++ b/openbsd-compat/openssl-compat.c
@@ -80,8 +80,10 @@ ssh_libcrypto_init(void)
 
 #ifdef	USE_OPENSSL_ENGINE
 	/* Enable use of crypto hardware */
+#if OPENSSL_VERSION_NUMBER < 0x30000000L
 	ENGINE_load_builtin_engines();
 	ENGINE_register_all_complete();
+#endif
 
 	/* Load the libcrypto config file to pick up engines defined there */
 # if defined(HAVE_OPENSSL_INIT_CRYPTO) && defined(OPENSSL_INIT_LOAD_CONFIG)
diff --git a/openbsd-compat/openssl-compat.h b/openbsd-compat/openssl-compat.h
index 8ca50b5..d428bbb 100644
--- a/openbsd-compat/openssl-compat.h
+++ b/openbsd-compat/openssl-compat.h
@@ -29,6 +29,12 @@
 #include <openssl/ecdsa.h>
 #endif
 #include <openssl/dh.h>
+#if (OPENSSL_VERSION_NUMBER >= 0x30000000L)
+#include <openssl/core_names.h>
+#include <openssl/decoder.h>
+#include <openssl/encoder.h>
+#include <openssl/param_build.h>
+#endif
 
 int ssh_compatible_openssl(long, long);
 void ssh_libcrypto_init(void);
@@ -93,6 +99,7 @@ void ssh_aes_ctr_iv(EVP_CIPHER_CTX *, int, u_char *, size_t);
 # endif
 #endif
 
+#if (OPENSSL_VERSION_NUMBER < 0x30000000L)
 /* LibreSSL/OpenSSL 1.1x API compat */
 #ifndef HAVE_DSA_GET0_PQG
 void DSA_get0_pqg(const DSA *d, const BIGNUM **p, const BIGNUM **q,
@@ -121,11 +128,6 @@ int EVP_CIPHER_CTX_get_iv(const EVP_CIPHER_CTX *ctx,
 # endif /* HAVE_EVP_CIPHER_CTX_GET_UPDATED_IV */
 #endif /* HAVE_EVP_CIPHER_CTX_GET_IV */
 
-#ifndef HAVE_EVP_CIPHER_CTX_SET_IV
-int EVP_CIPHER_CTX_set_iv(EVP_CIPHER_CTX *ctx,
-    const unsigned char *iv, size_t len);
-#endif /* HAVE_EVP_CIPHER_CTX_SET_IV */
-
 #ifndef HAVE_RSA_GET0_KEY
 void RSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e,
     const BIGNUM **d);
@@ -232,6 +234,30 @@ EVP_MD_CTX *EVP_MD_CTX_new(void);
 #ifndef HAVE_EVP_MD_CTX_free
 void EVP_MD_CTX_free(EVP_MD_CTX *ctx);
 #endif /* HAVE_EVP_MD_CTX_free */
+#else
+#  define EVP_CIPHER_CTX_get_iv EVP_CIPHER_CTX_get_updated_iv
+#endif /* OPENSSL_VERSION_NUMBER < 0x30000000L */
+
+#if OPENSSL_VERSION_NUMBER < 0x30000000L
+//XXX(ossl3): test for each method separately
+#define OSSL_PKEY_PARAM_PUB_KEY "pub"
+#define OSSL_PKEY_PARAM_PRIV_KEY "priv"
+#define OSSL_PKEY_PARAM_FFC_P "p"
+#define OSSL_PKEY_PARAM_FFC_Q "q"
+#define OSSL_PKEY_PARAM_FFC_G "g"
+#define OSSL_PKEY_PARAM_RSA_N "n"
+#define OSSL_PKEY_PARAM_RSA_E "e"
+#define OSSL_PKEY_PARAM_RSA_D "d"
+int EVP_PKEY_is_a(const EVP_PKEY *pkey, const char *name);
+int EVP_PKEY_get_bn_param(const EVP_PKEY *pkey, const char *key_name,
+    BIGNUM **bn);
+int EVP_PKEY_print_public_fp(FILE *fp, const EVP_PKEY *pkey, int indent,
+    ASN1_PCTX *pctx);
+int EVP_PKEY_print_private_fp(FILE *fp, const EVP_PKEY *pkey, int indent,
+    ASN1_PCTX *pctx);
+int EVP_PKEY_print_params_fp(FILE *fp, const EVP_PKEY *pkey, int indent,
+    ASN1_PCTX *pctx);
+#endif /* OPENSSL_VERSION_NUMBER < 0x30000000L */
 
 #endif /* WITH_OPENSSL */
 #endif /* _OPENSSL_COMPAT_H */
diff --git a/regress/unittests/sshbuf/test_sshbuf_getput_crypto.c b/regress/unittests/sshbuf/test_sshbuf_getput_crypto.c
index e3620e9..59b1b96 100644
--- a/regress/unittests/sshbuf/test_sshbuf_getput_crypto.c
+++ b/regress/unittests/sshbuf/test_sshbuf_getput_crypto.c
@@ -18,10 +18,15 @@
 #include <string.h>
 
 #include <openssl/bn.h>
+#include <openssl/evp.h>
 #include <openssl/objects.h>
 #ifdef OPENSSL_HAS_NISTP256
 # include <openssl/ec.h>
 #endif
+#if (OPENSSL_VERSION_NUMBER >= 0x30000000L)
+#include <openssl/core_names.h>
+#include <openssl/param_build.h>
+#endif
 
 #include "../test_helper/test_helper.h"
 #include "ssherr.h"
@@ -66,8 +71,14 @@ sshbuf_getput_crypto_tests(void)
 		0xc8, 0xf9, 0xa3, 0x5e, 0x42, 0xbd, 0xd0, 0x47,
 		0x55, 0x0f, 0x69, 0xd8, 0x0e, 0xc2, 0x3c, 0xd4
 	};
-	EC_KEY *eck;
+	EC_GROUP *ecg;
 	EC_POINT *ecp;
+	char ec_pub_buf[1024];
+	size_t ec_pub_len;
+	OSSL_PARAM_BLD *bld;
+	OSSL_PARAM *params;
+	EVP_PKEY_CTX *pctx;
+	EVP_PKEY *pkey;
 #endif
 	int r;
 
@@ -224,51 +235,75 @@ sshbuf_getput_crypto_tests(void)
 
 #if defined(OPENSSL_HAS_ECC) && defined(OPENSSL_HAS_NISTP256)
 	TEST_START("sshbuf_put_ec");
-	eck = EC_KEY_new_by_curve_name(ec256_nid);
-	ASSERT_PTR_NE(eck, NULL);
-	ecp = EC_POINT_new(EC_KEY_get0_group(eck));
+	ecg = EC_GROUP_new_by_curve_name(ec256_nid);
+	ASSERT_PTR_NE(ecg, NULL);
+	ecp = EC_POINT_new(ecg);
 	ASSERT_PTR_NE(ecp, NULL);
 	MKBN(ec256_x, bn_x);
 	MKBN(ec256_y, bn_y);
-	ASSERT_INT_EQ(EC_POINT_set_affine_coordinates_GFp(
-	    EC_KEY_get0_group(eck), ecp, bn_x, bn_y, NULL), 1);
-	ASSERT_INT_EQ(EC_KEY_set_public_key(eck, ecp), 1);
+	ASSERT_INT_EQ(EC_POINT_set_affine_coordinates(
+	    ecg, ecp, bn_x, bn_y, NULL), 1);
+	ec_pub_len = EC_POINT_point2oct(ecg, ecp,
+	    POINT_CONVERSION_UNCOMPRESSED, NULL, 0, NULL);
+	ASSERT_SIZE_T_LE(ec_pub_len, sizeof(ec_pub_buf));
+	ASSERT_SIZE_T_NE(EC_POINT_point2oct(ecg, ecp,
+	    POINT_CONVERSION_UNCOMPRESSED, ec_pub_buf, ec_pub_len, NULL), 0);
+	bld = OSSL_PARAM_BLD_new();
+	ASSERT_PTR_NE(bld, NULL);
+	ASSERT_INT_EQ(OSSL_PARAM_BLD_push_utf8_string(bld,
+	    OSSL_PKEY_PARAM_GROUP_NAME, OBJ_nid2sn(ec256_nid), 0), 1);
+	ASSERT_INT_EQ(OSSL_PARAM_BLD_push_octet_string(bld,
+	    OSSL_PKEY_PARAM_PUB_KEY, ec_pub_buf, ec_pub_len), 1);
+	params = OSSL_PARAM_BLD_to_param(bld);
+	ASSERT_PTR_NE(params, NULL);
+	pctx = EVP_PKEY_CTX_new_from_name(NULL, "EC", NULL);
+	ASSERT_PTR_NE(pctx, NULL);
+	ASSERT_INT_EQ(EVP_PKEY_fromdata_init(pctx), 1);
+	pkey = NULL;
+	ASSERT_INT_EQ(EVP_PKEY_fromdata(pctx, &pkey, EVP_PKEY_PUBLIC_KEY,
+	    params), 1);
 	BN_free(bn_x);
 	BN_free(bn_y);
+	EVP_PKEY_CTX_free(pctx);
+	OSSL_PARAM_free(params);
+	OSSL_PARAM_BLD_free(bld);
 	EC_POINT_free(ecp);
+	EC_GROUP_free(ecg);
 	p1 = sshbuf_new();
 	ASSERT_PTR_NE(p1, NULL);
-	ASSERT_INT_EQ(sshbuf_put_eckey(p1, eck), 0);
+	ASSERT_INT_EQ(sshbuf_put_eckey(p1, pkey), 0);
 	ASSERT_INT_EQ(sshbuf_get_string_direct(p1, &d, &s), 0);
 	ASSERT_SIZE_T_EQ(s, sizeof(expec256));
 	ASSERT_MEM_EQ(d, expec256, sizeof(expec256));
 	sshbuf_free(p1);
-	EC_KEY_free(eck);
+	EVP_PKEY_free(pkey);
 	TEST_DONE();
 
 	TEST_START("sshbuf_get_ec");
-	eck = EC_KEY_new_by_curve_name(ec256_nid);
-	ASSERT_PTR_NE(eck, NULL);
+	ecg = EC_GROUP_new_by_curve_name(ec256_nid);
+	ASSERT_PTR_NE(ecg, NULL);
 	p1 = sshbuf_new();
 	ASSERT_PTR_NE(p1, NULL);
 	ASSERT_INT_EQ(sshbuf_put_string(p1, expec256, sizeof(expec256)), 0);
 	ASSERT_SIZE_T_EQ(sshbuf_len(p1), sizeof(expec256) + 4);
 	ASSERT_INT_EQ(sshbuf_put_u8(p1, 0x00), 0);
-	ASSERT_INT_EQ(sshbuf_get_eckey(p1, eck), 0);
+	ecp = EC_POINT_new(ecg);
+	ASSERT_PTR_NE(ecp, NULL);
+	ASSERT_INT_EQ(sshbuf_get_ec(p1, ecp, ecg), 0);
 	bn_x = BN_new();
 	bn_y = BN_new();
 	ASSERT_PTR_NE(bn_x, NULL);
 	ASSERT_PTR_NE(bn_y, NULL);
-	ASSERT_INT_EQ(EC_POINT_get_affine_coordinates_GFp(
-	    EC_KEY_get0_group(eck), EC_KEY_get0_public_key(eck),
-	    bn_x, bn_y, NULL), 1);
+	ASSERT_INT_EQ(EC_POINT_get_affine_coordinates(
+	    ecg, ecp, bn_x, bn_y, NULL), 1);
 	MKBN(ec256_x, bn);
 	MKBN(ec256_y, bn2);
 	ASSERT_INT_EQ(BN_cmp(bn_x, bn), 0);
 	ASSERT_INT_EQ(BN_cmp(bn_y, bn2), 0);
 	ASSERT_SIZE_T_EQ(sshbuf_len(p1), 1);
+	EC_POINT_free(ecp);
+	EC_GROUP_free(ecg);
 	sshbuf_free(p1);
-	EC_KEY_free(eck);
 	BN_free(bn_x);
 	BN_free(bn_y);
 	BN_free(bn);
diff --git a/regress/unittests/sshbuf/test_sshbuf_getput_fuzz.c b/regress/unittests/sshbuf/test_sshbuf_getput_fuzz.c
index 3b48958..46a8205 100644
--- a/regress/unittests/sshbuf/test_sshbuf_getput_fuzz.c
+++ b/regress/unittests/sshbuf/test_sshbuf_getput_fuzz.c
@@ -36,7 +36,8 @@ attempt_parse_blob(u_char *blob, size_t len)
 #ifdef WITH_OPENSSL
 	BIGNUM *bn;
 #if defined(OPENSSL_HAS_ECC) && defined(OPENSSL_HAS_NISTP256)
-	EC_KEY *eck;
+	EC_GROUP *ecg;
+	EC_POINT *ecp;
 #endif /* defined(OPENSSL_HAS_ECC) && defined(OPENSSL_HAS_NISTP256) */
 #endif /* WITH_OPENSSL */
 	u_char *s;
@@ -62,10 +63,13 @@ attempt_parse_blob(u_char *blob, size_t len)
 	sshbuf_get_bignum2(p1, &bn);
 	BN_clear_free(bn);
 #if defined(OPENSSL_HAS_ECC) && defined(OPENSSL_HAS_NISTP256)
-	eck = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
-	ASSERT_PTR_NE(eck, NULL);
-	sshbuf_get_eckey(p1, eck);
-	EC_KEY_free(eck);
+	ecg = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1);
+	ASSERT_PTR_NE(ecg, NULL);
+	ecp = EC_POINT_new(ecg);
+	ASSERT_PTR_NE(ecp, NULL);
+	sshbuf_get_ec(p1, ecp, ecg);
+	EC_POINT_free(ecp);
+	EC_GROUP_free(ecg);
 #endif /* defined(OPENSSL_HAS_ECC) && defined(OPENSSL_HAS_NISTP256) */
 #endif /* WITH_OPENSSL */
 	sshbuf_free(p1);
diff --git a/regress/unittests/sshkey/common.c b/regress/unittests/sshkey/common.c
index 51b0d92..b49f13f 100644
--- a/regress/unittests/sshkey/common.c
+++ b/regress/unittests/sshkey/common.c
@@ -83,81 +83,269 @@ load_bignum(const char *name)
 	return ret;
 }
 
-const BIGNUM *
-rsa_n(struct sshkey *k)
+int
+has_rsa_n(struct sshkey *k)
 {
-	const BIGNUM *n = NULL;
+	BIGNUM *n = NULL;
+	int r = 0;
 
 	ASSERT_PTR_NE(k, NULL);
 	ASSERT_PTR_NE(k->rsa, NULL);
-	RSA_get0_key(k->rsa, &n, NULL, NULL);
-	return n;
+	if (EVP_PKEY_get_bn_param(k->rsa, OSSL_PKEY_PARAM_RSA_N, &n) == 1) {
+		BN_clear_free(n);
+		r = 1;
+	}
+	return r;
+}
+
+int
+has_rsa_e(struct sshkey *k)
+{
+	BIGNUM *e = NULL;
+	int r = 0;
+
+	ASSERT_PTR_NE(k, NULL);
+	ASSERT_PTR_NE(k->rsa, NULL);
+	if (EVP_PKEY_get_bn_param(k->rsa, OSSL_PKEY_PARAM_RSA_E, &e) == 1) {
+		BN_clear_free(e);
+		r = 1;
+	}
+	return r;
+}
+
+int
+has_rsa_p(struct sshkey *k)
+{
+	BIGNUM *p = NULL;
+	int r = 0;
+
+	ASSERT_PTR_NE(k, NULL);
+	ASSERT_PTR_NE(k->rsa, NULL);
+	if (EVP_PKEY_get_bn_param(k->rsa, OSSL_PKEY_PARAM_RSA_FACTOR1, &p)
+	    == 1) {
+		BN_clear_free(p);
+		r = 1;
+	}
+	return r;
+}
+
+int
+has_rsa_q(struct sshkey *k)
+{
+	BIGNUM *q = NULL;
+	int r = 0;
+
+	ASSERT_PTR_NE(k, NULL);
+	ASSERT_PTR_NE(k->rsa, NULL);
+	if (EVP_PKEY_get_bn_param(k->rsa, OSSL_PKEY_PARAM_RSA_FACTOR2, &q)
+	    == 1) {
+		BN_clear_free(q);
+		r = 1;
+	}
+	return r;
+}
+
+int
+has_dsa_g(struct sshkey *k)
+{
+	BIGNUM *g = NULL;
+	int r = 0;
+
+	ASSERT_PTR_NE(k, NULL);
+	ASSERT_PTR_NE(k->dsa, NULL);
+	if (EVP_PKEY_get_bn_param(k->dsa, OSSL_PKEY_PARAM_FFC_G, &g) == 1) {
+		BN_clear_free(g);
+		r = 1;
+	}
+	return r;
+}
+
+int
+has_dsa_pub_key(struct sshkey *k)
+{
+	BIGNUM *pub_key = NULL;
+	int r = 0;
+
+	ASSERT_PTR_NE(k, NULL);
+	ASSERT_PTR_NE(k->dsa, NULL);
+	if (EVP_PKEY_get_bn_param(k->dsa, OSSL_PKEY_PARAM_PUB_KEY, &pub_key)
+	    == 1) {
+		BN_clear_free(pub_key);
+		r = 1;
+	}
+	return r;
+}
+
+int
+has_dsa_priv_key(struct sshkey *k)
+{
+	BIGNUM *priv_key = NULL;
+	int r = 0;
+
+	ASSERT_PTR_NE(k, NULL);
+	ASSERT_PTR_NE(k->dsa, NULL);
+	if (EVP_PKEY_get_bn_param(k->dsa, OSSL_PKEY_PARAM_PRIV_KEY, &priv_key)
+	    == 1) {
+		BN_clear_free(priv_key);
+		r = 1;
+	}
+	return r;
+}
+
+int
+has_ec_pub_key(struct sshkey *k)
+{
+	char pubbuf[4096];
+	size_t publen = 0;
+	int r = 0;
+
+	ASSERT_PTR_NE(k, NULL);
+	ASSERT_PTR_NE(k->ecdsa, NULL);
+	if (EVP_PKEY_get_octet_string_param(k->ecdsa, OSSL_PKEY_PARAM_PUB_KEY,
+	    NULL, 0, &publen) == 1) {
+		ASSERT_SIZE_T_LT(publen, sizeof(pubbuf));
+		if (publen > 0 && EVP_PKEY_get_octet_string_param(k->ecdsa,
+		    OSSL_PKEY_PARAM_PUB_KEY, pubbuf, publen, NULL) == 1)
+			r = 1;
+	}
+	return r;
+}
+
+int
+has_ec_priv_key(struct sshkey *k)
+{
+	BIGNUM *priv_key = NULL;
+	int r = 0;
+
+	ASSERT_PTR_NE(k, NULL);
+	ASSERT_PTR_NE(k->ecdsa, NULL);
+	if (EVP_PKEY_get_bn_param(k->ecdsa, OSSL_PKEY_PARAM_PRIV_KEY,
+	    &priv_key) == 1) {
+		BN_clear_free(priv_key);
+		r = 1;
+	}
+	return r;
 }
 
-const BIGNUM *
-rsa_e(struct sshkey *k)
+int
+with_rsa_n(struct sshkey *k, const BIGNUM *exp)
 {
-	const BIGNUM *e = NULL;
+	BIGNUM *n = NULL;
+	int r;
 
 	ASSERT_PTR_NE(k, NULL);
 	ASSERT_PTR_NE(k->rsa, NULL);
-	RSA_get0_key(k->rsa, NULL, &e, NULL);
-	return e;
+	ASSERT_INT_EQ(EVP_PKEY_get_bn_param(k->rsa,
+	    OSSL_PKEY_PARAM_RSA_N, &n), 1);
+	r = BN_cmp(n, exp);
+	BN_clear_free(n);
+	return r == 0;
 }
 
-const BIGNUM *
-rsa_p(struct sshkey *k)
+int
+with_rsa_e(struct sshkey *k, const BIGNUM *exp)
 {
-	const BIGNUM *p = NULL;
+	BIGNUM *e = NULL;
+	int r;
 
 	ASSERT_PTR_NE(k, NULL);
 	ASSERT_PTR_NE(k->rsa, NULL);
-	RSA_get0_factors(k->rsa, &p, NULL);
-	return p;
+	ASSERT_INT_EQ(EVP_PKEY_get_bn_param(k->rsa,
+	    OSSL_PKEY_PARAM_RSA_E, &e), 1);
+	r = BN_cmp(e, exp);
+	BN_clear_free(e);
+	return r == 0;
 }
 
-const BIGNUM *
-rsa_q(struct sshkey *k)
+int
+with_rsa_p(struct sshkey *k, const BIGNUM *exp)
 {
-	const BIGNUM *q = NULL;
+	BIGNUM *p = NULL;
+	int r;
 
 	ASSERT_PTR_NE(k, NULL);
 	ASSERT_PTR_NE(k->rsa, NULL);
-	RSA_get0_factors(k->rsa, NULL, &q);
-	return q;
+	ASSERT_INT_EQ(EVP_PKEY_get_bn_param(k->rsa,
+	    OSSL_PKEY_PARAM_RSA_FACTOR1, &p), 1);
+	r = BN_cmp(p, exp);
+	BN_clear_free(p);
+	return r == 0;
 }
 
-const BIGNUM *
-dsa_g(struct sshkey *k)
+int
+with_rsa_q(struct sshkey *k, const BIGNUM *exp)
 {
-	const BIGNUM *g = NULL;
+	BIGNUM *q = NULL;
+	int r;
+
+	ASSERT_PTR_NE(k, NULL);
+	ASSERT_PTR_NE(k->rsa, NULL);
+	ASSERT_INT_EQ(EVP_PKEY_get_bn_param(k->rsa,
+	    OSSL_PKEY_PARAM_RSA_FACTOR2, &q), 1);
+	r = BN_cmp(q, exp);
+	BN_clear_free(q);
+	return r == 0;
+}
+
+int
+with_dsa_g(struct sshkey *k, const BIGNUM *exp)
+{
+	BIGNUM *g = NULL;
+	int r;
 
 	ASSERT_PTR_NE(k, NULL);
 	ASSERT_PTR_NE(k->dsa, NULL);
-	DSA_get0_pqg(k->dsa, NULL, NULL, &g);
-	return g;
+	ASSERT_INT_EQ(EVP_PKEY_get_bn_param(k->dsa,
+	    OSSL_PKEY_PARAM_FFC_G, &g), 1);
+	r = BN_cmp(g, exp);
+	BN_clear_free(g);
+	return r == 0;
 }
 
-const BIGNUM *
-dsa_pub_key(struct sshkey *k)
+int
+with_dsa_pub_key(struct sshkey *k, const BIGNUM *exp)
 {
-	const BIGNUM *pub_key = NULL;
+	BIGNUM *pub_key = NULL;
+	int r;
 
 	ASSERT_PTR_NE(k, NULL);
 	ASSERT_PTR_NE(k->dsa, NULL);
-	DSA_get0_key(k->dsa, &pub_key, NULL);
-	return pub_key;
+	ASSERT_INT_EQ(EVP_PKEY_get_bn_param(k->dsa,
+	    OSSL_PKEY_PARAM_PUB_KEY, &pub_key), 1);
+	r = BN_cmp(pub_key, exp);
+	BN_clear_free(pub_key);
+	return r == 0;
 }
 
-const BIGNUM *
-dsa_priv_key(struct sshkey *k)
+int
+with_dsa_priv_key(struct sshkey *k, const BIGNUM *exp)
 {
-	const BIGNUM *priv_key = NULL;
+	BIGNUM *priv_key = NULL;
+	int r;
 
 	ASSERT_PTR_NE(k, NULL);
 	ASSERT_PTR_NE(k->dsa, NULL);
-	DSA_get0_key(k->dsa, NULL, &priv_key);
-	return priv_key;
+	ASSERT_INT_EQ(EVP_PKEY_get_bn_param(k->dsa,
+	    OSSL_PKEY_PARAM_PRIV_KEY, &priv_key), 1);
+	r = BN_cmp(priv_key, exp);
+	BN_clear_free(priv_key);
+	return r == 0;
+}
+
+int
+rsa_n_size(struct sshkey *k)
+{
+	BIGNUM *n = NULL;
+	int r;
+
+	ASSERT_PTR_NE(k, NULL);
+	ASSERT_PTR_NE(k->rsa, NULL);
+	ASSERT_INT_EQ(EVP_PKEY_get_bn_param(k->rsa,
+	    OSSL_PKEY_PARAM_RSA_N, &n), 1);
+	r = BN_num_bits(n);
+	BN_clear_free(n);
+	return r;
 }
+
 #endif /* WITH_OPENSSL */
 
diff --git a/regress/unittests/sshkey/common.h b/regress/unittests/sshkey/common.h
index 7a514fd..2987168 100644
--- a/regress/unittests/sshkey/common.h
+++ b/regress/unittests/sshkey/common.h
@@ -14,12 +14,23 @@ struct sshbuf *load_text_file(const char *name);
 /* Load a bignum from a file */
 BIGNUM *load_bignum(const char *name);
 
-/* Accessors for key components */
-const BIGNUM *rsa_n(struct sshkey *k);
-const BIGNUM *rsa_e(struct sshkey *k);
-const BIGNUM *rsa_p(struct sshkey *k);
-const BIGNUM *rsa_q(struct sshkey *k);
-const BIGNUM *dsa_g(struct sshkey *k);
-const BIGNUM *dsa_pub_key(struct sshkey *k);
-const BIGNUM *dsa_priv_key(struct sshkey *k);
+/* Tests for key components */
+int has_rsa_n(struct sshkey *k);
+int has_rsa_e(struct sshkey *k);
+int has_rsa_p(struct sshkey *k);
+int has_rsa_q(struct sshkey *k);
+int has_dsa_g(struct sshkey *k);
+int has_dsa_pub_key(struct sshkey *k);
+int has_dsa_priv_key(struct sshkey *k);
+int has_ec_pub_key(struct sshkey *k);
+int has_ec_priv_key(struct sshkey *k);
 
+int with_rsa_n(struct sshkey *k, const BIGNUM *exp);
+int with_rsa_e(struct sshkey *k, const BIGNUM *exp);
+int with_rsa_p(struct sshkey *k, const BIGNUM *exp);
+int with_rsa_q(struct sshkey *k, const BIGNUM *exp);
+int with_dsa_g(struct sshkey *k, const BIGNUM *exp);
+int with_dsa_pub_key(struct sshkey *k, const BIGNUM *exp);
+int with_dsa_priv_key(struct sshkey *k, const BIGNUM *exp);
+
+int rsa_n_size(struct sshkey *k);
diff --git a/regress/unittests/sshkey/test_file.c b/regress/unittests/sshkey/test_file.c
index 497ab6d..0d83b54 100644
--- a/regress/unittests/sshkey/test_file.c
+++ b/regress/unittests/sshkey/test_file.c
@@ -26,6 +26,9 @@
 #ifdef OPENSSL_HAS_NISTP256
 # include <openssl/ec.h>
 #endif /* OPENSSL_HAS_NISTP256 */
+#if (OPENSSL_VERSION_NUMBER >= 0x30000000L)
+#include <openssl/core_names.h>
+#endif /* OPENSSL_VERSION_NUMBER > 3 */
 #endif /* WITH_OPENSSL */
 
 #include "../test_helper/test_helper.h"
@@ -46,7 +49,12 @@ sshkey_file_tests(void)
 	struct sshkey *k1, *k2;
 	struct sshbuf *buf, *pw;
 #ifdef WITH_OPENSSL
-	BIGNUM *a, *b, *c;
+	BIGNUM *a, *b, *c, *ec_priv_key;
+	unsigned char *bnbuf;
+	char ec_pub_buf[1024];
+	size_t ec_pub_len = 0, bnbuf_len = 0;
+	EC_POINT *ec_pub_key;
+	EC_GROUP *ec_group;
 #endif
 	char *cp;
 
@@ -64,9 +72,9 @@ sshkey_file_tests(void)
 	a = load_bignum("rsa_1.param.n");
 	b = load_bignum("rsa_1.param.p");
 	c = load_bignum("rsa_1.param.q");
-	ASSERT_BIGNUM_EQ(rsa_n(k1), a);
-	ASSERT_BIGNUM_EQ(rsa_p(k1), b);
-	ASSERT_BIGNUM_EQ(rsa_q(k1), c);
+	ASSERT_INT_EQ(with_rsa_n(k1, a), 1);
+	ASSERT_INT_EQ(with_rsa_p(k1, b), 1);
+	ASSERT_INT_EQ(with_rsa_q(k1, c), 1);
 	BN_free(a);
 	BN_free(b);
 	BN_free(c);
@@ -173,9 +181,9 @@ sshkey_file_tests(void)
 	a = load_bignum("dsa_1.param.g");
 	b = load_bignum("dsa_1.param.priv");
 	c = load_bignum("dsa_1.param.pub");
-	ASSERT_BIGNUM_EQ(dsa_g(k1), a);
-	ASSERT_BIGNUM_EQ(dsa_priv_key(k1), b);
-	ASSERT_BIGNUM_EQ(dsa_pub_key(k1), c);
+	ASSERT_INT_EQ(with_dsa_g(k1, a), 1);
+	ASSERT_INT_EQ(with_dsa_priv_key(k1, b), 1);
+	ASSERT_INT_EQ(with_dsa_pub_key(k1, c), 1);
 	BN_free(a);
 	BN_free(b);
 	BN_free(c);
@@ -268,12 +276,31 @@ sshkey_file_tests(void)
 	sshbuf_free(buf);
 	a = load_bignum("ecdsa_1.param.priv");
 	b = load_bignum("ecdsa_1.param.pub");
-	c = EC_POINT_point2bn(EC_KEY_get0_group(k1->ecdsa),
-	    EC_KEY_get0_public_key(k1->ecdsa), POINT_CONVERSION_UNCOMPRESSED,
-	    NULL, NULL);
+	ASSERT_INT_EQ(EVP_PKEY_get_octet_string_param(k1->ecdsa,
+	    OSSL_PKEY_PARAM_PUB_KEY, NULL, 0, &ec_pub_len), 1);
+	ASSERT_INT_LE(ec_pub_len, sizeof(ec_pub_buf));
+	ASSERT_INT_EQ(EVP_PKEY_get_octet_string_param(k1->ecdsa,
+	    OSSL_PKEY_PARAM_PUB_KEY, ec_pub_buf, ec_pub_len, NULL), 1);
+	ec_group = EC_GROUP_new_by_curve_name(k1->ecdsa_nid);
+	ASSERT_PTR_NE(ec_group, NULL);
+	ec_pub_key = EC_POINT_new(ec_group);
+	ASSERT_PTR_NE(ec_pub_key, NULL);
+	ASSERT_INT_EQ(EC_POINT_oct2point(ec_group, ec_pub_key, ec_pub_buf,
+	    ec_pub_len, NULL), 1);
+	bnbuf_len = EC_POINT_point2buf(ec_group, ec_pub_key,
+	    POINT_CONVERSION_UNCOMPRESSED, &bnbuf, NULL);
+	ASSERT_INT_NE(bnbuf_len, 0);
+	c = BN_bin2bn(bnbuf, bnbuf_len, NULL);
+	OPENSSL_free(bnbuf);
 	ASSERT_PTR_NE(c, NULL);
-	ASSERT_BIGNUM_EQ(EC_KEY_get0_private_key(k1->ecdsa), a);
+	ec_priv_key = NULL;
+	ASSERT_INT_EQ(EVP_PKEY_get_bn_param(k1->ecdsa,
+	    OSSL_PKEY_PARAM_PRIV_KEY, &ec_priv_key), 1);
+	ASSERT_BIGNUM_EQ(ec_priv_key, a);
 	ASSERT_BIGNUM_EQ(b, c);
+	BN_free(ec_priv_key);
+	EC_POINT_free(ec_pub_key);
+	EC_GROUP_free(ec_group);
 	BN_free(a);
 	BN_free(b);
 	BN_free(c);
diff --git a/regress/unittests/sshkey/test_sshkey.c b/regress/unittests/sshkey/test_sshkey.c
index 982907c..960646f 100644
--- a/regress/unittests/sshkey/test_sshkey.c
+++ b/regress/unittests/sshkey/test_sshkey.c
@@ -204,14 +204,14 @@ sshkey_tests(void)
 	TEST_START("new/free KEY_RSA");
 	k1 = sshkey_new(KEY_RSA);
 	ASSERT_PTR_NE(k1, NULL);
-	ASSERT_PTR_NE(k1->rsa, NULL);
+	ASSERT_PTR_EQ(k1->rsa, NULL); /* Blank until loaded/generated */
 	sshkey_free(k1);
 	TEST_DONE();
 
 	TEST_START("new/free KEY_DSA");
 	k1 = sshkey_new(KEY_DSA);
 	ASSERT_PTR_NE(k1, NULL);
-	ASSERT_PTR_NE(k1->dsa, NULL);
+	ASSERT_PTR_EQ(k1->dsa, NULL); /* Blank until loaded/generated */
 	sshkey_free(k1);
 	TEST_DONE();
 
@@ -267,18 +267,18 @@ sshkey_tests(void)
 	ASSERT_INT_EQ(sshkey_generate(KEY_RSA, 1024, &kr), 0);
 	ASSERT_PTR_NE(kr, NULL);
 	ASSERT_PTR_NE(kr->rsa, NULL);
-	ASSERT_PTR_NE(rsa_n(kr), NULL);
-	ASSERT_PTR_NE(rsa_e(kr), NULL);
-	ASSERT_PTR_NE(rsa_p(kr), NULL);
-	ASSERT_INT_EQ(BN_num_bits(rsa_n(kr)), 1024);
+	ASSERT_INT_EQ(has_rsa_n(kr), 1);
+	ASSERT_INT_EQ(has_rsa_e(kr), 1);
+	ASSERT_INT_EQ(has_rsa_p(kr), 1);
+	ASSERT_INT_EQ(rsa_n_size(kr), 1024);
 	TEST_DONE();
 
 	TEST_START("generate KEY_DSA");
 	ASSERT_INT_EQ(sshkey_generate(KEY_DSA, 1024, &kd), 0);
 	ASSERT_PTR_NE(kd, NULL);
 	ASSERT_PTR_NE(kd->dsa, NULL);
-	ASSERT_PTR_NE(dsa_g(kd), NULL);
-	ASSERT_PTR_NE(dsa_priv_key(kd), NULL);
+	ASSERT_INT_EQ(has_dsa_g(kd), 1);
+	ASSERT_INT_EQ(has_dsa_priv_key(kd), 1);
 	TEST_DONE();
 
 #ifdef OPENSSL_HAS_ECC
@@ -286,8 +286,8 @@ sshkey_tests(void)
 	ASSERT_INT_EQ(sshkey_generate(KEY_ECDSA, 256, &ke), 0);
 	ASSERT_PTR_NE(ke, NULL);
 	ASSERT_PTR_NE(ke->ecdsa, NULL);
-	ASSERT_PTR_NE(EC_KEY_get0_public_key(ke->ecdsa), NULL);
-	ASSERT_PTR_NE(EC_KEY_get0_private_key(ke->ecdsa), NULL);
+	ASSERT_INT_EQ(has_ec_pub_key(ke), 1);
+	ASSERT_INT_EQ(has_ec_priv_key(ke), 1);
 	TEST_DONE();
 #endif /* OPENSSL_HAS_ECC */
 #endif /* WITH_OPENSSL */
@@ -307,9 +307,9 @@ sshkey_tests(void)
 	ASSERT_PTR_NE(kr, k1);
 	ASSERT_INT_EQ(k1->type, KEY_RSA);
 	ASSERT_PTR_NE(k1->rsa, NULL);
-	ASSERT_PTR_NE(rsa_n(k1), NULL);
-	ASSERT_PTR_NE(rsa_e(k1), NULL);
-	ASSERT_PTR_EQ(rsa_p(k1), NULL);
+	ASSERT_INT_EQ(has_rsa_n(k1), 1);
+	ASSERT_INT_EQ(has_rsa_e(k1), 1);
+	ASSERT_INT_EQ(has_rsa_p(k1), 0);
 	TEST_DONE();
 
 	TEST_START("equal KEY_RSA/demoted KEY_RSA");
@@ -323,8 +323,8 @@ sshkey_tests(void)
 	ASSERT_PTR_NE(kd, k1);
 	ASSERT_INT_EQ(k1->type, KEY_DSA);
 	ASSERT_PTR_NE(k1->dsa, NULL);
-	ASSERT_PTR_NE(dsa_g(k1), NULL);
-	ASSERT_PTR_EQ(dsa_priv_key(k1), NULL);
+	ASSERT_INT_EQ(has_dsa_g(k1), 1);
+	ASSERT_INT_EQ(has_dsa_priv_key(k1), 0);
 	TEST_DONE();
 
 	TEST_START("equal KEY_DSA/demoted KEY_DSA");
@@ -340,8 +340,8 @@ sshkey_tests(void)
 	ASSERT_INT_EQ(k1->type, KEY_ECDSA);
 	ASSERT_PTR_NE(k1->ecdsa, NULL);
 	ASSERT_INT_EQ(k1->ecdsa_nid, ke->ecdsa_nid);
-	ASSERT_PTR_NE(EC_KEY_get0_public_key(ke->ecdsa), NULL);
-	ASSERT_PTR_EQ(EC_KEY_get0_private_key(k1->ecdsa), NULL);
+	ASSERT_INT_EQ(has_ec_pub_key(k1), 1);
+	ASSERT_INT_EQ(has_ec_priv_key(k1), 0);
 	TEST_DONE();
 
 	TEST_START("equal KEY_ECDSA/demoted KEY_ECDSA");
diff --git a/regress/unittests/sshsig/tests.c b/regress/unittests/sshsig/tests.c
index fdc3bae..9daebee 100644
--- a/regress/unittests/sshsig/tests.c
+++ b/regress/unittests/sshsig/tests.c
@@ -86,8 +86,10 @@ tests(void)
 #endif
 
 #ifdef WITH_OPENSSL
+# if OPENSSL_VERSION_NUMBER < 0x30000000L
 	OpenSSL_add_all_algorithms();
 	ERR_load_CRYPTO_strings();
+# endif
 #endif
 
 	TEST_START("load data");
diff --git a/regress/unittests/test_helper/test_helper.c b/regress/unittests/test_helper/test_helper.c
index 6461d7f..ffbd2f7 100644
--- a/regress/unittests/test_helper/test_helper.c
+++ b/regress/unittests/test_helper/test_helper.c
@@ -130,7 +130,7 @@ main(int argc, char **argv)
 	int ch;
 
 	seed_rng();
-#ifdef WITH_OPENSSL
+#if defined(WITH_OPENSSL) && OPENSSL_VERSION_NUMBER < 0x30000000L
 	ERR_load_CRYPTO_strings();
 #endif
 
diff --git a/ssh-dss.c b/ssh-dss.c
index fddc29c..1fd5ad9 100644
--- a/ssh-dss.c
+++ b/ssh-dss.c
@@ -52,10 +52,14 @@ int
 ssh_dss_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
     const u_char *data, size_t datalen, u_int compat)
 {
+	EVP_PKEY_CTX *sctx = NULL;
 	DSA_SIG *sig = NULL;
 	const BIGNUM *sig_r, *sig_s;
 	u_char digest[SSH_DIGEST_MAX_LENGTH], sigblob[SIGBLOB_LEN];
 	size_t rlen, slen, len, dlen = ssh_digest_bytes(SSH_DIGEST_SHA1);
+	const unsigned char *psig;
+	unsigned char *tsig = NULL;
+	size_t tsiglen = 0;
 	struct sshbuf *b = NULL;
 	int ret = SSH_ERR_INVALID_ARGUMENT;
 
@@ -74,7 +78,24 @@ ssh_dss_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
 	    digest, sizeof(digest))) != 0)
 		goto out;
 
-	if ((sig = DSA_do_sign(digest, dlen, key->dsa)) == NULL) {
+	if ((sctx = EVP_PKEY_CTX_new(key->dsa, NULL)) == NULL) {
+		ret =  SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if (EVP_PKEY_sign_init(sctx) <= 0 ||
+	    EVP_PKEY_sign(sctx, NULL, &tsiglen, digest, dlen) <= 0) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if ((psig = tsig = malloc(tsiglen)) == NULL) {
+		ret = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	if (EVP_PKEY_sign(sctx, tsig, &tsiglen, digest, dlen) <= 0) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if (d2i_DSA_SIG(&sig, &psig, tsiglen) == NULL) {
 		ret = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
 	}
@@ -111,6 +132,8 @@ ssh_dss_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
 	ret = 0;
  out:
 	explicit_bzero(digest, sizeof(digest));
+	EVP_PKEY_CTX_free(sctx);
+	freezero(tsig, tsiglen);
 	DSA_SIG_free(sig);
 	sshbuf_free(b);
 	return ret;
@@ -121,10 +144,13 @@ ssh_dss_verify(const struct sshkey *key,
     const u_char *signature, size_t signaturelen,
     const u_char *data, size_t datalen, u_int compat)
 {
+	EVP_PKEY_CTX *sctx = NULL;
 	DSA_SIG *sig = NULL;
 	BIGNUM *sig_r = NULL, *sig_s = NULL;
 	u_char digest[SSH_DIGEST_MAX_LENGTH], *sigblob = NULL;
 	size_t len, dlen = ssh_digest_bytes(SSH_DIGEST_SHA1);
+	unsigned char *tsig = NULL;
+	size_t tsiglen = 0;
 	int ret = SSH_ERR_INTERNAL_ERROR;
 	struct sshbuf *b = NULL;
 	char *ktype = NULL;
@@ -176,12 +202,26 @@ ssh_dss_verify(const struct sshkey *key,
 	}
 	sig_r = sig_s = NULL; /* transferred */
 
+	if ((tsiglen = i2d_DSA_SIG(sig, &tsig)) <= 0) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+
 	/* sha1 the data */
 	if ((ret = ssh_digest_memory(SSH_DIGEST_SHA1, data, datalen,
 	    digest, sizeof(digest))) != 0)
 		goto out;
 
-	switch (DSA_do_verify(digest, dlen, sig, key->dsa)) {
+	if ((sctx = EVP_PKEY_CTX_new(key->dsa, NULL)) == NULL) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if (EVP_PKEY_verify_init(sctx) <= 0) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+
+	switch (EVP_PKEY_verify(sctx, tsig, tsiglen, digest, dlen)) {
 	case 1:
 		ret = 0;
 		break;
@@ -194,6 +234,8 @@ ssh_dss_verify(const struct sshkey *key,
 	}
 
  out:
+	EVP_PKEY_CTX_free(sctx);
+	freezero(tsig, tsiglen);
 	explicit_bzero(digest, sizeof(digest));
 	DSA_SIG_free(sig);
 	BN_clear_free(sig_r);
diff --git a/ssh-ecdsa-sk.c b/ssh-ecdsa-sk.c
index c6927ec..63d49c0 100644
--- a/ssh-ecdsa-sk.c
+++ b/ssh-ecdsa-sk.c
@@ -144,6 +144,7 @@ ssh_ecdsa_sk_verify(const struct sshkey *key,
     const u_char *data, size_t datalen, u_int compat,
     struct sshkey_sig_details **detailsp)
 {
+	EVP_PKEY_CTX *sctx = NULL;
 	ECDSA_SIG *sig = NULL;
 	BIGNUM *sig_r = NULL, *sig_s = NULL;
 	u_char sig_flags;
@@ -154,6 +155,8 @@ ssh_ecdsa_sk_verify(const struct sshkey *key,
 	struct sshbuf *webauthn_wrapper = NULL, *webauthn_exts = NULL;
 	char *ktype = NULL, *webauthn_origin = NULL;
 	struct sshkey_sig_details *details = NULL;
+	unsigned char *tsig = NULL;
+	size_t tsiglen = 0;
 #ifdef DEBUG_SK
 	char *tmp = NULL;
 #endif
@@ -241,6 +244,11 @@ ssh_ecdsa_sk_verify(const struct sshkey *key,
 	}
 	sig_r = sig_s = NULL; /* transferred */
 
+	if ((tsiglen = i2d_ECDSA_SIG(sig, &tsig)) <= 0) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+
 	/* Reconstruct data that was supposedly signed */
 	if ((original_signed = sshbuf_new()) == NULL) {
 		ret = SSH_ERR_ALLOC_FAIL;
@@ -285,7 +293,15 @@ ssh_ecdsa_sk_verify(const struct sshkey *key,
 #endif
 
 	/* Verify it */
-	switch (ECDSA_do_verify(sighash, sizeof(sighash), sig, key->ecdsa)) {
+	if ((sctx = EVP_PKEY_CTX_new(key->ecdsa, NULL)) == NULL) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if (EVP_PKEY_verify_init(sctx) <= 0) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	switch (EVP_PKEY_verify(sctx, tsig, tsiglen, sighash, sizeof(sighash))) {
 	case 1:
 		ret = 0;
 		break;
@@ -302,6 +318,8 @@ ssh_ecdsa_sk_verify(const struct sshkey *key,
 		details = NULL;
 	}
  out:
+	EVP_PKEY_CTX_free(sctx);
+	freezero(tsig, tsiglen);
 	explicit_bzero(&sig_flags, sizeof(sig_flags));
 	explicit_bzero(&sig_counter, sizeof(sig_counter));
 	explicit_bzero(msghash, sizeof(msghash));
diff --git a/ssh-ecdsa.c b/ssh-ecdsa.c
index 599c719..835a010 100644
--- a/ssh-ecdsa.c
+++ b/ssh-ecdsa.c
@@ -50,11 +50,15 @@ int
 ssh_ecdsa_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
     const u_char *data, size_t datalen, u_int compat)
 {
+	EVP_PKEY_CTX *sctx = NULL;
 	ECDSA_SIG *sig = NULL;
 	const BIGNUM *sig_r, *sig_s;
 	int hash_alg;
 	u_char digest[SSH_DIGEST_MAX_LENGTH];
 	size_t len, dlen;
+	const unsigned char *psig;
+	unsigned char *tsig = NULL;
+	size_t tsiglen = 0;
 	struct sshbuf *b = NULL, *bb = NULL;
 	int ret = SSH_ERR_INTERNAL_ERROR;
 
@@ -74,7 +78,24 @@ ssh_ecdsa_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
 	    digest, sizeof(digest))) != 0)
 		goto out;
 
-	if ((sig = ECDSA_do_sign(digest, dlen, key->ecdsa)) == NULL) {
+	if ((sctx = EVP_PKEY_CTX_new(key->ecdsa, NULL)) == NULL) {
+		ret =  SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if (EVP_PKEY_sign_init(sctx) <= 0 ||
+	    EVP_PKEY_sign(sctx, NULL, &tsiglen, digest, dlen) <= 0) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if ((psig = tsig = malloc(tsiglen)) == NULL) {
+		ret = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	if (EVP_PKEY_sign(sctx, tsig, &tsiglen, digest, dlen) <= 0) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if (d2i_ECDSA_SIG(&sig, &psig, tsiglen) == NULL) {
 		ret = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
 	}
@@ -103,6 +124,8 @@ ssh_ecdsa_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
 	ret = 0;
  out:
 	explicit_bzero(digest, sizeof(digest));
+	EVP_PKEY_CTX_free(sctx);
+	freezero(tsig, tsiglen);
 	sshbuf_free(b);
 	sshbuf_free(bb);
 	ECDSA_SIG_free(sig);
@@ -115,11 +138,14 @@ ssh_ecdsa_verify(const struct sshkey *key,
     const u_char *signature, size_t signaturelen,
     const u_char *data, size_t datalen, u_int compat)
 {
+	EVP_PKEY_CTX *sctx = NULL;
 	ECDSA_SIG *sig = NULL;
 	BIGNUM *sig_r = NULL, *sig_s = NULL;
 	int hash_alg;
 	u_char digest[SSH_DIGEST_MAX_LENGTH];
 	size_t dlen;
+	unsigned char *tsig = NULL;
+	size_t tsiglen = 0;
 	int ret = SSH_ERR_INTERNAL_ERROR;
 	struct sshbuf *b = NULL, *sigbuf = NULL;
 	char *ktype = NULL;
@@ -170,11 +196,23 @@ ssh_ecdsa_verify(const struct sshkey *key,
 		ret = SSH_ERR_UNEXPECTED_TRAILING_DATA;
 		goto out;
 	}
+	if ((tsiglen = i2d_ECDSA_SIG(sig, &tsig)) <= 0) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
 	if ((ret = ssh_digest_memory(hash_alg, data, datalen,
 	    digest, sizeof(digest))) != 0)
 		goto out;
 
-	switch (ECDSA_do_verify(digest, dlen, sig, key->ecdsa)) {
+	if ((sctx = EVP_PKEY_CTX_new(key->ecdsa, NULL)) == NULL) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if (EVP_PKEY_verify_init(sctx) <= 0) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	switch (EVP_PKEY_verify(sctx, tsig, tsiglen, digest, dlen)) {
 	case 1:
 		ret = 0;
 		break;
@@ -187,6 +225,8 @@ ssh_ecdsa_verify(const struct sshkey *key,
 	}
 
  out:
+	EVP_PKEY_CTX_free(sctx);
+	freezero(tsig, tsiglen);
 	explicit_bzero(digest, sizeof(digest));
 	sshbuf_free(sigbuf);
 	sshbuf_free(b);
diff --git a/ssh-keygen.c b/ssh-keygen.c
index d62fab3..b46c3f1 100644
--- a/ssh-keygen.c
+++ b/ssh-keygen.c
@@ -376,17 +376,17 @@ do_convert_to_pkcs8(struct sshkey *k)
 {
 	switch (sshkey_type_plain(k->type)) {
 	case KEY_RSA:
-		if (!PEM_write_RSA_PUBKEY(stdout, k->rsa))
-			fatal("PEM_write_RSA_PUBKEY failed");
+		if (!PEM_write_PUBKEY(stdout, k->rsa))
+			fatal("PEM_write_PUBKEY failed");
 		break;
 	case KEY_DSA:
-		if (!PEM_write_DSA_PUBKEY(stdout, k->dsa))
-			fatal("PEM_write_DSA_PUBKEY failed");
+		if (!PEM_write_PUBKEY(stdout, k->dsa))
+			fatal("PEM_write_PUBKEY failed");
 		break;
 #ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA:
-		if (!PEM_write_EC_PUBKEY(stdout, k->ecdsa))
-			fatal("PEM_write_EC_PUBKEY failed");
+		if (!PEM_write_PUBKEY(stdout, k->ecdsa))
+			fatal("PEM_write_PUBKEY failed");
 		break;
 #endif
 	default:
@@ -398,19 +398,31 @@ do_convert_to_pkcs8(struct sshkey *k)
 static void
 do_convert_to_pem(struct sshkey *k)
 {
+	OSSL_ENCODER_CTX *octx;
 	switch (sshkey_type_plain(k->type)) {
 	case KEY_RSA:
-		if (!PEM_write_RSAPublicKey(stdout, k->rsa))
-			fatal("PEM_write_RSAPublicKey failed");
+		if ((octx = OSSL_ENCODER_CTX_new_for_pkey(k->rsa,
+		    OSSL_KEYMGMT_SELECT_PUBLIC_KEY, "PEM", "type-specific",
+		    NULL)) == NULL)
+			fatal("OSSL_ENCODER_CTX_new_for_pkey failed");
+		if (OSSL_ENCODER_CTX_get_num_encoders(octx) == 0) {
+			OSSL_ENCODER_CTX_free(octx);
+			fatal("No encoders found");
+		}
+		if (OSSL_ENCODER_to_fp(octx, stdout) == 0) {
+			OSSL_ENCODER_CTX_free(octx);
+			fatal("OSSL_ENCODER_to_fp failed");
+		}
+		OSSL_ENCODER_CTX_free(octx);
 		break;
 	case KEY_DSA:
-		if (!PEM_write_DSA_PUBKEY(stdout, k->dsa))
-			fatal("PEM_write_DSA_PUBKEY failed");
+		if (!PEM_write_PUBKEY(stdout, k->dsa))
+			fatal("PEM_write_PUBKEY failed");
 		break;
 #ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA:
-		if (!PEM_write_EC_PUBKEY(stdout, k->ecdsa))
-			fatal("PEM_write_EC_PUBKEY failed");
+		if (!PEM_write_PUBKEY(stdout, k->ecdsa))
+			fatal("PEM_write_PUBKEY failed");
 		break;
 #endif
 	default:
@@ -480,10 +492,14 @@ do_convert_private_ssh2(struct sshbuf *b)
 	u_int magic, i1, i2, i3, i4;
 	size_t slen;
 	u_long e;
+	OSSL_PARAM_BLD *bld = NULL;
+	OSSL_PARAM *params = NULL;
+	EVP_PKEY_CTX *pctx = NULL;
 	BIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL;
 	BIGNUM *dsa_pub_key = NULL, *dsa_priv_key = NULL;
 	BIGNUM *rsa_n = NULL, *rsa_e = NULL, *rsa_d = NULL;
 	BIGNUM *rsa_p = NULL, *rsa_q = NULL, *rsa_iqmp = NULL;
+	BIGNUM *rsa_dmp1 = NULL, *rsa_dmq1 = NULL;
 
 	if ((r = sshbuf_get_u32(b, &magic)) != 0)
 		fatal_fr(r, "parse magic");
@@ -534,12 +550,36 @@ do_convert_private_ssh2(struct sshbuf *b)
 		buffer_get_bignum_bits(b, dsa_q);
 		buffer_get_bignum_bits(b, dsa_pub_key);
 		buffer_get_bignum_bits(b, dsa_priv_key);
-		if (!DSA_set0_pqg(key->dsa, dsa_p, dsa_q, dsa_g))
-			fatal_f("DSA_set0_pqg failed");
-		dsa_p = dsa_q = dsa_g = NULL; /* transferred */
-		if (!DSA_set0_key(key->dsa, dsa_pub_key, dsa_priv_key))
-			fatal_f("DSA_set0_key failed");
-		dsa_pub_key = dsa_priv_key = NULL; /* transferred */
+		if ((bld = OSSL_PARAM_BLD_new()) == NULL)
+			fatal_f("OSSL_PARAM_BLD_new");
+		if (OSSL_PARAM_BLD_push_BN(bld,
+		    OSSL_PKEY_PARAM_FFC_P, dsa_p) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+		    OSSL_PKEY_PARAM_FFC_Q, dsa_q) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+		    OSSL_PKEY_PARAM_FFC_G, dsa_g) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+		    OSSL_PKEY_PARAM_PUB_KEY, dsa_pub_key) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+		    OSSL_PKEY_PARAM_PRIV_KEY, dsa_priv_key) == 0)
+			fatal_f("OSSL_PARAM_BLD_push_BN");
+		if ((params = OSSL_PARAM_BLD_to_param(bld)) == NULL)
+			fatal_f("OSSL_PARAM_BLD_to_param");
+		if ((pctx = EVP_PKEY_CTX_new_from_name(
+		    NULL, "DSA", NULL)) == NULL)
+			fatal_f("EVP_PKEY_CTX_new_from_name");
+		if (EVP_PKEY_fromdata_init(pctx) <= 0 ||
+		    EVP_PKEY_fromdata(pctx, &key->dsa,
+		    EVP_PKEY_KEYPAIR, params) <= 0)
+			fatal_f("EVP_PKEY_fromdata");
+		EVP_PKEY_CTX_free(pctx);
+		OSSL_PARAM_free(params);
+		OSSL_PARAM_BLD_free(bld);
+		BN_clear_free(dsa_priv_key);
+		BN_clear_free(dsa_pub_key);
+		BN_clear_free(dsa_q);
+		BN_clear_free(dsa_g);
+		BN_clear_free(dsa_p);
 		break;
 	case KEY_RSA:
 		if ((r = sshbuf_get_u8(b, &e1)) != 0 ||
@@ -574,15 +614,49 @@ do_convert_private_ssh2(struct sshbuf *b)
 		buffer_get_bignum_bits(b, rsa_iqmp);
 		buffer_get_bignum_bits(b, rsa_q);
 		buffer_get_bignum_bits(b, rsa_p);
-		if (!RSA_set0_key(key->rsa, rsa_n, rsa_e, rsa_d))
-			fatal_f("RSA_set0_key failed");
-		rsa_n = rsa_e = rsa_d = NULL; /* transferred */
-		if (!RSA_set0_factors(key->rsa, rsa_p, rsa_q))
-			fatal_f("RSA_set0_factors failed");
-		rsa_p = rsa_q = NULL; /* transferred */
-		if ((r = ssh_rsa_complete_crt_parameters(key, rsa_iqmp)) != 0)
+		if ((r = ssh_rsa_complete_crt_parameters(rsa_p, rsa_q, rsa_d,
+		    &rsa_dmp1, &rsa_dmq1)) != 0)
 			fatal_fr(r, "generate RSA parameters");
+		if ((bld = OSSL_PARAM_BLD_new()) == NULL)
+			fatal_f("OSSL_PARAM_BLD_new");
+		if (OSSL_PARAM_BLD_push_BN(bld,
+		    OSSL_PKEY_PARAM_RSA_E, rsa_e) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+		    OSSL_PKEY_PARAM_RSA_D, rsa_d) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+		    OSSL_PKEY_PARAM_RSA_N, rsa_n) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+		    OSSL_PKEY_PARAM_RSA_COEFFICIENT1, rsa_iqmp) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+		    OSSL_PKEY_PARAM_RSA_FACTOR1, rsa_p) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+		    OSSL_PKEY_PARAM_RSA_FACTOR2, rsa_q) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+		    OSSL_PKEY_PARAM_RSA_EXPONENT1, rsa_dmp1) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+		    OSSL_PKEY_PARAM_RSA_EXPONENT2, rsa_dmq1) == 0)
+			fatal_f("OSSL_PARAM_BLD_push_BN");
+		if ((params = OSSL_PARAM_BLD_to_param(bld)) == NULL)
+			fatal_f("OSSL_PARAM_BLD_to_param");
+		if ((pctx = EVP_PKEY_CTX_new_from_name(
+		    NULL, "RSA", NULL)) == NULL)
+			fatal_f("EVP_PKEY_CTX_new_from_name");
+		if (EVP_PKEY_fromdata_init(pctx) <= 0 ||
+		    EVP_PKEY_fromdata(pctx, &key->rsa,
+		    EVP_PKEY_KEYPAIR, params) <= 0)
+			fatal_f("EVP_PKEY_fromdata");
+
+		EVP_PKEY_CTX_free(pctx);
+		OSSL_PARAM_free(params);
+		OSSL_PARAM_BLD_free(bld);
+		BN_clear_free(rsa_dmq1);
+		BN_clear_free(rsa_dmp1);
 		BN_clear_free(rsa_iqmp);
+		BN_clear_free(rsa_q);
+		BN_clear_free(rsa_p);
+		BN_clear_free(rsa_d);
+		BN_clear_free(rsa_n);
+		BN_clear_free(rsa_e);
 		break;
 	}
 	rlen = sshbuf_len(b);
@@ -698,20 +772,20 @@ do_convert_from_pkcs8(struct sshkey **k, int *private)
 		if ((*k = sshkey_new(KEY_UNSPEC)) == NULL)
 			fatal("sshkey_new failed");
 		(*k)->type = KEY_RSA;
-		(*k)->rsa = EVP_PKEY_get1_RSA(pubkey);
+		(*k)->rsa = pubkey;
 		break;
 	case EVP_PKEY_DSA:
 		if ((*k = sshkey_new(KEY_UNSPEC)) == NULL)
 			fatal("sshkey_new failed");
 		(*k)->type = KEY_DSA;
-		(*k)->dsa = EVP_PKEY_get1_DSA(pubkey);
+		(*k)->dsa = pubkey;
 		break;
 #ifdef OPENSSL_HAS_ECC
 	case EVP_PKEY_EC:
 		if ((*k = sshkey_new(KEY_UNSPEC)) == NULL)
 			fatal("sshkey_new failed");
 		(*k)->type = KEY_ECDSA;
-		(*k)->ecdsa = EVP_PKEY_get1_EC_KEY(pubkey);
+		(*k)->ecdsa = pubkey;
 		(*k)->ecdsa_nid = sshkey_ecdsa_key_to_nid((*k)->ecdsa);
 		break;
 #endif
@@ -719,7 +793,6 @@ do_convert_from_pkcs8(struct sshkey **k, int *private)
 		fatal_f("unsupported pubkey type %d",
 		    EVP_PKEY_base_id(pubkey));
 	}
-	EVP_PKEY_free(pubkey);
 	return;
 }
 
@@ -727,19 +800,33 @@ static void
 do_convert_from_pem(struct sshkey **k, int *private)
 {
 	FILE *fp;
-	RSA *rsa;
+	OSSL_DECODER_CTX *octx;
+	EVP_PKEY *rsa = NULL;
 
 	if ((fp = fopen(identity_file, "r")) == NULL)
 		fatal("%s: %s: %s", __progname, identity_file, strerror(errno));
-	if ((rsa = PEM_read_RSAPublicKey(fp, NULL, NULL, NULL)) != NULL) {
-		if ((*k = sshkey_new(KEY_UNSPEC)) == NULL)
-			fatal("sshkey_new failed");
-		(*k)->type = KEY_RSA;
-		(*k)->rsa = rsa;
+	if ((octx = OSSL_DECODER_CTX_new_for_pkey(&rsa, "PEM", "type-specific",
+	    "RSA", OSSL_KEYMGMT_SELECT_PUBLIC_KEY, NULL, NULL)) == NULL) {
 		fclose(fp);
-		return;
+		fatal("OSSL_DECODER_CTX_new_for_pkey failed");
+	}
+	if (OSSL_DECODER_CTX_get_num_decoders(octx) == 0) {
+		OSSL_DECODER_CTX_free(octx);
+		fclose(fp);
+		fatal("No decoders found");
+	}
+	if (OSSL_DECODER_from_fp(octx, fp) == 0) {
+		OSSL_DECODER_CTX_free(octx);
+		fclose(fp);
+		fatal("unrecognised raw private key format");
 	}
-	fatal_f("unrecognised raw private key format");
+	OSSL_DECODER_CTX_free(octx);
+	fclose(fp);
+
+	if ((*k = sshkey_new(KEY_UNSPEC)) == NULL)
+		fatal("sshkey_new failed");
+	(*k)->type = KEY_RSA;
+	(*k)->rsa = rsa;
 }
 
 static void
@@ -747,6 +834,7 @@ do_convert_from(struct passwd *pw)
 {
 	struct sshkey *k = NULL;
 	int r, private = 0, ok = 0;
+	OSSL_ENCODER_CTX *octx = NULL;
 	struct stat st;
 
 	if (!have_identity)
@@ -776,22 +864,38 @@ do_convert_from(struct passwd *pw)
 	} else {
 		switch (k->type) {
 		case KEY_DSA:
-			ok = PEM_write_DSAPrivateKey(stdout, k->dsa, NULL,
-			    NULL, 0, NULL, NULL);
+			if ((octx = OSSL_ENCODER_CTX_new_for_pkey(k->dsa,
+			    OSSL_KEYMGMT_SELECT_PRIVATE_KEY, "PEM", "type-specific",
+			    NULL)) == NULL)
+				fatal("OSSL_ENCODER_CTX_new_for_pkey failed");
 			break;
 #ifdef OPENSSL_HAS_ECC
 		case KEY_ECDSA:
-			ok = PEM_write_ECPrivateKey(stdout, k->ecdsa, NULL,
-			    NULL, 0, NULL, NULL);
+			if ((octx = OSSL_ENCODER_CTX_new_for_pkey(k->ecdsa,
+			    OSSL_KEYMGMT_SELECT_PRIVATE_KEY, "PEM", "type-specific",
+			    NULL)) == NULL)
+				fatal("OSSL_ENCODER_CTX_new_for_pkey failed");
 			break;
 #endif
 		case KEY_RSA:
-			ok = PEM_write_RSAPrivateKey(stdout, k->rsa, NULL,
-			    NULL, 0, NULL, NULL);
+			if ((octx = OSSL_ENCODER_CTX_new_for_pkey(k->rsa,
+			    OSSL_KEYMGMT_SELECT_PRIVATE_KEY, "PEM", "type-specific",
+			    NULL)) == NULL)
+				fatal("OSSL_ENCODER_CTX_new_for_pkey failed");
 			break;
 		default:
 			fatal_f("unsupported key type %s", sshkey_type(k));
 		}
+		if (OSSL_ENCODER_CTX_get_num_encoders(octx) == 0) {
+			OSSL_ENCODER_CTX_free(octx);
+			fatal("No encoders found");
+		}
+		if (OSSL_ENCODER_to_fp(octx, stdout) == 0) {
+			OSSL_ENCODER_CTX_free(octx);
+			fatal("OSSL_ENCODER_to_fp failed");
+		}
+		OSSL_ENCODER_CTX_free(octx);
+		ok = 1;
 	}
 
 	if (!ok)
diff --git a/ssh-pkcs11-client.c b/ssh-pkcs11-client.c
index cfd833d..6d6d515 100644
--- a/ssh-pkcs11-client.c
+++ b/ssh-pkcs11-client.c
@@ -131,8 +131,10 @@ rsa_encrypt(int flen, const u_char *from, u_char *to, RSA *rsa, int padding)
 		goto fail;
 	}
 	key->type = KEY_RSA;
-	RSA_up_ref(rsa);
-	key->rsa = rsa;
+	if ((key->rsa = EVP_PKEY_new()) == NULL)
+		fatal_f("EVP_PKEY_new failed");
+	if (EVP_PKEY_set1_RSA(key->rsa, rsa) == 0)
+		fatal_f("EVP_PKEY_set1_RSA failed");
 	if ((r = sshkey_to_blob(key, &blob, &blen)) != 0) {
 		error_fr(r, "encode key");
 		goto fail;
@@ -174,23 +176,23 @@ ecdsa_do_sign(const unsigned char *dgst, int dgst_len, const BIGNUM *inv,
 	const u_char *cp;
 	u_char *blob = NULL, *signature = NULL;
 	size_t blen, slen = 0;
-	int r, nid;
-
-	nid = sshkey_ecdsa_key_to_nid(ec);
-	if (nid < 0) {
-		error_f("couldn't get curve nid");
-		goto fail;
-	}
+	int r;
 
 	key = sshkey_new(KEY_UNSPEC);
 	if (key == NULL) {
 		error_f("sshkey_new failed");
 		goto fail;
 	}
-	key->ecdsa = ec;
-	key->ecdsa_nid = nid;
 	key->type = KEY_ECDSA;
-	EC_KEY_up_ref(ec);
+	if ((key->ecdsa = EVP_PKEY_new()) == NULL)
+		fatal_f("EVP_PKEY_new failed");
+	if (EVP_PKEY_set1_EC_KEY(key->ecdsa, ec) == 0)
+		fatal_f("EVP_PKEY_set1_EC_KEY failed");
+	key->ecdsa_nid = sshkey_ecdsa_key_to_nid(key->ecdsa);
+	if (key->ecdsa_nid < 0) {
+		error_f("couldn't get curve nid");
+		goto fail;
+	}
 
 	if ((r = sshkey_to_blob(key, &blob, &blen)) != 0) {
 		error_fr(r, "encode key");
@@ -231,11 +233,15 @@ static EC_KEY_METHOD	*helper_ecdsa;
 static void
 wrap_key(struct sshkey *k)
 {
-	if (k->type == KEY_RSA)
-		RSA_set_method(k->rsa, helper_rsa);
+	if (k->type == KEY_RSA) {
+		RSA *rsa = EVP_PKEY_get0_RSA(k->rsa);
+		RSA_set_method(rsa, helper_rsa);
+	}
 #if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)
-	else if (k->type == KEY_ECDSA)
-		EC_KEY_set_method(k->ecdsa, helper_ecdsa);
+	else if (k->type == KEY_ECDSA) {
+		EC_KEY *ecdsa = EVP_PKEY_get0_EC_KEY(k->ecdsa);
+		EC_KEY_set_method(ecdsa, helper_ecdsa);
+	}
 #endif /* OPENSSL_HAS_ECC && HAVE_EC_KEY_METHOD_NEW */
 	else
 		fatal_f("unknown key type");
diff --git a/ssh-pkcs11-helper.c b/ssh-pkcs11-helper.c
index 5c3eaae..b8e7805 100644
--- a/ssh-pkcs11-helper.c
+++ b/ssh-pkcs11-helper.c
@@ -45,6 +45,7 @@
 #ifdef ENABLE_PKCS11
 
 #ifdef WITH_OPENSSL
+#include <openssl/rsa.h>
 
 /* borrows code from sftp-server and ssh-agent */
 
@@ -201,30 +202,39 @@ process_sign(void)
 	else {
 		if ((found = lookup_key(key)) != NULL) {
 #ifdef WITH_OPENSSL
-			int ret;
+			EVP_PKEY_CTX *ctx;
 
 			if (key->type == KEY_RSA) {
-				slen = RSA_size(key->rsa);
+				if ((ctx = EVP_PKEY_CTX_new(found->rsa, NULL))
+				    == NULL)
+					fatal_f("EVP_PKEY_CTX_new failed");
+				if (EVP_PKEY_sign_init(ctx) <= 0 ||
+				    EVP_PKEY_CTX_set_rsa_padding(ctx,
+				    RSA_PKCS1_PADDING) <= 0 ||
+				    EVP_PKEY_sign(ctx, NULL, &slen,
+				    data, dlen) <= 0)
+					fatal_f("Failed configuring context");
 				signature = xmalloc(slen);
-				ret = RSA_private_encrypt(dlen, data, signature,
-				    found->rsa, RSA_PKCS1_PADDING);
-				if (ret != -1) {
-					slen = ret;
-					ok = 0;
-				}
+				if (EVP_PKEY_sign(ctx, signature, &slen,
+				    data, dlen) <= 0)
+					fatal_f("EVP_PKEY_sign failed");
+				EVP_PKEY_CTX_free(ctx);
+				ok = 0;
 #ifdef OPENSSL_HAS_ECC
 			} else if (key->type == KEY_ECDSA) {
-				u_int xslen = ECDSA_size(key->ecdsa);
-
-				signature = xmalloc(xslen);
-				/* "The parameter type is ignored." */
-				ret = ECDSA_sign(-1, data, dlen, signature,
-				    &xslen, found->ecdsa);
-				if (ret != 0)
-					ok = 0;
-				else
-					error_f("ECDSA_sign returned %d", ret);
-				slen = xslen;
+				if ((ctx = EVP_PKEY_CTX_new(found->ecdsa,
+				    NULL)) == NULL)
+					fatal_f("EVP_PKEY_CTX_new failed");
+				if (EVP_PKEY_sign_init(ctx) <= 0 ||
+				    EVP_PKEY_sign(ctx, NULL, &slen,
+				    data, dlen) <= 0)
+					fatal_f("Failed configuring context");
+				signature = xmalloc(slen);
+				if (EVP_PKEY_sign(ctx, signature, &slen,
+				    data, dlen) <= 0)
+					fatal_f("EVP_PKEY_sign failed");
+				EVP_PKEY_CTX_free(ctx);
+				ok = 0;
 #endif /* OPENSSL_HAS_ECC */
 			} else
 				error_f("don't know how to sign with key "
diff --git a/ssh-pkcs11.c b/ssh-pkcs11.c
index b2e2b32..d6ac6d7 100644
--- a/ssh-pkcs11.c
+++ b/ssh-pkcs11.c
@@ -484,9 +484,10 @@ pkcs11_rsa_start_wrapper(void)
 /* redirect private key operations for rsa key to pkcs11 token */
 static int
 pkcs11_rsa_wrap(struct pkcs11_provider *provider, CK_ULONG slotidx,
-    CK_ATTRIBUTE *keyid_attrib, RSA *rsa)
+    CK_ATTRIBUTE *keyid_attrib, EVP_PKEY *pkey)
 {
 	struct pkcs11_key	*k11;
+	RSA			*rsa;
 
 	if (pkcs11_rsa_start_wrapper() == -1)
 		return (-1);
@@ -502,6 +503,7 @@ pkcs11_rsa_wrap(struct pkcs11_provider *provider, CK_ULONG slotidx,
 		memcpy(k11->keyid, keyid_attrib->pValue, k11->keyid_len);
 	}
 
+	rsa = EVP_PKEY_get0_RSA(pkey);
 	RSA_set_method(rsa, rsa_method);
 	RSA_set_ex_data(rsa, rsa_idx, k11);
 	return (0);
@@ -598,9 +600,10 @@ pkcs11_ecdsa_start_wrapper(void)
 
 static int
 pkcs11_ecdsa_wrap(struct pkcs11_provider *provider, CK_ULONG slotidx,
-    CK_ATTRIBUTE *keyid_attrib, EC_KEY *ec)
+    CK_ATTRIBUTE *keyid_attrib, EVP_PKEY *pkey)
 {
 	struct pkcs11_key	*k11;
+	EC_KEY			*ec;
 
 	if (pkcs11_ecdsa_start_wrapper() == -1)
 		return (-1);
@@ -615,6 +618,8 @@ pkcs11_ecdsa_wrap(struct pkcs11_provider *provider, CK_ULONG slotidx,
 		k11->keyid = xmalloc(k11->keyid_len);
 		memcpy(k11->keyid, keyid_attrib->pValue, k11->keyid_len);
 	}
+
+	ec = EVP_PKEY_get0_EC_KEY(pkey);
 	EC_KEY_set_method(ec, ec_key_method);
 	EC_KEY_set_ex_data(ec, ec_key_idx, k11);
 
@@ -705,7 +710,10 @@ pkcs11_fetch_ecdsa_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,
 	CK_FUNCTION_LIST	*f = NULL;
 	CK_RV			 rv;
 	ASN1_OCTET_STRING	*octet = NULL;
-	EC_KEY			*ec = NULL;
+	OSSL_PARAM_BLD		*bld = NULL;
+	OSSL_PARAM		*params = NULL;
+	EVP_PKEY_CTX		*pctx = NULL;
+	EVP_PKEY		*ec = NULL;
 	EC_GROUP		*group = NULL;
 	struct sshkey		*key = NULL;
 	const unsigned char	*attrp = NULL;
@@ -750,12 +758,6 @@ pkcs11_fetch_ecdsa_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,
 		goto fail;
 	}
 
-	ec = EC_KEY_new();
-	if (ec == NULL) {
-		error("EC_KEY_new failed");
-		goto fail;
-	}
-
 	attrp = key_attr[2].pValue;
 	group = d2i_ECPKParameters(NULL, &attrp, key_attr[2].ulValueLen);
 	if (group == NULL) {
@@ -763,11 +765,6 @@ pkcs11_fetch_ecdsa_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,
 		goto fail;
 	}
 
-	if (EC_KEY_set_group(ec, group) == 0) {
-		ossl_error("EC_KEY_set_group failed");
-		goto fail;
-	}
-
 	if (key_attr[1].ulValueLen <= 2) {
 		error("CKA_EC_POINT too small");
 		goto fail;
@@ -779,9 +776,28 @@ pkcs11_fetch_ecdsa_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,
 		ossl_error("d2i_ASN1_OCTET_STRING failed");
 		goto fail;
 	}
-	attrp = octet->data;
-	if (o2i_ECPublicKey(&ec, &attrp, octet->length) == NULL) {
-		ossl_error("o2i_ECPublicKey failed");
+
+	bld = OSSL_PARAM_BLD_new();
+	if (bld == NULL) {
+		ossl_error("OSSL_PARAM_BLD_new failed");
+		goto fail;
+	}
+	if (OSSL_PARAM_BLD_push_utf8_string(bld, OSSL_PKEY_PARAM_GROUP_NAME,
+	    OBJ_nid2sn(EC_GROUP_get_curve_name(group)), 0) == 0 ||
+	    OSSL_PARAM_BLD_push_octet_string(bld, OSSL_PKEY_PARAM_PUB_KEY,
+	    octet->data, octet->length) == 0) {
+		ossl_error("OSSL_PARAM_BLD_push_* failed");
+		goto fail;
+	}
+	params = OSSL_PARAM_BLD_to_param(bld);
+	if (params == NULL) {
+		ossl_error("OSSL_PARAM_BLD_to_param failed");
+		goto fail;
+	}
+	pctx = EVP_PKEY_CTX_new_from_name(NULL, "EC", NULL);
+	if (pctx == NULL || EVP_PKEY_fromdata_init(pctx) <= 0 ||
+	    EVP_PKEY_fromdata(pctx, &ec, EVP_PKEY_PUBLIC_KEY, params) <= 0) {
+		ossl_error("Failed creating pkey");
 		goto fail;
 	}
 
@@ -809,8 +825,10 @@ pkcs11_fetch_ecdsa_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,
 fail:
 	for (i = 0; i < 3; i++)
 		free(key_attr[i].pValue);
-	if (ec)
-		EC_KEY_free(ec);
+	EVP_PKEY_free(ec);
+	EVP_PKEY_CTX_free(pctx);
+	OSSL_PARAM_free(params);
+	OSSL_PARAM_BLD_free(bld);
 	if (group)
 		EC_GROUP_free(group);
 	if (octet)
@@ -828,8 +846,11 @@ pkcs11_fetch_rsa_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,
 	CK_SESSION_HANDLE	 session;
 	CK_FUNCTION_LIST	*f = NULL;
 	CK_RV			 rv;
-	RSA			*rsa = NULL;
-	BIGNUM			*rsa_n, *rsa_e;
+	OSSL_PARAM_BLD		*bld = NULL;
+	OSSL_PARAM		*params = NULL;
+	EVP_PKEY_CTX		*pctx = NULL;
+	EVP_PKEY		*rsa = NULL;
+	BIGNUM			*rsa_n = NULL, *rsa_e = NULL;
 	struct sshkey		*key = NULL;
 	int			 i;
 
@@ -871,21 +892,34 @@ pkcs11_fetch_rsa_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,
 		goto fail;
 	}
 
-	rsa = RSA_new();
-	if (rsa == NULL) {
-		error("RSA_new failed");
-		goto fail;
-	}
-
 	rsa_n = BN_bin2bn(key_attr[1].pValue, key_attr[1].ulValueLen, NULL);
 	rsa_e = BN_bin2bn(key_attr[2].pValue, key_attr[2].ulValueLen, NULL);
 	if (rsa_n == NULL || rsa_e == NULL) {
 		error("BN_bin2bn failed");
 		goto fail;
 	}
-	if (!RSA_set0_key(rsa, rsa_n, rsa_e, NULL))
-		fatal_f("set key");
-	rsa_n = rsa_e = NULL; /* transferred */
+
+	bld = OSSL_PARAM_BLD_new();
+	if (bld == NULL) {
+		error("OSSL_PARAM_BLD_new failed");
+		goto fail;
+	}
+	if (OSSL_PARAM_BLD_push_BN(bld,	OSSL_PKEY_PARAM_RSA_E, rsa_e) == 0 ||
+	    OSSL_PARAM_BLD_push_BN(bld,	OSSL_PKEY_PARAM_RSA_N, rsa_n) == 0) {
+		error("OSSL_PARAM_BLD_push_BN failed");
+		goto fail;
+	}
+	params = OSSL_PARAM_BLD_to_param(bld);
+	if (params == NULL) {
+		error("OSSL_PARAM_BLD_to_param failed");
+		goto fail;
+	}
+	pctx = EVP_PKEY_CTX_new_from_name(NULL, "RSA", NULL);
+	if (pctx == NULL || EVP_PKEY_fromdata_init(pctx) <= 0 ||
+	    EVP_PKEY_fromdata(pctx, &rsa, EVP_PKEY_PUBLIC_KEY, params) <= 0) {
+		error("Failed creating pkey");
+		goto fail;
+	}
 
 	if (pkcs11_rsa_wrap(p, slotidx, &key_attr[0], rsa))
 		goto fail;
@@ -904,7 +938,12 @@ pkcs11_fetch_rsa_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,
 fail:
 	for (i = 0; i < 3; i++)
 		free(key_attr[i].pValue);
-	RSA_free(rsa);
+	EVP_PKEY_free(rsa);
+	EVP_PKEY_CTX_free(pctx);
+	OSSL_PARAM_free(params);
+	OSSL_PARAM_BLD_free(bld);
+	BN_clear_free(rsa_e);
+	BN_clear_free(rsa_n);
 
 	return (key);
 }
@@ -919,11 +958,7 @@ pkcs11_fetch_x509_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,
 	CK_RV			 rv;
 	X509			*x509 = NULL;
 	X509_NAME		*x509_name = NULL;
-	EVP_PKEY		*evp;
-	RSA			*rsa = NULL;
-#ifdef OPENSSL_HAS_ECC
-	EC_KEY			*ec = NULL;
-#endif
+	EVP_PKEY		*evp = NULL;
 	struct sshkey		*key = NULL;
 	int			 i;
 #if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)
@@ -993,16 +1028,7 @@ pkcs11_fetch_x509_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,
 	}
 
 	if (EVP_PKEY_base_id(evp) == EVP_PKEY_RSA) {
-		if (EVP_PKEY_get0_RSA(evp) == NULL) {
-			error("invalid x509; no rsa key");
-			goto out;
-		}
-		if ((rsa = RSAPublicKey_dup(EVP_PKEY_get0_RSA(evp))) == NULL) {
-			error("RSAPublicKey_dup failed");
-			goto out;
-		}
-
-		if (pkcs11_rsa_wrap(p, slotidx, &cert_attr[0], rsa))
+		if (pkcs11_rsa_wrap(p, slotidx, &cert_attr[0], evp))
 			goto out;
 
 		key = sshkey_new(KEY_UNSPEC);
@@ -1011,28 +1037,19 @@ pkcs11_fetch_x509_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,
 			goto out;
 		}
 
-		key->rsa = rsa;
+		key->rsa = evp;
 		key->type = KEY_RSA;
 		key->flags |= SSHKEY_FLAG_EXT;
-		rsa = NULL;	/* now owned by key */
+		evp = NULL;	/* now owned by key */
 #if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)
 	} else if (EVP_PKEY_base_id(evp) == EVP_PKEY_EC) {
-		if (EVP_PKEY_get0_EC_KEY(evp) == NULL) {
-			error("invalid x509; no ec key");
-			goto out;
-		}
-		if ((ec = EC_KEY_dup(EVP_PKEY_get0_EC_KEY(evp))) == NULL) {
-			error("EC_KEY_dup failed");
-			goto out;
-		}
-
-		nid = sshkey_ecdsa_key_to_nid(ec);
+		nid = sshkey_ecdsa_key_to_nid(evp);
 		if (nid < 0) {
 			error("couldn't get curve nid");
 			goto out;
 		}
 
-		if (pkcs11_ecdsa_wrap(p, slotidx, &cert_attr[0], ec))
+		if (pkcs11_ecdsa_wrap(p, slotidx, &cert_attr[0], evp))
 			goto out;
 
 		key = sshkey_new(KEY_UNSPEC);
@@ -1041,11 +1058,11 @@ pkcs11_fetch_x509_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,
 			goto out;
 		}
 
-		key->ecdsa = ec;
+		key->ecdsa = evp;
 		key->ecdsa_nid = nid;
 		key->type = KEY_ECDSA;
 		key->flags |= SSHKEY_FLAG_EXT;
-		ec = NULL;	/* now owned by key */
+		evp = NULL;	/* now owned by key */
 #endif /* OPENSSL_HAS_ECC && HAVE_EC_KEY_METHOD_NEW */
 	} else {
 		error("unknown certificate key type");
@@ -1054,11 +1071,8 @@ pkcs11_fetch_x509_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,
  out:
 	for (i = 0; i < 3; i++)
 		free(cert_attr[i].pValue);
+	EVP_PKEY_free(evp);
 	X509_free(x509);
-	RSA_free(rsa);
-#ifdef OPENSSL_HAS_ECC
-	EC_KEY_free(ec);
-#endif
 	if (key == NULL) {
 		free(subject);
 		return -1;
diff --git a/ssh-rsa.c b/ssh-rsa.c
index 9b14f9a..55a40b5 100644
--- a/ssh-rsa.c
+++ b/ssh-rsa.c
@@ -37,8 +37,6 @@
 
 #include "openbsd-compat/openssl-compat.h"
 
-static int openssh_RSA_verify(int, u_char *, size_t, u_char *, size_t, RSA *);
-
 static const char *
 rsa_hash_alg_ident(int hash_alg)
 {
@@ -105,48 +103,39 @@ rsa_hash_alg_nid(int type)
 	}
 }
 
+//XXX(ossl3): rename to something more meaningful
 int
-ssh_rsa_complete_crt_parameters(struct sshkey *key, const BIGNUM *iqmp)
+ssh_rsa_complete_crt_parameters(const BIGNUM *p, const BIGNUM *q,
+    const BIGNUM *d, BIGNUM **dmp1, BIGNUM **dmq1)
 {
-	const BIGNUM *rsa_p, *rsa_q, *rsa_d;
 	BIGNUM *aux = NULL, *d_consttime = NULL;
-	BIGNUM *rsa_dmq1 = NULL, *rsa_dmp1 = NULL, *rsa_iqmp = NULL;
+	BIGNUM *rsa_dmq1 = NULL, *rsa_dmp1 = NULL;
 	BN_CTX *ctx = NULL;
 	int r;
 
-	if (key == NULL || key->rsa == NULL ||
-	    sshkey_type_plain(key->type) != KEY_RSA)
-		return SSH_ERR_INVALID_ARGUMENT;
-
-	RSA_get0_key(key->rsa, NULL, NULL, &rsa_d);
-	RSA_get0_factors(key->rsa, &rsa_p, &rsa_q);
-
 	if ((ctx = BN_CTX_new()) == NULL)
 		return SSH_ERR_ALLOC_FAIL;
 	if ((aux = BN_new()) == NULL ||
 	    (rsa_dmq1 = BN_new()) == NULL ||
 	    (rsa_dmp1 = BN_new()) == NULL)
 		return SSH_ERR_ALLOC_FAIL;
-	if ((d_consttime = BN_dup(rsa_d)) == NULL ||
-	    (rsa_iqmp = BN_dup(iqmp)) == NULL) {
+	if ((d_consttime = BN_dup(d)) == NULL) {
 		r = SSH_ERR_ALLOC_FAIL;
 		goto out;
 	}
 	BN_set_flags(aux, BN_FLG_CONSTTIME);
 	BN_set_flags(d_consttime, BN_FLG_CONSTTIME);
 
-	if ((BN_sub(aux, rsa_q, BN_value_one()) == 0) ||
+	if ((BN_sub(aux, q, BN_value_one()) == 0) ||
 	    (BN_mod(rsa_dmq1, d_consttime, aux, ctx) == 0) ||
-	    (BN_sub(aux, rsa_p, BN_value_one()) == 0) ||
+	    (BN_sub(aux, p, BN_value_one()) == 0) ||
 	    (BN_mod(rsa_dmp1, d_consttime, aux, ctx) == 0)) {
 		r = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
 	}
-	if (!RSA_set0_crt_params(key->rsa, rsa_dmp1, rsa_dmq1, rsa_iqmp)) {
-		r = SSH_ERR_LIBCRYPTO_ERROR;
-		goto out;
-	}
-	rsa_dmp1 = rsa_dmq1 = rsa_iqmp = NULL; /* transferred */
+	*dmp1 = rsa_dmp1;
+	*dmq1 = rsa_dmq1;
+	rsa_dmp1 = rsa_dmq1 = NULL; /* transferred */
 	/* success */
 	r = 0;
  out:
@@ -154,7 +143,6 @@ ssh_rsa_complete_crt_parameters(struct sshkey *key, const BIGNUM *iqmp)
 	BN_clear_free(d_consttime);
 	BN_clear_free(rsa_dmp1);
 	BN_clear_free(rsa_dmq1);
-	BN_clear_free(rsa_iqmp);
 	BN_CTX_free(ctx);
 	return r;
 }
@@ -164,11 +152,12 @@ int
 ssh_rsa_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
     const u_char *data, size_t datalen, const char *alg_ident)
 {
-	const BIGNUM *rsa_n;
+	EVP_PKEY_CTX *sctx = NULL;
+	const EVP_MD *evp_md = NULL;
 	u_char digest[SSH_DIGEST_MAX_LENGTH], *sig = NULL;
 	size_t slen = 0;
 	u_int dlen, len;
-	int nid, hash_alg, ret = SSH_ERR_INTERNAL_ERROR;
+	int hash_alg, ret = SSH_ERR_INTERNAL_ERROR;
 	struct sshbuf *b = NULL;
 
 	if (lenp != NULL)
@@ -183,38 +172,41 @@ ssh_rsa_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
 	if (key == NULL || key->rsa == NULL || hash_alg == -1 ||
 	    sshkey_type_plain(key->type) != KEY_RSA)
 		return SSH_ERR_INVALID_ARGUMENT;
-	RSA_get0_key(key->rsa, &rsa_n, NULL, NULL);
-	if (BN_num_bits(rsa_n) < SSH_RSA_MINIMUM_MODULUS_SIZE)
+	if (EVP_PKEY_bits(key->rsa) < SSH_RSA_MINIMUM_MODULUS_SIZE)
 		return SSH_ERR_KEY_LENGTH;
-	slen = RSA_size(key->rsa);
-	if (slen <= 0 || slen > SSHBUF_MAX_BIGNUM)
+	if (EVP_PKEY_size(key->rsa) > SSHBUF_MAX_BIGNUM)
 		return SSH_ERR_INVALID_ARGUMENT;
 
 	/* hash the data */
-	nid = rsa_hash_alg_nid(hash_alg);
+	evp_md = EVP_get_digestbynid(rsa_hash_alg_nid(hash_alg));
+	if (evp_md == NULL)
+		return SSH_ERR_INVALID_ARGUMENT;
 	if ((dlen = ssh_digest_bytes(hash_alg)) == 0)
 		return SSH_ERR_INTERNAL_ERROR;
 	if ((ret = ssh_digest_memory(hash_alg, data, datalen,
 	    digest, sizeof(digest))) != 0)
 		goto out;
 
-	if ((sig = malloc(slen)) == NULL) {
-		ret = SSH_ERR_ALLOC_FAIL;
+	if ((sctx = EVP_PKEY_CTX_new(key->rsa, NULL)) == NULL) {
+		ret =  SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
 	}
-
-	if (RSA_sign(nid, digest, dlen, sig, &len, key->rsa) != 1) {
+	if (EVP_PKEY_sign_init(sctx) <= 0 ||
+	    EVP_PKEY_CTX_set_rsa_padding(sctx, RSA_PKCS1_PADDING) <= 0 ||
+	    EVP_PKEY_CTX_set_signature_md(sctx, evp_md) <= 0 ||
+	    EVP_PKEY_sign(sctx, NULL, &slen, digest, dlen) <= 0) {
 		ret = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
 	}
-	if (len < slen) {
-		size_t diff = slen - len;
-		memmove(sig + diff, sig, len);
-		explicit_bzero(sig, diff);
-	} else if (len > slen) {
-		ret = SSH_ERR_INTERNAL_ERROR;
+	if ((sig = malloc(slen)) == NULL) {
+		ret = SSH_ERR_ALLOC_FAIL;
 		goto out;
 	}
+	if (EVP_PKEY_sign(sctx, sig, &slen, digest, dlen) <= 0) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+
 	/* encode signature */
 	if ((b = sshbuf_new()) == NULL) {
 		ret = SSH_ERR_ALLOC_FAIL;
@@ -235,6 +227,7 @@ ssh_rsa_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
 		*lenp = len;
 	ret = 0;
  out:
+	EVP_PKEY_CTX_free(sctx);
 	explicit_bzero(digest, sizeof(digest));
 	freezero(sig, slen);
 	sshbuf_free(b);
@@ -246,19 +239,19 @@ ssh_rsa_verify(const struct sshkey *key,
     const u_char *sig, size_t siglen, const u_char *data, size_t datalen,
     const char *alg)
 {
-	const BIGNUM *rsa_n;
+	EVP_PKEY_CTX *sctx = NULL;
+	const EVP_MD *evp_md = NULL;
 	char *sigtype = NULL;
 	int hash_alg, want_alg, ret = SSH_ERR_INTERNAL_ERROR;
-	size_t len = 0, diff, modlen, dlen;
+	size_t len = 0, dlen;
 	struct sshbuf *b = NULL;
-	u_char digest[SSH_DIGEST_MAX_LENGTH], *osigblob, *sigblob = NULL;
+	u_char digest[SSH_DIGEST_MAX_LENGTH], *sigblob = NULL;
 
 	if (key == NULL || key->rsa == NULL ||
 	    sshkey_type_plain(key->type) != KEY_RSA ||
 	    sig == NULL || siglen == 0)
 		return SSH_ERR_INVALID_ARGUMENT;
-	RSA_get0_key(key->rsa, &rsa_n, NULL, NULL);
-	if (BN_num_bits(rsa_n) < SSH_RSA_MINIMUM_MODULUS_SIZE)
+	if (EVP_PKEY_bits(key->rsa) < SSH_RSA_MINIMUM_MODULUS_SIZE)
 		return SSH_ERR_KEY_LENGTH;
 
 	if ((b = sshbuf_from(sig, siglen)) == NULL)
@@ -293,23 +286,6 @@ ssh_rsa_verify(const struct sshkey *key,
 		ret = SSH_ERR_UNEXPECTED_TRAILING_DATA;
 		goto out;
 	}
-	/* RSA_verify expects a signature of RSA_size */
-	modlen = RSA_size(key->rsa);
-	if (len > modlen) {
-		ret = SSH_ERR_KEY_BITS_MISMATCH;
-		goto out;
-	} else if (len < modlen) {
-		diff = modlen - len;
-		osigblob = sigblob;
-		if ((sigblob = realloc(sigblob, modlen)) == NULL) {
-			sigblob = osigblob; /* put it back for clear/free */
-			ret = SSH_ERR_ALLOC_FAIL;
-			goto out;
-		}
-		memmove(sigblob + diff, sigblob, len);
-		explicit_bzero(sigblob, diff);
-		len = modlen;
-	}
 	if ((dlen = ssh_digest_bytes(hash_alg)) == 0) {
 		ret = SSH_ERR_INTERNAL_ERROR;
 		goto out;
@@ -317,133 +293,38 @@ ssh_rsa_verify(const struct sshkey *key,
 	if ((ret = ssh_digest_memory(hash_alg, data, datalen,
 	    digest, sizeof(digest))) != 0)
 		goto out;
-
-	ret = openssh_RSA_verify(hash_alg, digest, dlen, sigblob, len,
-	    key->rsa);
- out:
-	freezero(sigblob, len);
-	free(sigtype);
-	sshbuf_free(b);
-	explicit_bzero(digest, sizeof(digest));
-	return ret;
-}
-
-/*
- * See:
- * http://www.rsasecurity.com/rsalabs/pkcs/pkcs-1/
- * ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1.asn
- */
-
-/*
- * id-sha1 OBJECT IDENTIFIER ::= { iso(1) identified-organization(3)
- *	oiw(14) secsig(3) algorithms(2) 26 }
- */
-static const u_char id_sha1[] = {
-	0x30, 0x21, /* type Sequence, length 0x21 (33) */
-	0x30, 0x09, /* type Sequence, length 0x09 */
-	0x06, 0x05, /* type OID, length 0x05 */
-	0x2b, 0x0e, 0x03, 0x02, 0x1a, /* id-sha1 OID */
-	0x05, 0x00, /* NULL */
-	0x04, 0x14  /* Octet string, length 0x14 (20), followed by sha1 hash */
-};
-
-/*
- * See http://csrc.nist.gov/groups/ST/crypto_apps_infra/csor/algorithms.html
- * id-sha256 OBJECT IDENTIFIER ::= { joint-iso-itu-t(2) country(16) us(840)
- *      organization(1) gov(101) csor(3) nistAlgorithm(4) hashAlgs(2)
- *      id-sha256(1) }
- */
-static const u_char id_sha256[] = {
-	0x30, 0x31, /* type Sequence, length 0x31 (49) */
-	0x30, 0x0d, /* type Sequence, length 0x0d (13) */
-	0x06, 0x09, /* type OID, length 0x09 */
-	0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, /* id-sha256 */
-	0x05, 0x00, /* NULL */
-	0x04, 0x20  /* Octet string, length 0x20 (32), followed by sha256 hash */
-};
-
-/*
- * See http://csrc.nist.gov/groups/ST/crypto_apps_infra/csor/algorithms.html
- * id-sha512 OBJECT IDENTIFIER ::= { joint-iso-itu-t(2) country(16) us(840)
- *      organization(1) gov(101) csor(3) nistAlgorithm(4) hashAlgs(2)
- *      id-sha256(3) }
- */
-static const u_char id_sha512[] = {
-	0x30, 0x51, /* type Sequence, length 0x51 (81) */
-	0x30, 0x0d, /* type Sequence, length 0x0d (13) */
-	0x06, 0x09, /* type OID, length 0x09 */
-	0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, /* id-sha512 */
-	0x05, 0x00, /* NULL */
-	0x04, 0x40  /* Octet string, length 0x40 (64), followed by sha512 hash */
-};
-
-static int
-rsa_hash_alg_oid(int hash_alg, const u_char **oidp, size_t *oidlenp)
-{
-	switch (hash_alg) {
-	case SSH_DIGEST_SHA1:
-		*oidp = id_sha1;
-		*oidlenp = sizeof(id_sha1);
-		break;
-	case SSH_DIGEST_SHA256:
-		*oidp = id_sha256;
-		*oidlenp = sizeof(id_sha256);
-		break;
-	case SSH_DIGEST_SHA512:
-		*oidp = id_sha512;
-		*oidlenp = sizeof(id_sha512);
-		break;
-	default:
-		return SSH_ERR_INVALID_ARGUMENT;
-	}
-	return 0;
-}
-
-static int
-openssh_RSA_verify(int hash_alg, u_char *hash, size_t hashlen,
-    u_char *sigbuf, size_t siglen, RSA *rsa)
-{
-	size_t rsasize = 0, oidlen = 0, hlen = 0;
-	int ret, len, oidmatch, hashmatch;
-	const u_char *oid = NULL;
-	u_char *decrypted = NULL;
-
-	if ((ret = rsa_hash_alg_oid(hash_alg, &oid, &oidlen)) != 0)
-		return ret;
-	ret = SSH_ERR_INTERNAL_ERROR;
-	hlen = ssh_digest_bytes(hash_alg);
-	if (hashlen != hlen) {
+	evp_md = EVP_get_digestbynid(rsa_hash_alg_nid(hash_alg));
+	if (evp_md == NULL) {
 		ret = SSH_ERR_INVALID_ARGUMENT;
-		goto done;
-	}
-	rsasize = RSA_size(rsa);
-	if (rsasize <= 0 || rsasize > SSHBUF_MAX_BIGNUM ||
-	    siglen == 0 || siglen > rsasize) {
-		ret = SSH_ERR_INVALID_ARGUMENT;
-		goto done;
-	}
-	if ((decrypted = malloc(rsasize)) == NULL) {
-		ret = SSH_ERR_ALLOC_FAIL;
-		goto done;
+		goto out;
 	}
-	if ((len = RSA_public_decrypt(siglen, sigbuf, decrypted, rsa,
-	    RSA_PKCS1_PADDING)) < 0) {
+	if ((sctx = EVP_PKEY_CTX_new(key->rsa, NULL)) == NULL) {
 		ret = SSH_ERR_LIBCRYPTO_ERROR;
-		goto done;
+		goto out;
 	}
-	if (len < 0 || (size_t)len != hlen + oidlen) {
-		ret = SSH_ERR_INVALID_FORMAT;
-		goto done;
+	if (EVP_PKEY_verify_init(sctx) <= 0 ||
+	    EVP_PKEY_CTX_set_rsa_padding(sctx, RSA_PKCS1_PADDING) <= 0 ||
+	    EVP_PKEY_CTX_set_signature_md(sctx, evp_md) <= 0) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
 	}
-	oidmatch = timingsafe_bcmp(decrypted, oid, oidlen) == 0;
-	hashmatch = timingsafe_bcmp(decrypted + oidlen, hash, hlen) == 0;
-	if (!oidmatch || !hashmatch) {
+	switch (EVP_PKEY_verify(sctx, sigblob, len, digest, dlen)) {
+	case 1:
+		ret = 0;
+		break;
+	case 0:
 		ret = SSH_ERR_SIGNATURE_INVALID;
-		goto done;
+		break;
+	default:
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		break;
 	}
-	ret = 0;
-done:
-	freezero(decrypted, rsasize);
+ out:
+	EVP_PKEY_CTX_free(sctx);
+	freezero(sigblob, len);
+	free(sigtype);
+	sshbuf_free(b);
+	explicit_bzero(digest, sizeof(digest));
 	return ret;
 }
 #endif /* WITH_OPENSSL */
diff --git a/sshbuf-getput-crypto.c b/sshbuf-getput-crypto.c
index 2e61d3b..99dc90a 100644
--- a/sshbuf-getput-crypto.c
+++ b/sshbuf-getput-crypto.c
@@ -25,6 +25,7 @@
 
 #ifdef WITH_OPENSSL
 #include <openssl/bn.h>
+#include <openssl/evp.h>
 #ifdef OPENSSL_HAS_ECC
 # include <openssl/ec.h>
 #endif /* OPENSSL_HAS_ECC */
@@ -32,6 +33,8 @@
 #include "ssherr.h"
 #include "sshbuf.h"
 
+#include "openbsd-compat/openssl-compat.h"
+
 int
 sshbuf_get_bignum2(struct sshbuf *buf, BIGNUM **valp)
 {
@@ -90,41 +93,6 @@ sshbuf_get_ec(struct sshbuf *buf, EC_POINT *v, const EC_GROUP *g)
 	}
 	return 0;
 }
-
-int
-sshbuf_get_eckey(struct sshbuf *buf, EC_KEY *v)
-{
-	EC_POINT *pt = EC_POINT_new(EC_KEY_get0_group(v));
-	int r;
-	const u_char *d;
-	size_t len;
-
-	if (pt == NULL) {
-		SSHBUF_DBG(("SSH_ERR_ALLOC_FAIL"));
-		return SSH_ERR_ALLOC_FAIL;
-	}
-	if ((r = sshbuf_peek_string_direct(buf, &d, &len)) < 0) {
-		EC_POINT_free(pt);
-		return r;
-	}
-	if ((r = get_ec(d, len, pt, EC_KEY_get0_group(v))) != 0) {
-		EC_POINT_free(pt);
-		return r;
-	}
-	if (EC_KEY_set_public_key(v, pt) != 1) {
-		EC_POINT_free(pt);
-		return SSH_ERR_ALLOC_FAIL; /* XXX assumption */
-	}
-	EC_POINT_free(pt);
-	/* Skip string */
-	if (sshbuf_get_string_direct(buf, NULL, NULL) != 0) {
-		/* Shouldn't happen */
-		SSHBUF_DBG(("SSH_ERR_INTERNAL_ERROR"));
-		SSHBUF_ABORT();
-		return SSH_ERR_INTERNAL_ERROR;
-	}
-	return 0;	
-}
 #endif /* OPENSSL_HAS_ECC */
 
 int
@@ -171,10 +139,66 @@ sshbuf_put_ec(struct sshbuf *buf, const EC_POINT *v, const EC_GROUP *g)
 }
 
 int
-sshbuf_put_eckey(struct sshbuf *buf, const EC_KEY *v)
+sshbuf_put_eckey(struct sshbuf *buf, const EVP_PKEY *v)
 {
-	return sshbuf_put_ec(buf, EC_KEY_get0_public_key(v),
-	    EC_KEY_get0_group(v));
+	char *curve = NULL, *pub = NULL;
+	size_t curve_len = 0, pub_len = 0;
+	EC_GROUP *group = NULL;
+	EC_POINT *point = NULL;
+	int nid = -1, r;
+
+	if (EVP_PKEY_get_utf8_string_param(v,
+	    OSSL_PKEY_PARAM_GROUP_NAME, NULL, 0, &curve_len) == 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if ((curve = malloc(curve_len + 1)) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	if (EVP_PKEY_get_utf8_string_param(v,
+	    OSSL_PKEY_PARAM_GROUP_NAME, curve, curve_len + 1,
+	    NULL) == 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if (EVP_PKEY_get_octet_string_param(v,
+	    OSSL_PKEY_PARAM_PUB_KEY, NULL, 0, &pub_len) == 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if ((pub = malloc(pub_len)) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	if (EVP_PKEY_get_octet_string_param(v,
+	    OSSL_PKEY_PARAM_PUB_KEY, pub, pub_len, NULL) == 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if ((nid = OBJ_sn2nid(curve)) == NID_undef) {
+		r = SSH_ERR_EC_CURVE_INVALID;
+		goto out;
+	}
+	if ((group = EC_GROUP_new_by_curve_name(nid)) == NULL) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if ((point = EC_POINT_new(group)) == NULL) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if (EC_POINT_oct2point(group, point, pub, pub_len, NULL) == 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	r = sshbuf_put_ec(buf, point, group);
+out:
+	EC_POINT_free(point);
+	EC_GROUP_free(group);
+	free(pub);
+	free(curve);
+	return r;
 }
 #endif /* OPENSSL_HAS_ECC */
 #endif /* WITH_OPENSSL */
diff --git a/sshbuf.h b/sshbuf.h
index 07d54f0..680dfe2 100644
--- a/sshbuf.h
+++ b/sshbuf.h
@@ -235,9 +235,8 @@ int	sshbuf_get_bignum2(struct sshbuf *buf, BIGNUM **valp);
 int	sshbuf_put_bignum2(struct sshbuf *buf, const BIGNUM *v);
 # ifdef OPENSSL_HAS_ECC
 int	sshbuf_get_ec(struct sshbuf *buf, EC_POINT *v, const EC_GROUP *g);
-int	sshbuf_get_eckey(struct sshbuf *buf, EC_KEY *v);
 int	sshbuf_put_ec(struct sshbuf *buf, const EC_POINT *v, const EC_GROUP *g);
-int	sshbuf_put_eckey(struct sshbuf *buf, const EC_KEY *v);
+int	sshbuf_put_eckey(struct sshbuf *buf, const EVP_PKEY *v);
 # endif /* OPENSSL_HAS_ECC */
 #endif /* WITH_OPENSSL */
 
diff --git a/sshkey.c b/sshkey.c
index f1e9200..0e9d153 100644
--- a/sshkey.c
+++ b/sshkey.c
@@ -346,24 +346,18 @@ sshkey_names_valid2(const char *names, int allow_wildcard)
 u_int
 sshkey_size(const struct sshkey *k)
 {
-#ifdef WITH_OPENSSL
-	const BIGNUM *rsa_n, *dsa_p;
-#endif /* WITH_OPENSSL */
-
 	switch (k->type) {
 #ifdef WITH_OPENSSL
 	case KEY_RSA:
 	case KEY_RSA_CERT:
 		if (k->rsa == NULL)
 			return 0;
-		RSA_get0_key(k->rsa, &rsa_n, NULL, NULL);
-		return BN_num_bits(rsa_n);
+		return EVP_PKEY_bits(k->rsa);
 	case KEY_DSA:
 	case KEY_DSA_CERT:
 		if (k->dsa == NULL)
 			return 0;
-		DSA_get0_pqg(k->dsa, &dsa_p, NULL, NULL);
-		return BN_num_bits(dsa_p);
+		return EVP_PKEY_bits(k->dsa);
 	case KEY_ECDSA:
 	case KEY_ECDSA_CERT:
 	case KEY_ECDSA_SK:
@@ -573,10 +567,6 @@ struct sshkey *
 sshkey_new(int type)
 {
 	struct sshkey *k;
-#ifdef WITH_OPENSSL
-	RSA *rsa;
-	DSA *dsa;
-#endif /* WITH_OPENSSL */
 
 	if ((k = calloc(1, sizeof(*k))) == NULL)
 		return NULL;
@@ -594,25 +584,13 @@ sshkey_new(int type)
 #ifdef WITH_OPENSSL
 	case KEY_RSA:
 	case KEY_RSA_CERT:
-		if ((rsa = RSA_new()) == NULL) {
-			free(k);
-			return NULL;
-		}
-		k->rsa = rsa;
-		break;
 	case KEY_DSA:
 	case KEY_DSA_CERT:
-		if ((dsa = DSA_new()) == NULL) {
-			free(k);
-			return NULL;
-		}
-		k->dsa = dsa;
-		break;
 	case KEY_ECDSA:
 	case KEY_ECDSA_CERT:
 	case KEY_ECDSA_SK:
 	case KEY_ECDSA_SK_CERT:
-		/* Cannot do anything until we know the group */
+		/* no need to prealloc */
 		break;
 #endif /* WITH_OPENSSL */
 	case KEY_ED25519:
@@ -649,12 +627,12 @@ sshkey_free(struct sshkey *k)
 #ifdef WITH_OPENSSL
 	case KEY_RSA:
 	case KEY_RSA_CERT:
-		RSA_free(k->rsa);
+		EVP_PKEY_free(k->rsa);
 		k->rsa = NULL;
 		break;
 	case KEY_DSA:
 	case KEY_DSA_CERT:
-		DSA_free(k->dsa);
+		EVP_PKEY_free(k->dsa);
 		k->dsa = NULL;
 		break;
 # ifdef OPENSSL_HAS_ECC
@@ -666,7 +644,7 @@ sshkey_free(struct sshkey *k)
 		/* FALLTHROUGH */
 	case KEY_ECDSA:
 	case KEY_ECDSA_CERT:
-		EC_KEY_free(k->ecdsa);
+		EVP_PKEY_free(k->ecdsa);
 		k->ecdsa = NULL;
 		break;
 # endif /* OPENSSL_HAS_ECC */
@@ -733,10 +711,9 @@ int
 sshkey_equal_public(const struct sshkey *a, const struct sshkey *b)
 {
 #if defined(WITH_OPENSSL)
-	const BIGNUM *rsa_e_a, *rsa_n_a;
-	const BIGNUM *rsa_e_b, *rsa_n_b;
-	const BIGNUM *dsa_p_a, *dsa_q_a, *dsa_g_a, *dsa_pub_key_a;
-	const BIGNUM *dsa_p_b, *dsa_q_b, *dsa_g_b, *dsa_pub_key_b;
+	int a_pk_len, b_pk_len;
+	unsigned char *a_pk = NULL, *b_pk = NULL;
+	int ret;
 #endif /* WITH_OPENSSL */
 
 	if (a == NULL || b == NULL ||
@@ -749,22 +726,36 @@ sshkey_equal_public(const struct sshkey *a, const struct sshkey *b)
 	case KEY_RSA:
 		if (a->rsa == NULL || b->rsa == NULL)
 			return 0;
-		RSA_get0_key(a->rsa, &rsa_n_a, &rsa_e_a, NULL);
-		RSA_get0_key(b->rsa, &rsa_n_b, &rsa_e_b, NULL);
-		return BN_cmp(rsa_e_a, rsa_e_b) == 0 &&
-		    BN_cmp(rsa_n_a, rsa_n_b) == 0;
+		a_pk_len = i2d_PublicKey(a->rsa, &a_pk);
+		if (a_pk_len < 0)
+			return 0;
+		b_pk_len = i2d_PublicKey(b->rsa, &b_pk);
+		if (b_pk_len < 0) {
+			OPENSSL_free(a_pk);
+			return 0;
+		}
+		ret = (a_pk_len == b_pk_len &&
+				memcmp(a_pk, b_pk, a_pk_len) == 0);
+		OPENSSL_free(b_pk);
+		OPENSSL_free(a_pk);
+		return ret;
 	case KEY_DSA_CERT:
 	case KEY_DSA:
 		if (a->dsa == NULL || b->dsa == NULL)
 			return 0;
-		DSA_get0_pqg(a->dsa, &dsa_p_a, &dsa_q_a, &dsa_g_a);
-		DSA_get0_pqg(b->dsa, &dsa_p_b, &dsa_q_b, &dsa_g_b);
-		DSA_get0_key(a->dsa, &dsa_pub_key_a, NULL);
-		DSA_get0_key(b->dsa, &dsa_pub_key_b, NULL);
-		return BN_cmp(dsa_p_a, dsa_p_b) == 0 &&
-		    BN_cmp(dsa_q_a, dsa_q_b) == 0 &&
-		    BN_cmp(dsa_g_a, dsa_g_b) == 0 &&
-		    BN_cmp(dsa_pub_key_a, dsa_pub_key_b) == 0;
+		a_pk_len = i2d_PublicKey(a->dsa, &a_pk);
+		if (a_pk_len < 0)
+			return 0;
+		b_pk_len = i2d_PublicKey(b->dsa, &b_pk);
+		if (b_pk_len < 0) {
+			OPENSSL_free(a_pk);
+			return 0;
+		}
+		ret = (a_pk_len == b_pk_len &&
+				memcmp(a_pk, b_pk, a_pk_len) == 0);
+		OPENSSL_free(b_pk);
+		OPENSSL_free(a_pk);
+		return ret;
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA_SK:
 	case KEY_ECDSA_SK_CERT:
@@ -775,17 +766,21 @@ sshkey_equal_public(const struct sshkey *a, const struct sshkey *b)
 		/* FALLTHROUGH */
 	case KEY_ECDSA_CERT:
 	case KEY_ECDSA:
-		if (a->ecdsa == NULL || b->ecdsa == NULL ||
-		    EC_KEY_get0_public_key(a->ecdsa) == NULL ||
-		    EC_KEY_get0_public_key(b->ecdsa) == NULL)
+		if (a->ecdsa == NULL || b->ecdsa == NULL)
 			return 0;
-		if (EC_GROUP_cmp(EC_KEY_get0_group(a->ecdsa),
-		    EC_KEY_get0_group(b->ecdsa), NULL) != 0 ||
-		    EC_POINT_cmp(EC_KEY_get0_group(a->ecdsa),
-		    EC_KEY_get0_public_key(a->ecdsa),
-		    EC_KEY_get0_public_key(b->ecdsa), NULL) != 0)
+		a_pk_len = i2d_PublicKey(a->ecdsa, &a_pk);
+		if (a_pk_len < 0)
 			return 0;
-		return 1;
+		b_pk_len = i2d_PublicKey(b->ecdsa, &b_pk);
+		if (b_pk_len < 0) {
+			OPENSSL_free(a_pk);
+			return 0;
+		}
+		ret = (a_pk_len == b_pk_len &&
+				memcmp(a_pk, b_pk, a_pk_len) == 0);
+		OPENSSL_free(b_pk);
+		OPENSSL_free(a_pk);
+		return ret;
 # endif /* OPENSSL_HAS_ECC */
 #endif /* WITH_OPENSSL */
 	case KEY_ED25519_SK:
@@ -831,7 +826,8 @@ to_blob_buf(const struct sshkey *key, struct sshbuf *b, int force_plain,
 	int type, ret = SSH_ERR_INTERNAL_ERROR;
 	const char *typename;
 #ifdef WITH_OPENSSL
-	const BIGNUM *rsa_n, *rsa_e, *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;
+	BIGNUM *rsa_n = NULL, *rsa_e = NULL;
+	BIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL, *dsa_pub_key = NULL;
 #endif /* WITH_OPENSSL */
 
 	if (key == NULL)
@@ -867,14 +863,37 @@ to_blob_buf(const struct sshkey *key, struct sshbuf *b, int force_plain,
 	case KEY_DSA:
 		if (key->dsa == NULL)
 			return SSH_ERR_INVALID_ARGUMENT;
-		DSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);
-		DSA_get0_key(key->dsa, &dsa_pub_key, NULL);
+		if (EVP_PKEY_get_bn_param(key->dsa, OSSL_PKEY_PARAM_FFC_P,
+		    &dsa_p) == 0 ||
+		    EVP_PKEY_get_bn_param(key->dsa, OSSL_PKEY_PARAM_FFC_Q,
+		    &dsa_q) == 0 ||
+		    EVP_PKEY_get_bn_param(key->dsa, OSSL_PKEY_PARAM_FFC_G,
+		    &dsa_g) == 0 ||
+		    EVP_PKEY_get_bn_param(key->dsa, OSSL_PKEY_PARAM_PUB_KEY,
+		    &dsa_pub_key) == 0) {
+			if (dsa_g != NULL)
+				BN_free(dsa_g);
+			if (dsa_q != NULL)
+				BN_free(dsa_q);
+			if (dsa_p != NULL)
+				BN_free(dsa_p);
+			return SSH_ERR_LIBCRYPTO_ERROR;
+		}
 		if ((ret = sshbuf_put_cstring(b, typename)) != 0 ||
 		    (ret = sshbuf_put_bignum2(b, dsa_p)) != 0 ||
 		    (ret = sshbuf_put_bignum2(b, dsa_q)) != 0 ||
 		    (ret = sshbuf_put_bignum2(b, dsa_g)) != 0 ||
-		    (ret = sshbuf_put_bignum2(b, dsa_pub_key)) != 0)
+		    (ret = sshbuf_put_bignum2(b, dsa_pub_key)) != 0) {
+			BN_free(dsa_pub_key);
+			BN_free(dsa_g);
+			BN_free(dsa_q);
+			BN_free(dsa_p);
 			return ret;
+		}
+		BN_free(dsa_pub_key);
+		BN_free(dsa_g);
+		BN_free(dsa_q);
+		BN_free(dsa_p);
 		break;
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA:
@@ -896,11 +915,23 @@ to_blob_buf(const struct sshkey *key, struct sshbuf *b, int force_plain,
 	case KEY_RSA:
 		if (key->rsa == NULL)
 			return SSH_ERR_INVALID_ARGUMENT;
-		RSA_get0_key(key->rsa, &rsa_n, &rsa_e, NULL);
+		if (EVP_PKEY_get_bn_param(key->rsa, OSSL_PKEY_PARAM_RSA_N,
+		    &rsa_n) == 0 ||
+		    EVP_PKEY_get_bn_param(key->rsa, OSSL_PKEY_PARAM_RSA_E,
+		    &rsa_e) == 0) {
+			if (rsa_n != NULL)
+				BN_free(rsa_n);
+			return SSH_ERR_LIBCRYPTO_ERROR;
+		}
 		if ((ret = sshbuf_put_cstring(b, typename)) != 0 ||
 		    (ret = sshbuf_put_bignum2(b, rsa_e)) != 0 ||
-		    (ret = sshbuf_put_bignum2(b, rsa_n)) != 0)
+		    (ret = sshbuf_put_bignum2(b, rsa_n)) != 0) {
+			BN_free(rsa_e);
+			BN_free(rsa_n);
 			return ret;
+		}
+		BN_free(rsa_e);
+		BN_free(rsa_n);
 		break;
 #endif /* WITH_OPENSSL */
 	case KEY_ED25519:
@@ -1435,24 +1466,28 @@ sshkey_read(struct sshkey *ret, char **cpp)
 	switch (sshkey_type_plain(ret->type)) {
 #ifdef WITH_OPENSSL
 	case KEY_RSA:
-		RSA_free(ret->rsa);
+		EVP_PKEY_free(ret->rsa);
 		ret->rsa = k->rsa;
 		k->rsa = NULL;
 #ifdef DEBUG_PK
-		RSA_print_fp(stderr, ret->rsa, 8);
+		EVP_PKEY_print_public_fp(stderr, ret->rsa, 8, NULL);
+		EVP_PKEY_print_private_fp(stderr, ret->rsa, 8, NULL);
+		EVP_PKEY_print_params_fp(stderr, ret->rsa, 8, NULL);
 #endif
 		break;
 	case KEY_DSA:
-		DSA_free(ret->dsa);
+		EVP_PKEY_free(ret->dsa);
 		ret->dsa = k->dsa;
 		k->dsa = NULL;
 #ifdef DEBUG_PK
-		DSA_print_fp(stderr, ret->dsa, 8);
+		EVP_PKEY_print_public_fp(stderr, ret->rsa, 8, NULL);
+		EVP_PKEY_print_private_fp(stderr, ret->rsa, 8, NULL);
+		EVP_PKEY_print_params_fp(stderr, ret->rsa, 8, NULL);
 #endif
 		break;
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA:
-		EC_KEY_free(ret->ecdsa);
+		EVP_PKEY_free(ret->ecdsa);
 		ret->ecdsa = k->ecdsa;
 		ret->ecdsa_nid = k->ecdsa_nid;
 		k->ecdsa = NULL;
@@ -1462,7 +1497,7 @@ sshkey_read(struct sshkey *ret, char **cpp)
 #endif
 		break;
 	case KEY_ECDSA_SK:
-		EC_KEY_free(ret->ecdsa);
+		EVP_PKEY_free(ret->ecdsa);
 		ret->ecdsa = k->ecdsa;
 		ret->ecdsa_nid = k->ecdsa_nid;
 		ret->sk_application = k->sk_application;
@@ -1606,9 +1641,10 @@ sshkey_cert_type(const struct sshkey *k)
 
 #ifdef WITH_OPENSSL
 static int
-rsa_generate_private_key(u_int bits, RSA **rsap)
+rsa_generate_private_key(u_int bits, EVP_PKEY **rsap)
 {
-	RSA *private = NULL;
+	EVP_PKEY *private = NULL;
+	EVP_PKEY_CTX *pctx = NULL;
 	BIGNUM *f4 = NULL;
 	int ret = SSH_ERR_INTERNAL_ERROR;
 
@@ -1618,12 +1654,16 @@ rsa_generate_private_key(u_int bits, RSA **rsap)
 	    bits > SSHBUF_MAX_BIGNUM * 8)
 		return SSH_ERR_KEY_LENGTH;
 	*rsap = NULL;
-	if ((private = RSA_new()) == NULL || (f4 = BN_new()) == NULL) {
+	if ((pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL)) == NULL ||
+	    (f4 = BN_new()) == NULL) {
 		ret = SSH_ERR_ALLOC_FAIL;
 		goto out;
 	}
 	if (!BN_set_word(f4, RSA_F4) ||
-	    !RSA_generate_key_ex(private, bits, f4, NULL)) {
+	    EVP_PKEY_keygen_init(pctx) <= 0 ||
+	    EVP_PKEY_CTX_set_rsa_keygen_bits(pctx, bits) <= 0 ||
+	    EVP_PKEY_CTX_set1_rsa_keygen_pubexp(pctx, f4) <= 0 ||
+	    EVP_PKEY_keygen(pctx, &private) <= 0) {
 		ret = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
 	}
@@ -1631,28 +1671,43 @@ rsa_generate_private_key(u_int bits, RSA **rsap)
 	private = NULL;
 	ret = 0;
  out:
-	RSA_free(private);
+	EVP_PKEY_free(private);
 	BN_free(f4);
+	EVP_PKEY_CTX_free(pctx);
 	return ret;
 }
 
 static int
-dsa_generate_private_key(u_int bits, DSA **dsap)
+dsa_generate_private_key(u_int bits, EVP_PKEY **dsap)
 {
-	DSA *private;
+	EVP_PKEY *private = NULL;
+	EVP_PKEY *params = NULL;
+	EVP_PKEY_CTX *pctx = NULL;
 	int ret = SSH_ERR_INTERNAL_ERROR;
 
 	if (dsap == NULL)
 		return SSH_ERR_INVALID_ARGUMENT;
 	if (bits != 1024)
 		return SSH_ERR_KEY_LENGTH;
-	if ((private = DSA_new()) == NULL) {
+	if ((pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_DSA, NULL)) == NULL) {
 		ret = SSH_ERR_ALLOC_FAIL;
 		goto out;
 	}
 	*dsap = NULL;
-	if (!DSA_generate_parameters_ex(private, bits, NULL, 0, NULL,
-	    NULL, NULL) || !DSA_generate_key(private)) {
+	if (EVP_PKEY_paramgen_init(pctx) <= 0 ||
+	    EVP_PKEY_CTX_set_dsa_paramgen_bits(pctx, bits) <= 0 ||
+	    EVP_PKEY_CTX_set_dsa_paramgen_q_bits(pctx, 160) <= 0 ||
+	    EVP_PKEY_paramgen(pctx, &params) <= 0) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	EVP_PKEY_CTX_free(pctx);
+	if ((pctx = EVP_PKEY_CTX_new(params, NULL)) == NULL) {
+		ret = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	if (EVP_PKEY_keygen_init(pctx) <= 0 ||
+	    EVP_PKEY_keygen(pctx, &private) <= 0) {
 		ret = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
 	}
@@ -1660,80 +1715,93 @@ dsa_generate_private_key(u_int bits, DSA **dsap)
 	private = NULL;
 	ret = 0;
  out:
-	DSA_free(private);
+	EVP_PKEY_free(private);
+	EVP_PKEY_free(params);
+	EVP_PKEY_CTX_free(pctx);
 	return ret;
 }
 
 # ifdef OPENSSL_HAS_ECC
 int
-sshkey_ecdsa_key_to_nid(EC_KEY *k)
+sshkey_ecdsa_key_to_nid(EVP_PKEY *k)
 {
-	EC_GROUP *eg;
-	int nids[] = {
-		NID_X9_62_prime256v1,
-		NID_secp384r1,
-#  ifdef OPENSSL_HAS_NISTP521
-		NID_secp521r1,
-#  endif /* OPENSSL_HAS_NISTP521 */
-		-1
-	};
-	int nid;
-	u_int i;
-	const EC_GROUP *g = EC_KEY_get0_group(k);
+	char *buf = NULL;
+	size_t size = 0;
+	int nid = -1, explicit = 0;
 
-	/*
-	 * The group may be stored in a ASN.1 encoded private key in one of two
-	 * ways: as a "named group", which is reconstituted by ASN.1 object ID
-	 * or explicit group parameters encoded into the key blob. Only the
-	 * "named group" case sets the group NID for us, but we can figure
-	 * it out for the other case by comparing against all the groups that
-	 * are supported.
-	 */
-	if ((nid = EC_GROUP_get_curve_name(g)) > 0)
-		return nid;
-	for (i = 0; nids[i] != -1; i++) {
-		if ((eg = EC_GROUP_new_by_curve_name(nids[i])) == NULL)
-			return -1;
-		if (EC_GROUP_cmp(g, eg, NULL) == 0)
-			break;
-		EC_GROUP_free(eg);
-	}
-	if (nids[i] != -1) {
-		/* Use the group with the NID attached */
-		EC_GROUP_set_asn1_flag(eg, OPENSSL_EC_NAMED_CURVE);
-		if (EC_KEY_set_group(k, eg) != 1) {
-			EC_GROUP_free(eg);
-			return -1;
-		}
+	if (EVP_PKEY_get_utf8_string_param(k, OSSL_PKEY_PARAM_GROUP_NAME,
+			NULL, 0, &size) == 0 || size == 0)
+		return -1;
+
+	buf = malloc(size + 1);
+	if (buf == NULL)
+		return -1;
+
+	if (EVP_PKEY_get_utf8_string_param(k, OSSL_PKEY_PARAM_GROUP_NAME,
+			buf, size + 1, NULL) == 0) {
+		free(buf);
+		return -1;
 	}
-	return nids[i];
+
+	nid = OBJ_sn2nid(buf);
+	free(buf);
+
+	if (nid == NID_undef)
+		return -1;
+
+	if (EVP_PKEY_get_int_param(k,
+			OSSL_PKEY_PARAM_EC_DECODED_FROM_EXPLICIT_PARAMS,
+			&explicit) == 0)
+		return -1;
+
+	if (explicit && EVP_PKEY_set_utf8_string_param(k,
+			OSSL_PKEY_PARAM_EC_ENCODING, "named_curve") == 0)
+		return -1;
+
+	return nid;
 }
 
 static int
-ecdsa_generate_private_key(u_int bits, int *nid, EC_KEY **ecdsap)
+ecdsa_generate_private_key(u_int bits, int *nid, EVP_PKEY **ecdsap)
 {
-	EC_KEY *private;
+	EVP_PKEY *private = NULL;
+	EVP_PKEY *params = NULL;
+	EVP_PKEY_CTX *pctx = NULL;
 	int ret = SSH_ERR_INTERNAL_ERROR;
 
 	if (nid == NULL || ecdsap == NULL)
 		return SSH_ERR_INVALID_ARGUMENT;
 	if ((*nid = sshkey_ecdsa_bits_to_nid(bits)) == -1)
 		return SSH_ERR_KEY_LENGTH;
+	if ((pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL)) == NULL) {
+		ret = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
 	*ecdsap = NULL;
-	if ((private = EC_KEY_new_by_curve_name(*nid)) == NULL) {
+	if (EVP_PKEY_paramgen_init(pctx) <= 0 ||
+	    EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx, *nid) <= 0 ||
+	    EVP_PKEY_CTX_set_ec_param_enc(pctx, OPENSSL_EC_NAMED_CURVE) <= 0 ||
+	    EVP_PKEY_paramgen(pctx, &params) <= 0) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	EVP_PKEY_CTX_free(pctx);
+	if ((pctx = EVP_PKEY_CTX_new(params, NULL)) == NULL) {
 		ret = SSH_ERR_ALLOC_FAIL;
 		goto out;
 	}
-	if (EC_KEY_generate_key(private) != 1) {
+	if (EVP_PKEY_keygen_init(pctx) <= 0 ||
+	    EVP_PKEY_keygen(pctx, &private) <= 0) {
 		ret = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
 	}
-	EC_KEY_set_asn1_flag(private, OPENSSL_EC_NAMED_CURVE);
 	*ecdsap = private;
 	private = NULL;
 	ret = 0;
  out:
-	EC_KEY_free(private);
+	EVP_PKEY_free(private);
+	EVP_PKEY_free(params);
+	EVP_PKEY_CTX_free(pctx);
 	return ret;
 }
 # endif /* OPENSSL_HAS_ECC */
@@ -1866,11 +1934,11 @@ sshkey_from_private(const struct sshkey *k, struct sshkey **pkp)
 	struct sshkey *n = NULL;
 	int r = SSH_ERR_INTERNAL_ERROR;
 #ifdef WITH_OPENSSL
-	const BIGNUM *rsa_n, *rsa_e;
-	BIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;
-	const BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;
-	BIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;
-	BIGNUM *dsa_pub_key_dup = NULL;
+	OSSL_ENCODER_CTX *ectx = NULL;
+	OSSL_DECODER_CTX *dctx = NULL;
+	unsigned char *pub = NULL;
+	const unsigned char *ppub = NULL;
+	size_t publen = 0;
 #endif /* WITH_OPENSSL */
 
 	*pkp = NULL;
@@ -1882,26 +1950,35 @@ sshkey_from_private(const struct sshkey *k, struct sshkey **pkp)
 #ifdef WITH_OPENSSL
 	case KEY_DSA:
 	case KEY_DSA_CERT:
-		DSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);
-		DSA_get0_key(k->dsa, &dsa_pub_key, NULL);
-		if ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||
-		    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||
-		    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||
-		    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {
-			r = SSH_ERR_ALLOC_FAIL;
+		if ((ectx = OSSL_ENCODER_CTX_new_for_pkey(k->dsa,
+		    EVP_PKEY_PUBLIC_KEY, "DER", "type-specific", NULL))
+		    == NULL) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
-		if (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {
+		if (OSSL_ENCODER_CTX_get_num_encoders(ectx) == 0) {
 			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
-		dsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */
-		if (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {
+		if (OSSL_ENCODER_to_data(ectx, &pub, &publen) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		if ((dctx = OSSL_DECODER_CTX_new_for_pkey(&n->dsa, "DER",
+		    "type-specific", "DSA", EVP_PKEY_PUBLIC_KEY, NULL, NULL))
+		    == NULL) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		if (OSSL_DECODER_CTX_get_num_decoders(dctx) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		ppub = pub;
+		if (OSSL_DECODER_from_data(dctx, &ppub, &publen) == 0) {
 			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
-		dsa_pub_key_dup = NULL; /* transferred */
-
 		break;
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA:
@@ -1909,13 +1986,32 @@ sshkey_from_private(const struct sshkey *k, struct sshkey **pkp)
 	case KEY_ECDSA_SK:
 	case KEY_ECDSA_SK_CERT:
 		n->ecdsa_nid = k->ecdsa_nid;
-		n->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);
-		if (n->ecdsa == NULL) {
-			r = SSH_ERR_ALLOC_FAIL;
+		if ((ectx = OSSL_ENCODER_CTX_new_for_pkey(k->ecdsa,
+		    EVP_PKEY_PUBLIC_KEY, "DER", "SubjectPublicKeyInfo", NULL))
+		    == NULL) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		if (OSSL_ENCODER_CTX_get_num_encoders(ectx) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		if (OSSL_ENCODER_to_data(ectx, &pub, &publen) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		if ((dctx = OSSL_DECODER_CTX_new_for_pkey(&n->ecdsa, "DER",
+		    "SubjectPublicKeyInfo", "EC", EVP_PKEY_PUBLIC_KEY, NULL,
+		    NULL)) == NULL) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		if (OSSL_DECODER_CTX_get_num_decoders(dctx) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
-		if (EC_KEY_set_public_key(n->ecdsa,
-		    EC_KEY_get0_public_key(k->ecdsa)) != 1) {
+		ppub = pub;
+		if (OSSL_DECODER_from_data(dctx, &ppub, &publen) == 0) {
 			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
@@ -1928,17 +2024,35 @@ sshkey_from_private(const struct sshkey *k, struct sshkey **pkp)
 # endif /* OPENSSL_HAS_ECC */
 	case KEY_RSA:
 	case KEY_RSA_CERT:
-		RSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);
-		if ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||
-		    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {
-			r = SSH_ERR_ALLOC_FAIL;
+		if ((ectx = OSSL_ENCODER_CTX_new_for_pkey(k->rsa,
+		    EVP_PKEY_PUBLIC_KEY, "DER", "type-specific", NULL))
+		    == NULL) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		if (OSSL_ENCODER_CTX_get_num_encoders(ectx) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
-		if (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {
+		if (OSSL_ENCODER_to_data(ectx, &pub, &publen) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		if ((dctx = OSSL_DECODER_CTX_new_for_pkey(&n->rsa, "DER",
+		    "type-specific", "RSA", EVP_PKEY_PUBLIC_KEY, NULL, NULL))
+		    == NULL) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		if (OSSL_DECODER_CTX_get_num_decoders(dctx) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		ppub = pub;
+		if (OSSL_DECODER_from_data(dctx, &ppub, &publen) == 0) {
 			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
-		rsa_n_dup = rsa_e_dup = NULL; /* transferred */
 		break;
 #endif /* WITH_OPENSSL */
 	case KEY_ED25519:
@@ -1996,12 +2110,9 @@ sshkey_from_private(const struct sshkey *k, struct sshkey **pkp)
  out:
 	sshkey_free(n);
 #ifdef WITH_OPENSSL
-	BN_clear_free(rsa_n_dup);
-	BN_clear_free(rsa_e_dup);
-	BN_clear_free(dsa_p_dup);
-	BN_clear_free(dsa_q_dup);
-	BN_clear_free(dsa_g_dup);
-	BN_clear_free(dsa_pub_key_dup);
+	OPENSSL_free(pub);
+	OSSL_DECODER_CTX_free(dctx);
+	OSSL_ENCODER_CTX_free(ectx);
 #endif
 
 	return r;
@@ -2350,12 +2461,9 @@ cert_parse(struct sshbuf *b, struct sshkey *key, struct sshbuf *certbuf)
 
 #ifdef WITH_OPENSSL
 static int
-check_rsa_length(const RSA *rsa)
+check_rsa_length(const EVP_PKEY *rsa)
 {
-	const BIGNUM *rsa_n;
-
-	RSA_get0_key(rsa, &rsa_n, NULL, NULL);
-	if (BN_num_bits(rsa_n) < SSH_RSA_MINIMUM_MODULUS_SIZE)
+	if (EVP_PKEY_bits(rsa) < SSH_RSA_MINIMUM_MODULUS_SIZE)
 		return SSH_ERR_KEY_LENGTH;
 	return 0;
 }
@@ -2372,10 +2480,16 @@ sshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,
 	u_char *pk = NULL;
 	struct sshbuf *copy;
 #if defined(WITH_OPENSSL)
+	OSSL_PARAM_BLD *bld = NULL;
+	OSSL_PARAM *params = NULL;
+	EVP_PKEY_CTX *pctx = NULL;
 	BIGNUM *rsa_n = NULL, *rsa_e = NULL;
 	BIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL, *dsa_pub_key = NULL;
 # if defined(OPENSSL_HAS_ECC)
+	EC_GROUP *group = NULL;
 	EC_POINT *q = NULL;
+	size_t ecdsa_publen = 0;
+	char *ecdsa_pub_key = NULL;
 # endif /* OPENSSL_HAS_ECC */
 #endif /* WITH_OPENSSL */
 
@@ -2417,15 +2531,34 @@ sshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,
 			ret = SSH_ERR_INVALID_FORMAT;
 			goto out;
 		}
-		if (!RSA_set0_key(key->rsa, rsa_n, rsa_e, NULL)) {
+		bld = OSSL_PARAM_BLD_new();
+		if (bld == NULL) {
+			ret = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+		if (OSSL_PARAM_BLD_push_BN(bld,
+					OSSL_PKEY_PARAM_RSA_E, rsa_e) == 0 ||
+				OSSL_PARAM_BLD_push_BN(bld,
+					OSSL_PKEY_PARAM_RSA_N, rsa_n) == 0) {
+			ret = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		params = OSSL_PARAM_BLD_to_param(bld);
+		if (params == NULL) {
+			ret = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		pctx = EVP_PKEY_CTX_new_from_name(NULL, "RSA", NULL);
+		if (pctx == NULL || EVP_PKEY_fromdata_init(pctx) <= 0 ||
+				EVP_PKEY_fromdata(pctx, &key->rsa,
+					EVP_PKEY_PUBLIC_KEY, params) <= 0) {
 			ret = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
-		rsa_n = rsa_e = NULL; /* transferred */
 		if ((ret = check_rsa_length(key->rsa)) != 0)
 			goto out;
 #ifdef DEBUG_PK
-		RSA_print_fp(stderr, key->rsa, 8);
+		EVP_PKEY_print_public_fp(stderr, key->rsa, 8, NULL);
 #endif
 		break;
 	case KEY_DSA_CERT:
@@ -2447,18 +2580,36 @@ sshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,
 			ret = SSH_ERR_INVALID_FORMAT;
 			goto out;
 		}
-		if (!DSA_set0_pqg(key->dsa, dsa_p, dsa_q, dsa_g)) {
+		bld = OSSL_PARAM_BLD_new();
+		if (bld == NULL) {
+			ret = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+		if (OSSL_PARAM_BLD_push_BN(bld,
+					OSSL_PKEY_PARAM_FFC_P, dsa_p) == 0 ||
+				OSSL_PARAM_BLD_push_BN(bld,
+					OSSL_PKEY_PARAM_FFC_Q, dsa_q) == 0 ||
+				OSSL_PARAM_BLD_push_BN(bld,
+					OSSL_PKEY_PARAM_FFC_G, dsa_g) == 0 ||
+				OSSL_PARAM_BLD_push_BN(bld,
+					OSSL_PKEY_PARAM_PUB_KEY, dsa_pub_key) == 0) {
 			ret = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
-		dsa_p = dsa_q = dsa_g = NULL; /* transferred */
-		if (!DSA_set0_key(key->dsa, dsa_pub_key, NULL)) {
+		params = OSSL_PARAM_BLD_to_param(bld);
+		if (params == NULL) {
+			ret = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		pctx = EVP_PKEY_CTX_new_from_name(NULL, "DSA", NULL);
+		if (pctx == NULL || EVP_PKEY_fromdata_init(pctx) <= 0 ||
+				EVP_PKEY_fromdata(pctx, &key->dsa,
+					EVP_PKEY_PUBLIC_KEY, params) <= 0) {
 			ret = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
-		dsa_pub_key = NULL; /* transferred */
 #ifdef DEBUG_PK
-		DSA_print_fp(stderr, key->dsa, 8);
+		EVP_PKEY_print_public_fp(stderr, key->dsa, 8, NULL);
 #endif
 		break;
 # ifdef OPENSSL_HAS_ECC
@@ -2485,32 +2636,64 @@ sshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,
 			ret = SSH_ERR_EC_CURVE_MISMATCH;
 			goto out;
 		}
-		EC_KEY_free(key->ecdsa);
-		if ((key->ecdsa = EC_KEY_new_by_curve_name(key->ecdsa_nid))
+		EVP_PKEY_free(key->ecdsa);
+		if ((group = EC_GROUP_new_by_curve_name(key->ecdsa_nid))
 		    == NULL) {
 			ret = SSH_ERR_EC_CURVE_INVALID;
 			goto out;
 		}
-		if ((q = EC_POINT_new(EC_KEY_get0_group(key->ecdsa))) == NULL) {
+		if ((q = EC_POINT_new(group)) == NULL) {
 			ret = SSH_ERR_ALLOC_FAIL;
 			goto out;
 		}
-		if (sshbuf_get_ec(b, q, EC_KEY_get0_group(key->ecdsa)) != 0) {
+		if (sshbuf_get_ec(b, q, group) != 0) {
 			ret = SSH_ERR_INVALID_FORMAT;
 			goto out;
 		}
-		if (sshkey_ec_validate_public(EC_KEY_get0_group(key->ecdsa),
-		    q) != 0) {
+		if (sshkey_ec_validate_public(group, q) != 0) {
 			ret = SSH_ERR_KEY_INVALID_EC_VALUE;
 			goto out;
 		}
-		if (EC_KEY_set_public_key(key->ecdsa, q) != 1) {
-			/* XXX assume it is a allocation error */
+		ecdsa_publen = EC_POINT_point2oct(group, q,
+				POINT_CONVERSION_UNCOMPRESSED, NULL, 0, NULL);
+		if ((ecdsa_pub_key = malloc(ecdsa_publen)) == NULL) {
 			ret = SSH_ERR_ALLOC_FAIL;
 			goto out;
 		}
+		if (EC_POINT_point2oct(group, q,
+				POINT_CONVERSION_UNCOMPRESSED, ecdsa_pub_key,
+				ecdsa_publen, NULL) == 0) {
+			ret = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		bld = OSSL_PARAM_BLD_new();
+		if (bld == NULL) {
+			ret = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+		if (OSSL_PARAM_BLD_push_utf8_string(bld,
+		    OSSL_PKEY_PARAM_GROUP_NAME, OBJ_nid2sn(key->ecdsa_nid), 0)
+		    == 0 ||
+		    OSSL_PARAM_BLD_push_octet_string(bld,
+		    OSSL_PKEY_PARAM_PUB_KEY, ecdsa_pub_key, ecdsa_publen)
+		    == 0) {
+			ret = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		params = OSSL_PARAM_BLD_to_param(bld);
+		if (params == NULL) {
+			ret = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		pctx = EVP_PKEY_CTX_new_from_name(NULL, "EC", NULL);
+		if (pctx == NULL || EVP_PKEY_fromdata_init(pctx) <= 0 ||
+				EVP_PKEY_fromdata(pctx, &key->ecdsa,
+					EVP_PKEY_PUBLIC_KEY, params) <= 0) {
+			ret = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
 #ifdef DEBUG_PK
-		sshkey_dump_ec_point(EC_KEY_get0_group(key->ecdsa), q);
+		sshkey_dump_ec_point(group, q);
 #endif
 		if (type == KEY_ECDSA_SK || type == KEY_ECDSA_SK_CERT) {
 			/* Parse additional security-key application string */
@@ -2617,6 +2800,9 @@ sshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,
 	free(curve);
 	free(pk);
 #if defined(WITH_OPENSSL)
+	OSSL_PARAM_BLD_free(bld);
+	OSSL_PARAM_free(params);
+	EVP_PKEY_CTX_free(pctx);
 	BN_clear_free(rsa_n);
 	BN_clear_free(rsa_e);
 	BN_clear_free(dsa_p);
@@ -2624,7 +2810,9 @@ sshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,
 	BN_clear_free(dsa_g);
 	BN_clear_free(dsa_pub_key);
 # if defined(OPENSSL_HAS_ECC)
-	EC_POINT_free(q);
+	EC_GROUP_free(group);
+	EC_POINT_clear_free(q);
+	free(ecdsa_pub_key);
 # endif /* OPENSSL_HAS_ECC */
 #endif /* WITH_OPENSSL */
 	return ret;
@@ -2927,7 +3115,14 @@ sshkey_certify_custom(struct sshkey *k, struct sshkey *ca, const char *alg,
 	struct sshbuf *cert = NULL;
 	char *sigtype = NULL;
 #ifdef WITH_OPENSSL
-	const BIGNUM *rsa_n, *rsa_e, *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;
+	BIGNUM *rsa_n = NULL, *rsa_e = NULL;
+	BIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL, *dsa_pub_key = NULL;
+# ifdef OPENSSL_HAS_ECC
+	EC_GROUP *ecdsa_group = NULL;
+	EC_POINT *ecdsa_pub_key = NULL;
+	size_t ecdsa_publen = 0;
+	char *ecdsa_pub = NULL;
+# endif /* OPENSSL_HAS_ECC */
 #endif /* WITH_OPENSSL */
 
 	if (k == NULL || k->cert == NULL ||
@@ -2972,8 +3167,17 @@ sshkey_certify_custom(struct sshkey *k, struct sshkey *ca, const char *alg,
 	switch (k->type) {
 #ifdef WITH_OPENSSL
 	case KEY_DSA_CERT:
-		DSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);
-		DSA_get0_key(k->dsa, &dsa_pub_key, NULL);
+		if (EVP_PKEY_get_bn_param(k->dsa,
+				OSSL_PKEY_PARAM_FFC_P, &dsa_p) == 0 ||
+		    EVP_PKEY_get_bn_param(k->dsa,
+			    	OSSL_PKEY_PARAM_FFC_Q, &dsa_q) == 0 ||
+		    EVP_PKEY_get_bn_param(k->dsa,
+			    	OSSL_PKEY_PARAM_FFC_G, &dsa_g) == 0 ||
+		    EVP_PKEY_get_bn_param(k->dsa,
+			    	OSSL_PKEY_PARAM_PUB_KEY, &dsa_pub_key) == 0) {
+			ret = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
 		if ((ret = sshbuf_put_bignum2(cert, dsa_p)) != 0 ||
 		    (ret = sshbuf_put_bignum2(cert, dsa_q)) != 0 ||
 		    (ret = sshbuf_put_bignum2(cert, dsa_g)) != 0 ||
@@ -2983,11 +3187,39 @@ sshkey_certify_custom(struct sshkey *k, struct sshkey *ca, const char *alg,
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA_CERT:
 	case KEY_ECDSA_SK_CERT:
+		if ((ecdsa_group = EC_GROUP_new_by_curve_name(k->ecdsa_nid))
+		    == NULL) {
+			ret = SSH_ERR_EC_CURVE_INVALID;
+			goto out;
+		}
+		if (EVP_PKEY_get_octet_string_param(k->ecdsa,
+				OSSL_PKEY_PARAM_PUB_KEY, NULL, 0,
+				&ecdsa_publen) == 0) {
+			ret = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		if ((ecdsa_pub = malloc(ecdsa_publen)) == NULL) {
+			ret = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+		if (EVP_PKEY_get_octet_string_param(k->ecdsa,
+				OSSL_PKEY_PARAM_PUB_KEY, ecdsa_pub,
+				ecdsa_publen, NULL) == 0) {
+			ret = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		if ((ecdsa_pub_key = EC_POINT_new(ecdsa_group)) == NULL) {
+			ret = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+		if (EC_POINT_oct2point(ecdsa_group, ecdsa_pub_key, ecdsa_pub,
+				ecdsa_publen, NULL) == 0) {
+			ret = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
 		if ((ret = sshbuf_put_cstring(cert,
 		    sshkey_curve_nid_to_name(k->ecdsa_nid))) != 0 ||
-		    (ret = sshbuf_put_ec(cert,
-		    EC_KEY_get0_public_key(k->ecdsa),
-		    EC_KEY_get0_group(k->ecdsa))) != 0)
+		    (ret = sshbuf_put_ec(cert, ecdsa_pub_key, ecdsa_group)) != 0)
 			goto out;
 		if (k->type == KEY_ECDSA_SK_CERT) {
 			if ((ret = sshbuf_put_cstring(cert,
@@ -2997,7 +3229,13 @@ sshkey_certify_custom(struct sshkey *k, struct sshkey *ca, const char *alg,
 		break;
 # endif /* OPENSSL_HAS_ECC */
 	case KEY_RSA_CERT:
-		RSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);
+		if (EVP_PKEY_get_bn_param(k->rsa,
+				OSSL_PKEY_PARAM_RSA_N, &rsa_n) == 0 ||
+			EVP_PKEY_get_bn_param(k->rsa,
+				OSSL_PKEY_PARAM_RSA_E, &rsa_e) == 0) {
+			ret = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
 		if ((ret = sshbuf_put_bignum2(cert, rsa_e)) != 0 ||
 		    (ret = sshbuf_put_bignum2(cert, rsa_n)) != 0)
 			goto out;
@@ -3080,6 +3318,19 @@ sshkey_certify_custom(struct sshkey *k, struct sshkey *ca, const char *alg,
 	free(ca_blob);
 	free(sigtype);
 	sshbuf_free(principals);
+#ifdef WITH_OPENSSL
+	BN_clear_free(rsa_n);
+	BN_clear_free(rsa_e);
+	BN_clear_free(dsa_p);
+	BN_clear_free(dsa_q);
+	BN_clear_free(dsa_g);
+	BN_clear_free(dsa_pub_key);
+# ifdef OPENSSL_HAS_ECC
+	EC_GROUP_free(ecdsa_group);
+	EC_POINT_clear_free(ecdsa_pub_key);
+	free(ecdsa_pub);
+# endif
+#endif
 	return ret;
 }
 
@@ -3234,8 +3485,17 @@ sshkey_private_serialize_opt(struct sshkey *key, struct sshbuf *buf,
 	int was_shielded = sshkey_is_shielded(key);
 	struct sshbuf *b = NULL;
 #ifdef WITH_OPENSSL
-	const BIGNUM *rsa_n, *rsa_e, *rsa_d, *rsa_iqmp, *rsa_p, *rsa_q;
-	const BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key, *dsa_priv_key;
+	BIGNUM *rsa_n = NULL, *rsa_e = NULL, *rsa_d = NULL;
+	BIGNUM *rsa_iqmp = NULL, *rsa_p = NULL, *rsa_q = NULL;
+	BIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL;
+	BIGNUM *dsa_pub_key = NULL, *dsa_priv_key = NULL;
+# ifdef OPENSSL_HAS_ECC
+	EC_GROUP *ecdsa_group = NULL;
+	EC_POINT *ecdsa_point = NULL;
+	size_t ecdsa_publen = 0;
+	char *ecdsa_pub = NULL;
+	BIGNUM *ecdsa_priv_key = NULL;
+# endif /* OPENSSL_HAS_ECC */
 #endif /* WITH_OPENSSL */
 
 	if ((r = sshkey_unshield_private(key)) != 0)
@@ -3247,9 +3507,21 @@ sshkey_private_serialize_opt(struct sshkey *key, struct sshbuf *buf,
 	switch (key->type) {
 #ifdef WITH_OPENSSL
 	case KEY_RSA:
-		RSA_get0_key(key->rsa, &rsa_n, &rsa_e, &rsa_d);
-		RSA_get0_factors(key->rsa, &rsa_p, &rsa_q);
-		RSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);
+		if (EVP_PKEY_get_bn_param(key->rsa, OSSL_PKEY_PARAM_RSA_N,
+		    &rsa_n) == 0 ||
+		    EVP_PKEY_get_bn_param(key->rsa, OSSL_PKEY_PARAM_RSA_E,
+		    &rsa_e) == 0 ||
+		    EVP_PKEY_get_bn_param(key->rsa, OSSL_PKEY_PARAM_RSA_D,
+		    &rsa_d) == 0 ||
+		    EVP_PKEY_get_bn_param(key->rsa, OSSL_PKEY_PARAM_RSA_FACTOR1,
+		    &rsa_p) == 0 ||
+		    EVP_PKEY_get_bn_param(key->rsa, OSSL_PKEY_PARAM_RSA_FACTOR2,
+		    &rsa_q) == 0 ||
+		    EVP_PKEY_get_bn_param(key->rsa, OSSL_PKEY_PARAM_RSA_COEFFICIENT1,
+		    &rsa_iqmp) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
 		if ((r = sshbuf_put_bignum2(b, rsa_n)) != 0 ||
 		    (r = sshbuf_put_bignum2(b, rsa_e)) != 0 ||
 		    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||
@@ -3263,9 +3535,17 @@ sshkey_private_serialize_opt(struct sshkey *key, struct sshbuf *buf,
 			r = SSH_ERR_INVALID_ARGUMENT;
 			goto out;
 		}
-		RSA_get0_key(key->rsa, NULL, NULL, &rsa_d);
-		RSA_get0_factors(key->rsa, &rsa_p, &rsa_q);
-		RSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);
+		if (EVP_PKEY_get_bn_param(key->rsa, OSSL_PKEY_PARAM_RSA_D,
+		    &rsa_d) == 0 ||
+		    EVP_PKEY_get_bn_param(key->rsa, OSSL_PKEY_PARAM_RSA_FACTOR1,
+		    &rsa_p) == 0 ||
+		    EVP_PKEY_get_bn_param(key->rsa, OSSL_PKEY_PARAM_RSA_FACTOR2,
+		    &rsa_q) == 0 ||
+		    EVP_PKEY_get_bn_param(key->rsa, OSSL_PKEY_PARAM_RSA_COEFFICIENT1,
+		    &rsa_iqmp) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
 		if ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||
 		    (r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||
 		    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||
@@ -3274,8 +3554,19 @@ sshkey_private_serialize_opt(struct sshkey *key, struct sshbuf *buf,
 			goto out;
 		break;
 	case KEY_DSA:
-		DSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);
-		DSA_get0_key(key->dsa, &dsa_pub_key, &dsa_priv_key);
+		if (EVP_PKEY_get_bn_param(key->dsa, OSSL_PKEY_PARAM_FFC_P,
+		    &dsa_p) == 0 ||
+		    EVP_PKEY_get_bn_param(key->dsa, OSSL_PKEY_PARAM_FFC_Q,
+		    &dsa_q) == 0 ||
+		    EVP_PKEY_get_bn_param(key->dsa, OSSL_PKEY_PARAM_FFC_G,
+		    &dsa_g) == 0 ||
+		    EVP_PKEY_get_bn_param(key->dsa, OSSL_PKEY_PARAM_PUB_KEY,
+		    &dsa_pub_key) == 0 ||
+		    EVP_PKEY_get_bn_param(key->dsa, OSSL_PKEY_PARAM_PRIV_KEY,
+		    &dsa_priv_key) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
 		if ((r = sshbuf_put_bignum2(b, dsa_p)) != 0 ||
 		    (r = sshbuf_put_bignum2(b, dsa_q)) != 0 ||
 		    (r = sshbuf_put_bignum2(b, dsa_g)) != 0 ||
@@ -3288,18 +3579,56 @@ sshkey_private_serialize_opt(struct sshkey *key, struct sshbuf *buf,
 			r = SSH_ERR_INVALID_ARGUMENT;
 			goto out;
 		}
-		DSA_get0_key(key->dsa, NULL, &dsa_priv_key);
+		if (EVP_PKEY_get_bn_param(key->dsa, OSSL_PKEY_PARAM_PRIV_KEY,
+		    &dsa_priv_key) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
 		if ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||
 		    (r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)
 			goto out;
 		break;
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA:
+		if ((ecdsa_group = EC_GROUP_new_by_curve_name(key->ecdsa_nid))
+		    == NULL) {
+			r = SSH_ERR_EC_CURVE_INVALID;
+			goto out;
+		}
+		if (EVP_PKEY_get_octet_string_param(key->ecdsa,
+				OSSL_PKEY_PARAM_PUB_KEY, NULL, 0,
+				&ecdsa_publen) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		if ((ecdsa_pub = malloc(ecdsa_publen)) == NULL) {
+			r = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+		if (EVP_PKEY_get_octet_string_param(key->ecdsa,
+				OSSL_PKEY_PARAM_PUB_KEY, ecdsa_pub,
+				ecdsa_publen, NULL) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		if ((ecdsa_point = EC_POINT_new(ecdsa_group)) == NULL) {
+			r = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+		if (EC_POINT_oct2point(ecdsa_group, ecdsa_point, ecdsa_pub,
+				ecdsa_publen, NULL) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		if (EVP_PKEY_get_bn_param(key->ecdsa,
+				OSSL_PKEY_PARAM_PRIV_KEY, &ecdsa_priv_key) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
 		if ((r = sshbuf_put_cstring(b,
 		    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||
-		    (r = sshbuf_put_eckey(b, key->ecdsa)) != 0 ||
-		    (r = sshbuf_put_bignum2(b,
-		    EC_KEY_get0_private_key(key->ecdsa))) != 0)
+		    (r = sshbuf_put_ec(b, ecdsa_point, ecdsa_group)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, ecdsa_priv_key)) != 0)
 			goto out;
 		break;
 	case KEY_ECDSA_CERT:
@@ -3307,9 +3636,13 @@ sshkey_private_serialize_opt(struct sshkey *key, struct sshbuf *buf,
 			r = SSH_ERR_INVALID_ARGUMENT;
 			goto out;
 		}
+		if (EVP_PKEY_get_bn_param(key->ecdsa,
+				OSSL_PKEY_PARAM_PRIV_KEY, &ecdsa_priv_key) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
 		if ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||
-		    (r = sshbuf_put_bignum2(b,
-		    EC_KEY_get0_private_key(key->ecdsa))) != 0)
+		    (r = sshbuf_put_bignum2(b, ecdsa_priv_key)) != 0)
 			goto out;
 		break;
 	case KEY_ECDSA_SK:
@@ -3423,6 +3756,25 @@ sshkey_private_serialize_opt(struct sshkey *key, struct sshbuf *buf,
 	if (r == 0)
 		r = sshbuf_putb(buf, b);
 	sshbuf_free(b);
+#ifdef WITH_OPENSSL
+	BN_clear_free(rsa_n);
+       	BN_clear_free(rsa_e);
+       	BN_clear_free(rsa_d);
+	BN_clear_free(rsa_iqmp);
+       	BN_clear_free(rsa_p);
+       	BN_clear_free(rsa_q);
+	BN_clear_free(dsa_p);
+       	BN_clear_free(dsa_q);
+       	BN_clear_free(dsa_g);
+	BN_clear_free(dsa_pub_key);
+       	BN_clear_free(dsa_priv_key);
+# ifdef OPENSSL_HAS_ECC
+	EC_GROUP_free(ecdsa_group);
+	EC_POINT_clear_free(ecdsa_point);
+	free(ecdsa_pub);
+	BN_clear_free(ecdsa_priv_key);
+# endif /* OPENSSL_HAS_ECC */
+#endif /* WITH_OPENSSL */
 
 	return r;
 }
@@ -3446,11 +3798,21 @@ sshkey_private_deserialize(struct sshbuf *buf, struct sshkey **kp)
 	u_char *expect_ed25519_pk = NULL;
 	u_char *xmss_pk = NULL, *xmss_sk = NULL;
 #ifdef WITH_OPENSSL
+	OSSL_PARAM_BLD *bld = NULL;
+	OSSL_PARAM *params = NULL;
+	EVP_PKEY_CTX *pctx = NULL;
 	BIGNUM *exponent = NULL;
 	BIGNUM *rsa_n = NULL, *rsa_e = NULL, *rsa_d = NULL;
 	BIGNUM *rsa_iqmp = NULL, *rsa_p = NULL, *rsa_q = NULL;
+	BIGNUM *rsa_dmp1 = NULL, *rsa_dmq1 = NULL;
 	BIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL;
 	BIGNUM *dsa_pub_key = NULL, *dsa_priv_key = NULL;
+# ifdef OPENSSL_HAS_ECC
+	EC_GROUP *ecdsa_group = NULL;
+	EC_POINT *ecdsa_q = NULL;
+	size_t ecdsa_publen = 0;
+	char *ecdsa_pub_key = NULL;
+# endif /* OPENSSL_HAS_ECC */
 #endif /* WITH_OPENSSL */
 
 	if (kp != NULL)
@@ -3493,61 +3855,157 @@ sshkey_private_deserialize(struct sshbuf *buf, struct sshkey **kp)
 	switch (type) {
 #ifdef WITH_OPENSSL
 	case KEY_DSA:
-		if ((r = sshbuf_get_bignum2(buf, &dsa_p)) != 0 ||
-		    (r = sshbuf_get_bignum2(buf, &dsa_q)) != 0 ||
-		    (r = sshbuf_get_bignum2(buf, &dsa_g)) != 0 ||
-		    (r = sshbuf_get_bignum2(buf, &dsa_pub_key)) != 0)
-			goto out;
-		if (!DSA_set0_pqg(k->dsa, dsa_p, dsa_q, dsa_g)) {
+	case KEY_DSA_CERT:
+		if (type == KEY_DSA) {
+			if ((r = sshbuf_get_bignum2(buf, &dsa_p)) != 0 ||
+			    (r = sshbuf_get_bignum2(buf, &dsa_q)) != 0 ||
+			    (r = sshbuf_get_bignum2(buf, &dsa_g)) != 0 ||
+			    (r = sshbuf_get_bignum2(buf, &dsa_pub_key)) != 0 ||
+			    (r = sshbuf_get_bignum2(buf, &dsa_priv_key)) != 0)
+				goto out;
+		} else {
+			if (EVP_PKEY_get_bn_param(k->dsa,
+				    OSSL_PKEY_PARAM_FFC_P, &dsa_p) == 0 ||
+			    EVP_PKEY_get_bn_param(k->dsa,
+				    OSSL_PKEY_PARAM_FFC_Q, &dsa_q) == 0 ||
+			    EVP_PKEY_get_bn_param(k->dsa,
+				    OSSL_PKEY_PARAM_FFC_G, &dsa_g) == 0 ||
+			    EVP_PKEY_get_bn_param(k->dsa,
+				    OSSL_PKEY_PARAM_PUB_KEY, &dsa_pub_key) == 0) {
+				r = SSH_ERR_LIBCRYPTO_ERROR;
+				goto out;
+			}
+			EVP_PKEY_free(k->dsa);
+			if ((r = sshbuf_get_bignum2(buf, &dsa_priv_key)) != 0)
+				goto out;
+		}
+
+		bld = OSSL_PARAM_BLD_new();
+		if (bld == NULL ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+			    OSSL_PKEY_PARAM_FFC_P, dsa_p) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+			    OSSL_PKEY_PARAM_FFC_Q, dsa_q) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+			    OSSL_PKEY_PARAM_FFC_G, dsa_g) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+			    OSSL_PKEY_PARAM_PUB_KEY, dsa_pub_key) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+			    OSSL_PKEY_PARAM_PRIV_KEY, dsa_priv_key) == 0) {
 			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
-		dsa_p = dsa_q = dsa_g = NULL; /* transferred */
-		if (!DSA_set0_key(k->dsa, dsa_pub_key, NULL)) {
+
+		params = OSSL_PARAM_BLD_to_param(bld);
+		if (params == NULL) {
 			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
-		dsa_pub_key = NULL; /* transferred */
-		/* FALLTHROUGH */
-	case KEY_DSA_CERT:
-		if ((r = sshbuf_get_bignum2(buf, &dsa_priv_key)) != 0)
-			goto out;
-		if (!DSA_set0_key(k->dsa, NULL, dsa_priv_key)) {
+
+		pctx = EVP_PKEY_CTX_new_from_name(NULL, "DSA", NULL);
+		if (pctx == NULL || EVP_PKEY_fromdata_init(pctx) <= 0 ||
+		    EVP_PKEY_fromdata(pctx, &k->dsa,
+			    EVP_PKEY_KEYPAIR, params) <= 0) {
 			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
-		dsa_priv_key = NULL; /* transferred */
 		break;
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA:
-		if ((k->ecdsa_nid = sshkey_ecdsa_nid_from_name(tname)) == -1) {
-			r = SSH_ERR_INVALID_ARGUMENT;
-			goto out;
+	case KEY_ECDSA_CERT:
+		if (type == KEY_ECDSA) {
+			if ((k->ecdsa_nid = sshkey_ecdsa_nid_from_name(tname))
+			     == -1) {
+				r = SSH_ERR_INVALID_ARGUMENT;
+				goto out;
+			}
+			if ((r = sshbuf_get_cstring(buf, &curve, NULL)) != 0)
+				goto out;
+			if (k->ecdsa_nid != sshkey_curve_name_to_nid(curve)) {
+				r = SSH_ERR_EC_CURVE_MISMATCH;
+				goto out;
+			}
+			if ((ecdsa_group = EC_GROUP_new_by_curve_name(
+			    k->ecdsa_nid)) == NULL) {
+				r = SSH_ERR_EC_CURVE_INVALID;
+				goto out;
+			}
+			if ((ecdsa_q = EC_POINT_new(ecdsa_group)) == NULL) {
+				r = SSH_ERR_ALLOC_FAIL;
+				goto out;
+			}
+			if (sshbuf_get_ec(buf, ecdsa_q, ecdsa_group) != 0) {
+				r = SSH_ERR_INVALID_FORMAT;
+				goto out;
+			}
+			if (sshkey_ec_validate_public(ecdsa_group,
+			    ecdsa_q) != 0) {
+				r = SSH_ERR_KEY_INVALID_EC_VALUE;
+				goto out;
+			}
+			ecdsa_publen = EC_POINT_point2oct(ecdsa_group, ecdsa_q,
+				POINT_CONVERSION_UNCOMPRESSED, NULL, 0, NULL);
+			if ((ecdsa_pub_key = malloc(ecdsa_publen)) == NULL) {
+				r = SSH_ERR_ALLOC_FAIL;
+				goto out;
+			}
+			if (EC_POINT_point2oct(ecdsa_group, ecdsa_q,
+			    POINT_CONVERSION_UNCOMPRESSED,
+			    ecdsa_pub_key, ecdsa_publen, NULL) == 0) {
+				r = SSH_ERR_LIBCRYPTO_ERROR;
+				goto out;
+			}
+		} else {
+			if (EVP_PKEY_get_octet_string_param(k->ecdsa,
+			    OSSL_PKEY_PARAM_PUB_KEY, NULL, 0, &ecdsa_publen)
+			    == 0) {
+				r = SSH_ERR_LIBCRYPTO_ERROR;
+				goto out;
+			}
+			if ((ecdsa_pub_key = malloc(ecdsa_publen)) == NULL) {
+				r = SSH_ERR_ALLOC_FAIL;
+				goto out;
+			}
+			if (EVP_PKEY_get_octet_string_param(k->ecdsa,
+			    OSSL_PKEY_PARAM_PUB_KEY, ecdsa_pub_key,
+			    ecdsa_publen, NULL) == 0) {
+				r = SSH_ERR_LIBCRYPTO_ERROR;
+				goto out;
+			}
+			EVP_PKEY_free(k->ecdsa);
 		}
-		if ((r = sshbuf_get_cstring(buf, &curve, NULL)) != 0)
+		if ((r = sshbuf_get_bignum2(buf, &exponent)) != 0)
 			goto out;
-		if (k->ecdsa_nid != sshkey_curve_name_to_nid(curve)) {
-			r = SSH_ERR_EC_CURVE_MISMATCH;
+
+		bld = OSSL_PARAM_BLD_new();
+		if (bld == NULL) {
+			r = SSH_ERR_ALLOC_FAIL;
 			goto out;
 		}
-		k->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);
-		if (k->ecdsa  == NULL) {
+		if (OSSL_PARAM_BLD_push_utf8_string(bld,
+		    OSSL_PKEY_PARAM_GROUP_NAME, OBJ_nid2sn(k->ecdsa_nid), 0)
+		    == 0 ||
+		    OSSL_PARAM_BLD_push_octet_string(bld,
+		    OSSL_PKEY_PARAM_PUB_KEY, ecdsa_pub_key, ecdsa_publen)
+		    == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+		    OSSL_PKEY_PARAM_PRIV_KEY, exponent) == 0) {
 			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
-		if ((r = sshbuf_get_eckey(buf, k->ecdsa)) != 0)
-			goto out;
-		/* FALLTHROUGH */
-	case KEY_ECDSA_CERT:
-		if ((r = sshbuf_get_bignum2(buf, &exponent)) != 0)
+		params = OSSL_PARAM_BLD_to_param(bld);
+		if (params == NULL) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
-		if (EC_KEY_set_private_key(k->ecdsa, exponent) != 1) {
+		}
+		pctx = EVP_PKEY_CTX_new_from_name(NULL, "EC", NULL);
+		if (pctx == NULL || EVP_PKEY_fromdata_init(pctx) <= 0 ||
+				EVP_PKEY_fromdata(pctx, &k->ecdsa,
+					EVP_PKEY_KEYPAIR, params) <= 0) {
 			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
-		if ((r = sshkey_ec_validate_public(EC_KEY_get0_group(k->ecdsa),
-		    EC_KEY_get0_public_key(k->ecdsa))) != 0 ||
-		    (r = sshkey_ec_validate_private(k->ecdsa)) != 0)
+		if ((r = sshkey_ec_validate_private(k->ecdsa)) != 0)
 			goto out;
 		break;
 	case KEY_ECDSA_SK:
@@ -3566,21 +4024,67 @@ sshkey_private_deserialize(struct sshbuf *buf, struct sshkey **kp)
 			r = SSH_ERR_ALLOC_FAIL;
 			goto out;
 		}
-		k->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);
-		if (k->ecdsa  == NULL) {
+		if ((ecdsa_group = EC_GROUP_new_by_curve_name(
+		    k->ecdsa_nid)) == NULL) {
+			r = SSH_ERR_EC_CURVE_INVALID;
+			goto out;
+		}
+		if ((ecdsa_q = EC_POINT_new(ecdsa_group)) == NULL) {
+			r = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+		if (sshbuf_get_ec(buf, ecdsa_q, ecdsa_group) != 0) {
+			r = SSH_ERR_INVALID_FORMAT;
+			goto out;
+		}
+		if (sshkey_ec_validate_public(ecdsa_group, ecdsa_q) != 0) {
+			r = SSH_ERR_KEY_INVALID_EC_VALUE;
+			goto out;
+		}
+		ecdsa_publen = EC_POINT_point2oct(ecdsa_group, ecdsa_q,
+			POINT_CONVERSION_UNCOMPRESSED, NULL, 0, NULL);
+		if ((ecdsa_pub_key = malloc(ecdsa_publen)) == NULL) {
+			r = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+		if (EC_POINT_point2oct(ecdsa_group, ecdsa_q,
+		    POINT_CONVERSION_UNCOMPRESSED,
+		    ecdsa_pub_key, ecdsa_publen, NULL) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		bld = OSSL_PARAM_BLD_new();
+		if (bld == NULL) {
+			r = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+		if (OSSL_PARAM_BLD_push_utf8_string(bld,
+		    OSSL_PKEY_PARAM_GROUP_NAME, OBJ_nid2sn(k->ecdsa_nid), 0)
+		    == 0 ||
+		    OSSL_PARAM_BLD_push_octet_string(bld,
+		    OSSL_PKEY_PARAM_PUB_KEY, ecdsa_pub_key, ecdsa_publen)
+		    == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		params = OSSL_PARAM_BLD_to_param(bld);
+		if (params == NULL) {
 			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
-		if ((r = sshbuf_get_eckey(buf, k->ecdsa)) != 0 ||
-		    (r = sshbuf_get_cstring(buf, &k->sk_application,
+		pctx = EVP_PKEY_CTX_new_from_name(NULL, "EC", NULL);
+		if (pctx == NULL || EVP_PKEY_fromdata_init(pctx) <= 0 ||
+		    EVP_PKEY_fromdata(pctx, &k->ecdsa, EVP_PKEY_PUBLIC_KEY,
+			    params) <= 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		if ((r = sshbuf_get_cstring(buf, &k->sk_application,
 		    NULL)) != 0 ||
 		    (r = sshbuf_get_u8(buf, &k->sk_flags)) != 0 ||
 		    (r = sshbuf_get_stringb(buf, k->sk_key_handle)) != 0 ||
 		    (r = sshbuf_get_stringb(buf, k->sk_reserved)) != 0)
 			goto out;
-		if ((r = sshkey_ec_validate_public(EC_KEY_get0_group(k->ecdsa),
-		    EC_KEY_get0_public_key(k->ecdsa))) != 0)
-			goto out;
 		break;
 	case KEY_ECDSA_SK_CERT:
 		if ((k->sk_key_handle = sshbuf_new()) == NULL ||
@@ -3594,40 +4098,68 @@ sshkey_private_deserialize(struct sshbuf *buf, struct sshkey **kp)
 		    (r = sshbuf_get_stringb(buf, k->sk_key_handle)) != 0 ||
 		    (r = sshbuf_get_stringb(buf, k->sk_reserved)) != 0)
 			goto out;
-		if ((r = sshkey_ec_validate_public(EC_KEY_get0_group(k->ecdsa),
-		    EC_KEY_get0_public_key(k->ecdsa))) != 0)
-			goto out;
 		break;
 # endif /* OPENSSL_HAS_ECC */
 	case KEY_RSA:
-		if ((r = sshbuf_get_bignum2(buf, &rsa_n)) != 0 ||
-		    (r = sshbuf_get_bignum2(buf, &rsa_e)) != 0)
-			goto out;
-		if (!RSA_set0_key(k->rsa, rsa_n, rsa_e, NULL)) {
-			r = SSH_ERR_LIBCRYPTO_ERROR;
-			goto out;
-		}
-		rsa_n = rsa_e = NULL; /* transferred */
-		/* FALLTHROUGH */
 	case KEY_RSA_CERT:
+		if (type == KEY_RSA) {
+			if ((r = sshbuf_get_bignum2(buf, &rsa_n)) != 0 ||
+			    (r = sshbuf_get_bignum2(buf, &rsa_e)) != 0)
+				goto out;
+		} else {
+			if (EVP_PKEY_get_bn_param(k->rsa,
+				    OSSL_PKEY_PARAM_RSA_N, &rsa_n) == 0 ||
+			    EVP_PKEY_get_bn_param(k->rsa,
+				    OSSL_PKEY_PARAM_RSA_E, &rsa_e) == 0) {
+				goto out;
+			}
+			EVP_PKEY_free(k->rsa);
+		}
 		if ((r = sshbuf_get_bignum2(buf, &rsa_d)) != 0 ||
 		    (r = sshbuf_get_bignum2(buf, &rsa_iqmp)) != 0 ||
 		    (r = sshbuf_get_bignum2(buf, &rsa_p)) != 0 ||
 		    (r = sshbuf_get_bignum2(buf, &rsa_q)) != 0)
 			goto out;
-		if (!RSA_set0_key(k->rsa, NULL, NULL, rsa_d)) {
+		if ((r = ssh_rsa_complete_crt_parameters(rsa_p, rsa_q, rsa_d,
+		    &rsa_dmp1, &rsa_dmq1)) != 0)
+			goto out;
+
+		bld = OSSL_PARAM_BLD_new();
+		if (bld == NULL ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+			    OSSL_PKEY_PARAM_RSA_N, rsa_n) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+			    OSSL_PKEY_PARAM_RSA_E, rsa_e) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+			    OSSL_PKEY_PARAM_RSA_D, rsa_d) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+			    OSSL_PKEY_PARAM_RSA_COEFFICIENT1, rsa_iqmp) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+			    OSSL_PKEY_PARAM_RSA_FACTOR1, rsa_p) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+			    OSSL_PKEY_PARAM_RSA_FACTOR2, rsa_q) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+			    OSSL_PKEY_PARAM_RSA_EXPONENT1, rsa_dmp1) == 0 ||
+		    OSSL_PARAM_BLD_push_BN(bld,
+			    OSSL_PKEY_PARAM_RSA_EXPONENT2, rsa_dmq1) == 0) {
 			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
-		rsa_d = NULL; /* transferred */
-		if (!RSA_set0_factors(k->rsa, rsa_p, rsa_q)) {
+
+		params = OSSL_PARAM_BLD_to_param(bld);
+		if (params == NULL) {
 			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
-		rsa_p = rsa_q = NULL; /* transferred */
-		if ((r = check_rsa_length(k->rsa)) != 0)
+
+		pctx = EVP_PKEY_CTX_new_from_name(NULL, "RSA", NULL);
+		if (pctx == NULL || EVP_PKEY_fromdata_init(pctx) <= 0 ||
+		    EVP_PKEY_fromdata(pctx, &k->rsa,
+			    EVP_PKEY_KEYPAIR, params) <= 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
-		if ((r = ssh_rsa_complete_crt_parameters(k, rsa_iqmp)) != 0)
+		}
+		if ((r = check_rsa_length(k->rsa)) != 0)
 			goto out;
 		break;
 #endif /* WITH_OPENSSL */
@@ -3693,11 +4225,12 @@ sshkey_private_deserialize(struct sshbuf *buf, struct sshkey **kp)
 		r = SSH_ERR_KEY_TYPE_UNKNOWN;
 		goto out;
 	}
-#ifdef WITH_OPENSSL
+#if defined(WITH_OPENSSL) && OPENSSL_VERSION_NUMBER < 0x30000000L
 	/* enable blinding */
 	switch (k->type) {
 	case KEY_RSA:
 	case KEY_RSA_CERT:
+		//XXX(ossl3): hoist into legacy compat layer
 		if (RSA_blinding_on(k->rsa, NULL) != 1) {
 			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
@@ -3734,6 +4267,16 @@ sshkey_private_deserialize(struct sshbuf *buf, struct sshkey **kp)
 	BN_clear_free(rsa_p);
 	BN_clear_free(rsa_q);
 	BN_clear_free(rsa_iqmp);
+	BN_clear_free(rsa_dmp1);
+	BN_clear_free(rsa_dmq1);
+# ifdef OPENSSL_HAS_ECC
+	EC_GROUP_free(ecdsa_group);
+	EC_POINT_free(ecdsa_q);
+	free(ecdsa_pub_key);
+# endif /* OPENSSL_HAS_ECC */
+	EVP_PKEY_CTX_free(pctx);
+	OSSL_PARAM_free(params);
+	OSSL_PARAM_BLD_free(bld);
 #endif /* WITH_OPENSSL */
 	sshkey_free(k);
 	freezero(ed25519_pk, pklen);
@@ -3766,8 +4309,7 @@ sshkey_ec_validate_public(const EC_GROUP *group, const EC_POINT *public)
 	 * We shouldn't ever hit this case because bignum_get_ecpoint()
 	 * refuses to load GF2m points.
 	 */
-	if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=
-	    NID_X9_62_prime_field)
+	if (EC_GROUP_get_field_type(group) != NID_X9_62_prime_field)
 		goto out;
 
 	/* Q != infinity */
@@ -3784,7 +4326,7 @@ sshkey_ec_validate_public(const EC_GROUP *group, const EC_POINT *public)
 
 	/* log2(x) > log2(order)/2, log2(y) > log2(order)/2 */
 	if (EC_GROUP_get_order(group, order, NULL) != 1 ||
-	    EC_POINT_get_affine_coordinates_GFp(group, public,
+	    EC_POINT_get_affine_coordinates(group, public,
 	    x, y, NULL) != 1) {
 		ret = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
@@ -3823,23 +4365,51 @@ sshkey_ec_validate_public(const EC_GROUP *group, const EC_POINT *public)
 }
 
 int
-sshkey_ec_validate_private(const EC_KEY *key)
+sshkey_ec_validate_private(const EVP_PKEY *key)
 {
-	BIGNUM *order = NULL, *tmp = NULL;
+	EC_GROUP *group = NULL;
+	BIGNUM *order = NULL, *tmp = NULL, *priv = NULL;
+	char *curve = NULL;
+	size_t curve_len = 0;
+	int nid = -1;
 	int ret = SSH_ERR_KEY_INVALID_EC_VALUE;
 
 	if ((order = BN_new()) == NULL || (tmp = BN_new()) == NULL) {
 		ret = SSH_ERR_ALLOC_FAIL;
 		goto out;
 	}
+	if (EVP_PKEY_get_utf8_string_param(key, OSSL_PKEY_PARAM_GROUP_NAME,
+	    NULL, 0, &curve_len) == 0) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if ((curve = malloc(curve_len + 1)) == NULL) {
+		ret = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	if (EVP_PKEY_get_utf8_string_param(key, OSSL_PKEY_PARAM_GROUP_NAME,
+	    curve, curve_len + 1, NULL) == 0) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	if ((nid = OBJ_sn2nid(curve)) == NID_undef) {
+		goto out;
+	}
+	if ((group = EC_GROUP_new_by_curve_name(nid)) == NULL) {
+		ret = SSH_ERR_EC_CURVE_INVALID;
+		goto out;
+	}
+	if (EVP_PKEY_get_bn_param(key, OSSL_PKEY_PARAM_PRIV_KEY, &priv) == 0) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
 
 	/* log2(private) > log2(order)/2 */
-	if (EC_GROUP_get_order(EC_KEY_get0_group(key), order, NULL) != 1) {
+	if (EC_GROUP_get_order(group, order, NULL) != 1) {
 		ret = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
 	}
-	if (BN_num_bits(EC_KEY_get0_private_key(key)) <=
-	    BN_num_bits(order) / 2)
+	if (BN_num_bits(priv) <= BN_num_bits(order) / 2)
 		goto out;
 
 	/* private < order - 1 */
@@ -3847,12 +4417,15 @@ sshkey_ec_validate_private(const EC_KEY *key)
 		ret = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
 	}
-	if (BN_cmp(EC_KEY_get0_private_key(key), tmp) >= 0)
+	if (BN_cmp(priv, tmp) >= 0)
 		goto out;
 	ret = 0;
  out:
+	free(curve);
+	EC_GROUP_free(group);
 	BN_clear_free(order);
 	BN_clear_free(tmp);
+	BN_clear_free(priv);
 	return ret;
 }
 
@@ -3869,14 +4442,12 @@ sshkey_dump_ec_point(const EC_GROUP *group, const EC_POINT *point)
 		fprintf(stderr, "%s: BN_new failed\n", __func__);
 		goto out;
 	}
-	if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=
-	    NID_X9_62_prime_field) {
+	if (EC_GROUP_get_field_type(group) != NID_X9_62_prime_field) {
 		fprintf(stderr, "%s: group is not a prime field\n", __func__);
 		goto out;
 	}
-	if (EC_POINT_get_affine_coordinates_GFp(group, point,
-	    x, y, NULL) != 1) {
-		fprintf(stderr, "%s: EC_POINT_get_affine_coordinates_GFp\n",
+	if (EC_POINT_get_affine_coordinates(group, point, x, y, NULL) != 1) {
+		fprintf(stderr, "%s: EC_POINT_get_affine_coordinates\n",
 		    __func__);
 		goto out;
 	}
@@ -3891,18 +4462,53 @@ sshkey_dump_ec_point(const EC_GROUP *group, const EC_POINT *point)
 }
 
 void
-sshkey_dump_ec_key(const EC_KEY *key)
+sshkey_dump_ec_key(const EVP_PKEY *key)
 {
-	const BIGNUM *exponent;
+	EC_GROUP *group = NULL;
+	EC_POINT *point = NULL;
+	BIGNUM *exponent = NULL;
+	int nid = -1;
+	char *curve = NULL, *pub = NULL;
+	size_t curve_len = 0, pub_len = 0;
 
-	sshkey_dump_ec_point(EC_KEY_get0_group(key),
-	    EC_KEY_get0_public_key(key));
+	if (EVP_PKEY_get_utf8_string_param(key, OSSL_PKEY_PARAM_GROUP_NAME,
+	    NULL, 0, &curve_len) == 0)
+		goto out;
+	if ((curve = malloc(curve_len + 1)) == NULL)
+		goto out;
+	if (EVP_PKEY_get_utf8_string_param(key, OSSL_PKEY_PARAM_GROUP_NAME,
+	    curve, curve_len + 1, NULL) == 0)
+		goto out;
+	if (EVP_PKEY_get_octet_string_param(key, OSSL_PKEY_PARAM_PUB_KEY,
+	    NULL, 0, &pub_len) == 0)
+		goto out;
+	if ((pub = malloc(pub_len)) == NULL)
+		goto out;
+	if (EVP_PKEY_get_octet_string_param(key, OSSL_PKEY_PARAM_PUB_KEY,
+	    pub, pub_len, NULL) == 0)
+		goto out;
+	if ((nid = OBJ_sn2nid(curve)) == NID_undef)
+		goto out;
+	if ((group = EC_GROUP_new_by_curve_name(nid)) == NULL)
+		goto out;
+	if ((point = EC_POINT_new(group)) == NULL)
+		goto out;
+	if (EC_POINT_oct2point(group, point, pub, pub_len, NULL) == 0)
+		goto out;
+	sshkey_dump_ec_point(group, point);
 	fputs("exponent=", stderr);
-	if ((exponent = EC_KEY_get0_private_key(key)) == NULL)
+	if (EVP_PKEY_get_bn_param(key, OSSL_PKEY_PARAM_PRIV_KEY,
+	    &exponent) == 0 || exponent == NULL)
 		fputs("(NULL)", stderr);
 	else
-		BN_print_fp(stderr, EC_KEY_get0_private_key(key));
+		BN_print_fp(stderr, exponent);
 	fputs("\n", stderr);
+out:
+	EC_GROUP_free(group);
+	EC_POINT_free(point);
+	BN_clear_free(exponent);
+	free(curve);
+	free(pub);
 }
 #endif /* WITH_OPENSSL && OPENSSL_HAS_ECC */
 
@@ -4416,39 +5022,23 @@ sshkey_private_to_blob_pem_pkcs8(struct sshkey *key, struct sshbuf *buf,
 		r = SSH_ERR_ALLOC_FAIL;
 		goto out;
 	}
-	if (format == SSHKEY_PRIVATE_PKCS8 && (pkey = EVP_PKEY_new()) == NULL) {
-		r = SSH_ERR_ALLOC_FAIL;
-		goto out;
-	}
 	if ((r = sshkey_unshield_private(key)) != 0)
 		goto out;
 
 	switch (key->type) {
 	case KEY_DSA:
-		if (format == SSHKEY_PRIVATE_PEM) {
-			success = PEM_write_bio_DSAPrivateKey(bio, key->dsa,
-			    cipher, passphrase, len, NULL, NULL);
-		} else {
-			success = EVP_PKEY_set1_DSA(pkey, key->dsa);
-		}
+		pkey = key->dsa;
+		success = 1;
 		break;
 #ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA:
-		if (format == SSHKEY_PRIVATE_PEM) {
-			success = PEM_write_bio_ECPrivateKey(bio, key->ecdsa,
-			    cipher, passphrase, len, NULL, NULL);
-		} else {
-			success = EVP_PKEY_set1_EC_KEY(pkey, key->ecdsa);
-		}
+		pkey = key->ecdsa;
+		success = 1;
 		break;
 #endif
 	case KEY_RSA:
-		if (format == SSHKEY_PRIVATE_PEM) {
-			success = PEM_write_bio_RSAPrivateKey(bio, key->rsa,
-			    cipher, passphrase, len, NULL, NULL);
-		} else {
-			success = EVP_PKEY_set1_RSA(pkey, key->rsa);
-		}
+		pkey = key->rsa;
+		success = 1;
 		break;
 	default:
 		success = 0;
@@ -4458,12 +5048,24 @@ sshkey_private_to_blob_pem_pkcs8(struct sshkey *key, struct sshbuf *buf,
 		r = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
 	}
-	if (format == SSHKEY_PRIVATE_PKCS8) {
+	switch (format) {
+	case SSHKEY_PRIVATE_PEM:
+		if ((success = PEM_write_bio_PrivateKey_traditional(bio, pkey,
+		    cipher, passphrase, len, NULL, NULL)) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		break;
+	case SSHKEY_PRIVATE_PKCS8:
 		if ((success = PEM_write_bio_PrivateKey(bio, pkey, cipher,
 		    passphrase, len, NULL, NULL)) == 0) {
 			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
+		break;
+	default:
+		r = SSH_ERR_INVALID_ARGUMENT;
+		goto out;
 	}
 	if ((blen = BIO_get_mem_data(bio, &bptr)) <= 0) {
 		r = SSH_ERR_INTERNAL_ERROR;
@@ -4478,7 +5080,6 @@ sshkey_private_to_blob_pem_pkcs8(struct sshkey *key, struct sshbuf *buf,
 	if (r == 0)
 		r = sshbuf_putb(buf, blob);
 
-	EVP_PKEY_free(pkey);
 	sshbuf_free(blob);
 	BIO_free(bio);
 	return r;
@@ -4609,6 +5210,13 @@ sshkey_parse_private_pem_fileblob(struct sshbuf *blob, int type,
 	EVP_PKEY *pk = NULL;
 	struct sshkey *prv = NULL;
 	BIO *bio = NULL;
+#ifdef OPENSSL_HAS_ECC
+	EC_GROUP *group = NULL;
+	EC_POINT *point = NULL;
+	int nid = -1;
+	char *curve = NULL, *pub = NULL;
+	size_t curve_len = 0, pub_len = 0;
+#endif /* OPENSSL_HAS_ECC */
 	int r;
 
 	if (keyp != NULL)
@@ -4643,15 +5251,21 @@ sshkey_parse_private_pem_fileblob(struct sshbuf *blob, int type,
 			r = SSH_ERR_ALLOC_FAIL;
 			goto out;
 		}
-		prv->rsa = EVP_PKEY_get1_RSA(pk);
+		prv->rsa = pk;
+		pk = NULL; /* Transferred */
 		prv->type = KEY_RSA;
 #ifdef DEBUG_PK
-		RSA_print_fp(stderr, prv->rsa, 8);
+		EVP_PKEY_print_public_fp(stderr, prv->rsa, 8, NULL);
+		EVP_PKEY_print_private_fp(stderr, prv->rsa, 8, NULL);
+		EVP_PKEY_print_params_fp(stderr, prv->rsa, 8, NULL);
 #endif
+//XXX(ossl3): hoist somewhere
+#if OPENSSL_VERSION_NUMBER < 0x30000000L
 		if (RSA_blinding_on(prv->rsa, NULL) != 1) {
 			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
+#endif
 		if ((r = check_rsa_length(prv->rsa)) != 0)
 			goto out;
 	} else if (EVP_PKEY_base_id(pk) == EVP_PKEY_DSA &&
@@ -4660,10 +5274,13 @@ sshkey_parse_private_pem_fileblob(struct sshbuf *blob, int type,
 			r = SSH_ERR_ALLOC_FAIL;
 			goto out;
 		}
-		prv->dsa = EVP_PKEY_get1_DSA(pk);
+		prv->dsa = pk;
+		pk = NULL; /* Transferred */
 		prv->type = KEY_DSA;
 #ifdef DEBUG_PK
-		DSA_print_fp(stderr, prv->dsa, 8);
+		EVP_PKEY_print_public_fp(stderr, prv->dsa, 8, NULL);
+		EVP_PKEY_print_private_fp(stderr, prv->dsa, 8, NULL);
+		EVP_PKEY_print_params_fp(stderr, prv->dsa, 8, NULL);
 #endif
 #ifdef OPENSSL_HAS_ECC
 	} else if (EVP_PKEY_base_id(pk) == EVP_PKEY_EC &&
@@ -4672,13 +5289,59 @@ sshkey_parse_private_pem_fileblob(struct sshbuf *blob, int type,
 			r = SSH_ERR_ALLOC_FAIL;
 			goto out;
 		}
-		prv->ecdsa = EVP_PKEY_get1_EC_KEY(pk);
+		//XXX(ossl3): madness, should ec_validate_public take the EVP_PKEY?
+		if (EVP_PKEY_get_utf8_string_param(pk,
+		    OSSL_PKEY_PARAM_GROUP_NAME, NULL, 0, &curve_len) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		if ((curve = malloc(curve_len + 1)) == NULL) {
+			r = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+		if (EVP_PKEY_get_utf8_string_param(pk,
+		    OSSL_PKEY_PARAM_GROUP_NAME, curve, curve_len + 1,
+		    NULL) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		if (EVP_PKEY_get_octet_string_param(pk,
+		    OSSL_PKEY_PARAM_PUB_KEY, NULL, 0, &pub_len) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		if ((pub = malloc(pub_len)) == NULL) {
+			r = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+		if (EVP_PKEY_get_octet_string_param(pk,
+		    OSSL_PKEY_PARAM_PUB_KEY, pub, pub_len, NULL) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		if ((nid = OBJ_sn2nid(curve)) == NID_undef) {
+			r = SSH_ERR_EC_CURVE_INVALID;
+			goto out;
+		}
+		if ((group = EC_GROUP_new_by_curve_name(nid)) == NULL) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		if ((point = EC_POINT_new(group)) == NULL) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		if (EC_POINT_oct2point(group, point, pub, pub_len, NULL) == 0) {
+			r = SSH_ERR_LIBCRYPTO_ERROR;
+			goto out;
+		}
+		prv->ecdsa = pk;
+		pk = NULL; /* Transferred */
 		prv->type = KEY_ECDSA;
 		prv->ecdsa_nid = sshkey_ecdsa_key_to_nid(prv->ecdsa);
 		if (prv->ecdsa_nid == -1 ||
 		    sshkey_curve_nid_to_name(prv->ecdsa_nid) == NULL ||
-		    sshkey_ec_validate_public(EC_KEY_get0_group(prv->ecdsa),
-		    EC_KEY_get0_public_key(prv->ecdsa)) != 0 ||
+		    sshkey_ec_validate_public(group, point) != 0 ||
 		    sshkey_ec_validate_private(prv->ecdsa) != 0) {
 			r = SSH_ERR_INVALID_FORMAT;
 			goto out;
@@ -4698,6 +5361,12 @@ sshkey_parse_private_pem_fileblob(struct sshbuf *blob, int type,
 		prv = NULL;
 	}
  out:
+#ifdef OPENSSL_HAS_ECC
+	EC_GROUP_free(group);
+	EC_POINT_free(point);
+	free(curve);
+	free(pub);
+#endif /* OPENSSL_HAS_ECC */
 	BIO_free(bio);
 	EVP_PKEY_free(pk);
 	sshkey_free(prv);
diff --git a/sshkey.h b/sshkey.h
index 094815e..331f143 100644
--- a/sshkey.h
+++ b/sshkey.h
@@ -29,22 +29,17 @@
 #include <sys/types.h>
 
 #ifdef WITH_OPENSSL
-#include <openssl/rsa.h>
-#include <openssl/dsa.h>
+# include <openssl/evp.h>
 # ifdef OPENSSL_HAS_ECC
-#  include <openssl/ec.h>
-#  include <openssl/ecdsa.h>
+#   include <openssl/ec.h>
 # else /* OPENSSL_HAS_ECC */
-#  define EC_KEY	void
 #  define EC_GROUP	void
 #  define EC_POINT	void
 # endif /* OPENSSL_HAS_ECC */
 #define SSH_OPENSSL_VERSION OpenSSL_version(OPENSSL_VERSION)
 #else /* WITH_OPENSSL */
 # define BIGNUM		void
-# define RSA		void
-# define DSA		void
-# define EC_KEY		void
+# define EVP_PKEY	void
 # define EC_GROUP	void
 # define EC_POINT	void
 #define SSH_OPENSSL_VERSION "without OpenSSL"
@@ -126,12 +121,12 @@ struct sshkey {
 	int	 type;
 	int	 flags;
 	/* KEY_RSA */
-	RSA	*rsa;
+	EVP_PKEY *rsa;
 	/* KEY_DSA */
-	DSA	*dsa;
+	EVP_PKEY *dsa;
 	/* KEY_ECDSA and KEY_ECDSA_SK */
 	int	 ecdsa_nid;	/* NID of curve */
-	EC_KEY	*ecdsa;
+	EVP_PKEY *ecdsa;
 	/* KEY_ED25519 and KEY_ED25519_SK */
 	u_char	*ed25519_sk;
 	u_char	*ed25519_pk;
@@ -223,10 +218,10 @@ int		 sshkey_curve_name_to_nid(const char *);
 const char *	 sshkey_curve_nid_to_name(int);
 u_int		 sshkey_curve_nid_to_bits(int);
 int		 sshkey_ecdsa_bits_to_nid(int);
-int		 sshkey_ecdsa_key_to_nid(EC_KEY *);
+int		 sshkey_ecdsa_key_to_nid(EVP_PKEY *);
 int		 sshkey_ec_nid_to_hash_alg(int nid);
 int		 sshkey_ec_validate_public(const EC_GROUP *, const EC_POINT *);
-int		 sshkey_ec_validate_private(const EC_KEY *);
+int		 sshkey_ec_validate_private(const EVP_PKEY *);
 const char	*sshkey_ssh_name(const struct sshkey *);
 const char	*sshkey_ssh_name_plain(const struct sshkey *);
 int		 sshkey_names_valid2(const char *, int);
@@ -254,7 +249,7 @@ int	 sshkey_get_sigtype(const u_char *, size_t, char **);
 
 /* for debug */
 void	sshkey_dump_ec_point(const EC_GROUP *, const EC_POINT *);
-void	sshkey_dump_ec_key(const EC_KEY *);
+void	sshkey_dump_ec_key(const EVP_PKEY *);
 
 /* private key parsing and serialisation */
 int	sshkey_private_serialize(struct sshkey *key, struct sshbuf *buf);
@@ -274,7 +269,8 @@ int	sshkey_parse_pubkey_from_private_fileblob_type(struct sshbuf *blob,
     int type, struct sshkey **pubkeyp);
 
 /* XXX should be internal, but used by ssh-keygen */
-int ssh_rsa_complete_crt_parameters(struct sshkey *, const BIGNUM *);
+int ssh_rsa_complete_crt_parameters(const BIGNUM *, const BIGNUM *,
+    const BIGNUM *, BIGNUM **, BIGNUM **);
 
 /* stateful keys (e.g. XMSS) */
 int	 sshkey_set_filename(struct sshkey *, const char *);
@@ -324,13 +320,10 @@ int ssh_xmss_verify(const struct sshkey *key,
 #endif
 
 #if !defined(WITH_OPENSSL)
-# undef RSA
-# undef DSA
-# undef EC_KEY
+# undef EVP_PKEY
 # undef EC_GROUP
 # undef EC_POINT
 #elif !defined(OPENSSL_HAS_ECC)
-# undef EC_KEY
 # undef EC_GROUP
 # undef EC_POINT
 #endif
diff --git a/umac.c b/umac.c
index a710424..8fb73f4 100644
--- a/umac.c
+++ b/umac.c
@@ -158,13 +158,41 @@ typedef unsigned int	UWORD;  /* Register */
 #ifdef WITH_OPENSSL
 #include "openbsd-compat/openssl-compat.h"
 #ifndef USE_BUILTIN_RIJNDAEL
-# include <openssl/aes.h>
+# include <openssl/evp.h>
 #endif
-typedef AES_KEY aes_int_key[1];
-#define aes_encryption(in,out,int_key)                  \
-  AES_encrypt((u_char *)(in),(u_char *)(out),(AES_KEY *)int_key)
-#define aes_key_setup(key,int_key)                      \
-  AES_set_encrypt_key((const u_char *)(key),UMAC_KEY_LEN*8,int_key)
+typedef struct {
+    unsigned char key[16];
+} _aes_int_key;
+typedef _aes_int_key aes_int_key[1];
+static void _aes_encryption(const unsigned char *in, unsigned char *out,
+                    const _aes_int_key *key)
+{
+    EVP_CIPHER_CTX *ctx;
+    int outl = AES_BLOCK_LEN;
+
+    ctx = EVP_CIPHER_CTX_new();
+    if (ctx == NULL)
+        return;
+
+    if (EVP_EncryptInit(ctx, EVP_aes_128_ecb(), key->key, NULL) == 1 &&
+        EVP_CIPHER_CTX_set_padding(ctx, 0) == 1 &&
+        EVP_EncryptUpdate(ctx, out, &outl, in, AES_BLOCK_LEN) == 1 &&
+	outl == 0 &&
+        EVP_EncryptFinal_ex(ctx, NULL, &outl) == 1) {
+        /* Nothing to do */
+    }
+
+    EVP_CIPHER_CTX_free(ctx);
+}
+static int _aes_key_setup(const unsigned char *key, _aes_int_key *int_key)
+{
+    memcpy(int_key->key, key, sizeof(int_key->key));
+    return 0;
+}
+#define aes_encryption(in, out, key) \
+  _aes_encryption((in), (out), (_aes_int_key *) (key))
+#define aes_key_setup(key, int_key) \
+  _aes_key_setup((key), (_aes_int_key *) (int_key))
 #else
 #include "rijndael.h"
 #define AES_ROUNDS ((UMAC_KEY_LEN / 4) + 6)
